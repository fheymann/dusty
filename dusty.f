CC =====================================================================                            
c     [MN, June,.07]: This is 'dusty2.08-matt.f' with added 
c     Fdiff scale calculation of diffusely heated slab.
c     Optional printout of spectra in W/m2 using flag iPhys                           
c     in 'dusty.inp'. Added Subroutine FdiffScale (called from Star).                                
c     Matt's functions used for integext and Fdiffscale calculation 
c     of externally illuminated sphere.
c     My new additions and comments are labeled with cc! 
c     dusty2.08-Matt.f is with minor changes to a few variable names
c
c -----------------------                                                                           
c     [June,06]: Dusty2.08  Beta-version
c       
c     Corrected bug in intensity output for sphere:  
c     added the missing 4piY^2 factor in Subroutine PrOut. 
c -----------------------                                                                           
c     [Mar,05]: version dusty2.07                                                                   
c -----------------------                                                                           
c   - Increased lambda grid, npL=118 (old npL=105) for better resolution around 10 microns.         
c   - Slab input options: 1) I/O angles in degrees; 2) Choice of 3 forms of input                   
c   - Convolved images option: normalization to the area of the PSF                                 
c     In case of a user supplied PSF profile, the profile is normalized to its area:                
c                   A= Int{2*pi*PSF(x) x}dx in units of x^2                                         
c   - Minor improvements:                                                                           
c     = Power law interpolation is used instead of linear interpolation                             
c       for abs/sca cross-sections from a file (in Subroutine GetOptPr)                             
c       and for the central spectrum when taken from a file in Sub GetSpShape.                      
c     = Increased itlim (# iterations over Td) from 1e4 to 5e4 in Sub RADTRANSF                     
c   - Added external illumination of the spherical shell.                                           
c   - Input of initial (boundary) condition can be either dust temperature Td, or                   
c     flux, Fe, at the inner boundary.                                                              
c   - RDW changes incorporated except Mdot, ve, M> conversion factors.                              
c     Disk option not completely included b/c it needs subroutine arguments                         
c     adjustment for running in Solaris.                                                            
c =====================================================================                             
                                                                                                    
                                                                                                    
c**********************************************************************                             
c     This is the block data with optical constants for the supported                               
c     grain types. It has to be at the beginning of the program.                                    
c     The data was compiled from different sources by Z. Ivezic (1996).                             
c                                                          [MN, Apr'98]                             
c =====================================================================                             
      BLOCK DATA DustChem                                                                           
       IMPLICIT none                                                                                
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER npLnk                                                             
      PARAMETER (npLnk=98)                                                      
      DOUBLE PRECISION n_sil_ow(npLnk),k_sil_ow(npLnk),n_sil_oc(npLnk),         
     &       k_sil_oc(npLnk), n_sil_dl(npLnk), k_sil_dl(npLnk),                 
     &       n_amc_hn(npLnk), k_amc_hn(npLnk), n_sic_pg(npLnk),                 
     &       k_sic_pg(npLnk), n_gr1_dl(npLnk), k_gr1_dl(npLnk),                 
     &       n_gr2_dl(npLnk), k_gr2_dl(npLnk), lam_nk(npLnk)                    
      COMMON /nkdat/ n_sil_ow, k_sil_ow, n_sil_oc, k_sil_oc,                    
     &               n_sil_dl, k_sil_dl, n_amc_hn, k_amc_hn,                    
     &               n_sic_pg, k_sic_pg, n_gr1_dl, k_gr1_dl,                    
     &               n_gr2_dl, k_gr2_dl, lam_nk                                 
      DATA lam_nk/1.00D-02,2.00D-02,3.00D-02,4.00D-02,5.00D-02,                 
     &   6.00D-02,8.00D-02,1.00D-01,1.20D-01,1.50D-01,2.00D-01,2.50D-01,        
     &   3.00D-01,3.60D-01,4.40D-01,5.50D-01,7.00D-01,8.50D-01,1.00D+00,        
     &   1.15D+00,1.30D+00,1.70D+00,2.00D+00,2.20D+00,2.70D+00,3.00D+00,        
     &   3.50D+00,4.00D+00,4.50D+00,5.00D+00,5.50D+00,6.00D+00,6.50D+00,        
     &   7.00D+00,7.50D+00,8.00D+00,8.50D+00,9.00D+00,9.40D+00,9.55D+00,        
     &   9.70D+00,9.85D+00,1.00D+01,1.05D+01,1.10D+01,1.13D+01,1.16D+01,        
     &   1.20D+01,1.25D+01,1.30D+01,1.35D+01,1.40D+01,1.45D+01,1.50D+01,        
     &   1.60D+01,1.70D+01,1.80D+01,1.90D+01,2.00D+01,2.20D+01,2.30D+01,        
     &   2.40D+01,2.50D+01,2.60D+01,2.70D+01,2.80D+01,3.00D+01,3.50D+01,        
     &   4.00D+01,4.50D+01,5.00D+01,5.50D+01,6.00D+01,6.50D+01,7.00D+01,        
     &   7.50D+01,8.00D+01,8.50D+01,9.00D+01,9.50D+01,1.00D+02,1.05D+02,        
     &   1.10D+02,1.20D+02,1.30D+02,1.40D+02,1.50D+02,2.00D+02,2.50D+02,        
     &   3.00D+02,4.00D+02,5.00D+02,7.00D+02,1.30D+03,4.00D+03,1.30D+04,        
     &   2.00D+04,3.60D+04/                                                     
      DATA n_sil_ow/1.81D+00,1.81D+00,1.81D+00,1.81D+00,1.81D+00,               
     &   1.81D+00,1.81D+00,1.81D+00,1.81D+00,1.81D+00,1.81D+00,1.81D+00,        
     &   1.81D+00,1.81D+00,1.82D+00,1.84D+00,1.85D+00,1.85D+00,1.85D+00,        
     &   1.85D+00,1.85D+00,1.87D+00,1.88D+00,1.88D+00,1.89D+00,1.89D+00,        
     &   1.88D+00,1.87D+00,1.87D+00,1.85D+00,1.83D+00,1.81D+00,1.79D+00,        
     &   1.75D+00,1.71D+00,1.64D+00,1.55D+00,1.45D+00,1.40D+00,1.43D+00,        
     &   1.44D+00,1.46D+00,1.51D+00,1.73D+00,1.91D+00,2.00D+00,2.11D+00,        
     &   2.21D+00,2.21D+00,2.16D+00,2.09D+00,2.06D+00,2.03D+00,1.98D+00,        
     &   1.91D+00,1.90D+00,1.96D+00,2.04D+00,2.12D+00,2.27D+00,2.34D+00,        
     &   2.36D+00,2.38D+00,2.40D+00,2.42D+00,2.43D+00,2.45D+00,2.60D+00,        
     &   2.66D+00,2.70D+00,2.74D+00,2.76D+00,2.77D+00,2.79D+00,2.80D+00,        
     &   2.81D+00,2.82D+00,2.83D+00,2.85D+00,2.86D+00,2.87D+00,2.87D+00,        
     &   2.87D+00,2.87D+00,2.88D+00,2.88D+00,2.88D+00,2.89D+00,2.90D+00,        
     &   2.90D+00,2.90D+00,2.90D+00,2.91D+00,2.91D+00,2.91D+00,2.91D+00,        
     &   2.91D+00,2.91D+00/                                                     
      DATA k_sil_ow/9.99D-02,9.99D-02,9.99D-02,9.99D-02,9.99D-02,               
     &   9.99D-02,9.99D-02,9.99D-02,9.99D-02,9.99D-02,9.99D-02,9.99D-02,        
     &   9.99D-02,9.99D-02,9.08D-02,7.17D-02,6.03D-02,5.64D-02,5.46D-02,        
     &   6.12D-02,6.75D-02,7.23D-02,7.33D-02,6.96D-02,6.19D-02,5.88D-02,        
     &   5.48D-02,5.24D-02,5.07D-02,5.14D-02,5.24D-02,5.50D-02,5.79D-02,        
     &   6.36D-02,7.07D-02,9.03D-02,1.31D-01,2.63D-01,4.31D-01,4.96D-01,        
     &   5.60D-01,6.30D-01,7.12D-01,8.10D-01,7.94D-01,7.86D-01,7.68D-01,        
     &   6.13D-01,4.93D-01,3.98D-01,3.74D-01,3.69D-01,3.66D-01,3.72D-01,        
     &   4.39D-01,5.63D-01,6.68D-01,7.23D-01,7.51D-01,7.55D-01,7.34D-01,        
     &   7.10D-01,6.85D-01,6.61D-01,6.37D-01,6.44D-01,6.58D-01,6.28D-01,        
     &   5.78D-01,5.23D-01,4.69D-01,4.34D-01,4.13D-01,3.92D-01,3.70D-01,        
     &   3.49D-01,3.28D-01,3.06D-01,2.85D-01,2.64D-01,2.42D-01,2.37D-01,        
     &   2.32D-01,2.22D-01,2.12D-01,2.02D-01,1.92D-01,1.42D-01,1.00D-01,        
     &   9.09D-02,7.24D-02,5.39D-02,3.79D-02,2.15D-02,7.26D-03,2.39D-03,        
     &   2.39D-03,2.39D-03/                                                     
      DATA n_sil_oc/1.77D+00,1.77D+00,1.77D+00,1.77D+00,1.77D+00,               
     &   1.77D+00,1.77D+00,1.77D+00,1.77D+00,1.77D+00,1.77D+00,1.77D+00,        
     &   1.77D+00,1.77D+00,1.79D+00,1.82D+00,1.83D+00,1.82D+00,1.81D+00,        
     &   1.81D+00,1.81D+00,1.84D+00,1.85D+00,1.86D+00,1.87D+00,1.88D+00,        
     &   1.88D+00,1.87D+00,1.86D+00,1.85D+00,1.83D+00,1.80D+00,1.78D+00,        
     &   1.74D+00,1.69D+00,1.62D+00,1.51D+00,1.39D+00,1.34D+00,1.36D+00,        
     &   1.37D+00,1.39D+00,1.44D+00,1.67D+00,1.86D+00,1.96D+00,2.08D+00,        
     &   2.22D+00,2.23D+00,2.17D+00,2.09D+00,2.04D+00,2.01D+00,1.92D+00,        
     &   1.78D+00,1.73D+00,1.80D+00,1.98D+00,2.17D+00,2.40D+00,2.48D+00,        
     &   2.53D+00,2.58D+00,2.63D+00,2.69D+00,2.70D+00,2.74D+00,2.90D+00,        
     &   2.95D+00,2.98D+00,3.01D+00,3.02D+00,3.03D+00,3.03D+00,3.03D+00,        
     &   3.04D+00,3.04D+00,3.05D+00,3.05D+00,3.05D+00,3.06D+00,3.06D+00,        
     &   3.06D+00,3.06D+00,3.06D+00,3.06D+00,3.06D+00,3.07D+00,3.07D+00,        
     &   3.07D+00,3.07D+00,3.08D+00,3.08D+00,3.08D+00,3.08D+00,3.08D+00,        
     &   3.08D+00,3.08D+00/                                                     
      DATA k_sil_oc/8.95D-02,8.95D-02,8.95D-02,8.95D-02,8.95D-02,               
     &   8.95D-02,8.95D-02,8.95D-02,8.95D-02,8.95D-02,8.95D-02,8.95D-02,        
     &   8.95D-02,8.95D-02,8.23D-02,6.64D-02,5.09D-02,4.46D-02,4.69D-02,        
     &   6.37D-02,7.89D-02,9.62D-02,1.03D-01,1.00D-01,9.27D-02,8.97D-02,        
     &   8.50D-02,8.14D-02,7.85D-02,7.80D-02,7.77D-02,8.06D-02,8.40D-02,        
     &   8.91D-02,9.51D-02,1.10D-01,1.48D-01,2.95D-01,4.78D-01,5.49D-01,        
     &   6.19D-01,6.96D-01,7.87D-01,9.11D-01,9.10D-01,9.14D-01,9.07D-01,        
     &   7.40D-01,5.94D-01,4.74D-01,4.39D-01,4.28D-01,4.20D-01,4.35D-01,        
     &   5.35D-01,7.36D-01,9.52D-01,1.10D+00,1.13D+00,1.07D+00,1.04D+00,        
     &   1.01D+00,0.97D+00,0.94D+00,8.98D-01,8.77D-01,8.42D-01,7.52D-01,        
     &   6.60D-01,5.68D-01,4.75D-01,4.25D-01,4.04D-01,3.82D-01,3.60D-01,        
     &   3.39D-01,3.17D-01,2.96D-01,2.74D-01,2.52D-01,2.31D-01,2.26D-01,        
     &   2.21D-01,2.12D-01,2.02D-01,1.92D-01,1.83D-01,1.35D-01,9.44D-02,        
     &   8.56D-02,6.82D-02,5.07D-02,3.57D-02,2.02D-02,6.82D-03,2.29D-03,        
     &   2.29D-03,2.29D-03/                                                     
      DATA n_sil_dl/8.66D-01,8.66D-01,8.66D-01,8.25D-01,7.81D-01,               
     &   8.90D-01,1.29D+00,1.60D+00,1.87D+00,2.26D+00,1.93D+00,1.80D+00,        
     &   1.76D+00,1.74D+00,1.73D+00,1.72D+00,1.72D+00,1.71D+00,1.71D+00,        
     &   1.71D+00,1.71D+00,1.71D+00,1.71D+00,1.71D+00,1.70D+00,1.70D+00,        
     &   1.69D+00,1.68D+00,1.66D+00,1.64D+00,1.60D+00,1.57D+00,1.52D+00,        
     &   1.47D+00,1.34D+00,1.21D+00,1.16D+00,1.11D+00,1.20D+00,1.24D+00,        
     &   1.30D+00,1.35D+00,1.39D+00,1.57D+00,1.75D+00,1.82D+00,1.90D+00,        
     &   2.00D+00,2.04D+00,2.09D+00,2.04D+00,2.00D+00,1.91D+00,1.82D+00,        
     &   1.73D+00,1.69D+00,1.71D+00,1.78D+00,1.89D+00,2.04D+00,2.11D+00,        
     &   2.18D+00,2.26D+00,2.30D+00,2.35D+00,2.40D+00,2.50D+00,2.63D+00,        
     &   2.76D+00,2.89D+00,3.02D+00,3.07D+00,3.13D+00,3.18D+00,3.23D+00,        
     &   3.25D+00,3.27D+00,3.29D+00,3.31D+00,3.33D+00,3.35D+00,3.35D+00,        
     &   3.36D+00,3.37D+00,3.38D+00,3.39D+00,3.40D+00,3.41D+00,3.42D+00,        
     &   3.42D+00,3.43D+00,3.43D+00,3.43D+00,3.43D+00,3.43D+00,3.43D+00,        
     &   3.43D+00,3.43D+00/                                                     
      DATA k_sil_dl/1.39D-01,1.39D-01,1.39D-01,2.55D-01,4.29D-01,               
     &   6.73D-01,8.78D-01,9.26D-01,7.22D-01,5.30D-01,5.32D-02,2.77D-02,        
     &   2.84D-02,2.88D-02,2.91D-02,2.94D-02,2.97D-02,3.00D-02,3.03D-02,        
     &   3.06D-02,3.09D-02,3.21D-02,3.31D-02,3.39D-02,3.60D-02,3.72D-02,        
     &   3.94D-02,4.11D-02,4.25D-02,4.40D-02,4.72D-02,5.05D-02,5.36D-02,        
     &   5.66D-02,1.14D-01,1.71D-01,3.68D-01,5.66D-01,7.65D-01,8.29D-01,        
     &   8.71D-01,8.97D-01,9.24D-01,9.63D-01,1.00D+00,9.65D-01,9.28D-01,        
     &   8.78D-01,7.71D-01,6.63D-01,5.70D-01,4.77D-01,4.83D-01,4.88D-01,        
     &   5.83D-01,7.14D-01,8.55D-01,9.76D-01,1.05D+00,1.08D+00,1.10D+00,        
     &   1.11D+00,1.13D+00,1.12D+00,1.12D+00,1.12D+00,1.11D+00,1.06D+00,        
     &   1.01D+00,9.66D-01,9.19D-01,8.66D-01,8.13D-01,7.59D-01,7.06D-01,        
     &   6.72D-01,6.38D-01,6.03D-01,5.69D-01,5.35D-01,5.00D-01,4.83D-01,        
     &   4.67D-01,4.33D-01,3.99D-01,3.65D-01,3.32D-01,2.48D-01,2.06D-01,        
     &   1.65D-01,1.32D-01,9.87D-02,7.04D-02,3.83D-02,2.46D-02,2.46D-02,        
     &   2.46D-02,2.46D-02/                                                     
      DATA n_amc_hn/8.40D-01,8.40D-01,8.40D-01,8.40D-01,7.40D-01,               
     &   6.90D-01,9.30D-01,1.53D+00,1.74D+00,1.55D+00,1.22D+00,1.40D+00,        
     &   1.60D+00,1.71D+00,1.78D+00,1.85D+00,1.94D+00,2.01D+00,2.11D+00,        
     &   2.21D+00,2.31D+00,2.50D+00,2.63D+00,2.70D+00,2.82D+00,2.86D+00,        
     &   2.95D+00,3.03D+00,3.04D+00,3.04D+00,3.09D+00,3.15D+00,3.16D+00,        
     &   3.16D+00,3.25D+00,3.35D+00,3.38D+00,3.42D+00,3.47D+00,3.49D+00,        
     &   3.51D+00,3.53D+00,3.55D+00,3.59D+00,3.63D+00,3.65D+00,3.67D+00,        
     &   3.70D+00,3.73D+00,3.75D+00,3.79D+00,3.84D+00,3.86D+00,3.88D+00,        
     &   3.96D+00,3.99D+00,4.10D+00,4.14D+00,4.18D+00,4.26D+00,4.31D+00,        
     &   4.34D+00,4.36D+00,4.42D+00,4.47D+00,4.50D+00,4.57D+00,4.77D+00,        
     &   4.94D+00,5.11D+00,5.25D+00,5.32D+00,5.44D+00,5.49D+00,5.67D+00,        
     &   5.71D+00,5.85D+00,5.90D+00,5.99D+00,5.94D+00,6.32D+00,6.70D+00,        
     &   6.79D+00,6.99D+00,7.17D+00,7.37D+00,7.55D+00,8.50D+00,9.32D+00,        
     &   1.01D+01,1.15D+01,1.25D+01,1.41D+01,1.65D+01,1.65D+01,1.65D+01,        
     &   1.65D+01,1.65D+01/                                                     
      DATA k_amc_hn/1.08D-01,1.08D-01,1.08D-01,1.08D-01,1.77D-01,               
     &   3.80D-01,9.00D-01,8.40D-01,5.60D-01,1.77D-01,3.21D-01,7.40D-01,        
     &   7.20D-01,6.86D-01,6.70D-01,6.95D-01,7.70D-01,8.25D-01,9.00D-01,        
     &   9.38D-01,9.60D-01,9.95D-01,1.02D+00,1.01D+00,9.96D-01,9.90D-01,        
     &   1.01D+00,1.04D+00,1.04D+00,1.03D+00,1.09D+00,1.15D+00,1.20D+00,        
     &   1.25D+00,1.34D+00,1.42D+00,1.44D+00,1.47D+00,1.50D+00,1.51D+00,        
     &   1.52D+00,1.53D+00,1.54D+00,1.57D+00,1.60D+00,1.61D+00,1.62D+00,        
     &   1.63D+00,1.66D+00,1.69D+00,1.71D+00,1.74D+00,1.76D+00,1.78D+00,        
     &   1.83D+00,1.89D+00,1.95D+00,1.95D+00,1.98D+00,2.05D+00,2.08D+00,        
     &   2.13D+00,2.19D+00,2.23D+00,2.27D+00,2.32D+00,2.40D+00,2.60D+00,        
     &   2.77D+00,2.92D+00,3.00D+00,3.18D+00,3.31D+00,3.50D+00,3.70D+00,        
     &   3.80D+00,4.00D+00,4.15D+00,4.30D+00,4.48D+00,4.59D+00,4.70D+00,        
     &   4.79D+00,4.97D+00,5.15D+00,5.33D+00,5.51D+00,6.41D+00,7.17D+00,        
     &   7.92D+00,9.43D+00,1.04D+01,1.25D+01,1.41D+01,1.41D+01,1.41D+01,        
     &   1.41D+01,1.41D+01/                                                     
      DATA n_sic_pg/7.06D-01,7.06D-01,7.06D-01,7.06D-01,7.06D-01,               
     &   7.06D-01,7.06D-01,7.06D-01,9.69D-01,2.07D+00,4.29D+00,5.16D+00,        
     &   4.75D+00,3.42D+00,2.59D+00,2.55D+00,2.51D+00,2.50D+00,2.47D+00,        
     &   2.49D+00,2.50D+00,2.51D+00,2.55D+00,2.58D+00,2.65D+00,2.69D+00,        
     &   2.73D+00,2.76D+00,2.76D+00,2.77D+00,2.74D+00,2.71D+00,2.67D+00,        
     &   2.63D+00,2.57D+00,2.51D+00,2.42D+00,2.33D+00,2.17D+00,2.11D+00,        
     &   2.04D+00,1.96D+00,1.88D+00,1.56D+00,1.25D+00,1.47D+00,1.69D+00,        
     &   1.99D+00,3.07D+00,4.14D+00,4.21D+00,4.28D+00,4.11D+00,3.93D+00,        
     &   3.71D+00,3.59D+00,3.52D+00,3.49D+00,3.46D+00,3.43D+00,3.42D+00,        
     &   3.40D+00,3.39D+00,3.39D+00,3.39D+00,3.38D+00,3.38D+00,3.38D+00,        
     &   3.39D+00,3.39D+00,3.39D+00,3.40D+00,3.41D+00,3.41D+00,3.42D+00,        
     &   3.42D+00,3.43D+00,3.43D+00,3.44D+00,3.44D+00,3.45D+00,3.45D+00,        
     &   3.46D+00,3.46D+00,3.47D+00,3.48D+00,3.49D+00,3.51D+00,3.52D+00,        
     &   3.52D+00,3.52D+00,3.52D+00,3.52D+00,3.52D+00,3.52D+00,3.52D+00,        
     &   3.52D+00,3.52D+00/                                                     
      DATA k_sic_pg/1.53D+00,1.53D+00,1.53D+00,1.53D+00,1.53D+00,               
     &   1.53D+00,1.53D+00,1.53D+00,1.43D+00,1.28D+00,1.06D+00,3.50D-01,        
     &   2.50D-01,1.62D-01,1.04D-01,1.13D-01,1.21D-01,1.30D-01,1.44D-01,        
     &   1.62D-01,1.80D-01,2.17D-01,2.63D-01,2.76D-01,2.77D-01,2.78D-01,        
     &   2.51D-01,2.23D-01,1.88D-01,1.53D-01,1.22D-01,9.08D-02,8.07D-02,        
     &   7.06D-02,6.69D-02,6.31D-02,6.59D-02,6.87D-02,9.61D-02,1.05D-01,        
     &   1.09D-01,1.24D-01,1.38D-01,5.43D-01,9.48D-01,1.40D+00,1.85D+00,        
     &   2.45D+00,2.45D+00,2.45D+00,1.69D+00,9.19D-01,7.00D-01,4.80D-01,        
     &   3.62D-01,2.90D-01,2.80D-01,2.82D-01,2.70D-01,2.57D-01,2.51D-01,        
     &   2.45D-01,2.38D-01,2.35D-01,2.32D-01,2.29D-01,2.23D-01,2.13D-01,        
     &   2.04D-01,1.94D-01,1.84D-01,1.80D-01,1.75D-01,1.71D-01,1.66D-01,        
     &   1.63D-01,1.60D-01,1.57D-01,1.54D-01,1.51D-01,1.48D-01,1.46D-01,        
     &   1.43D-01,1.39D-01,1.34D-01,1.29D-01,1.25D-01,1.01D-01,9.22D-02,        
     &   8.30D-02,8.30D-02,8.30D-02,8.30D-02,8.30D-02,8.30D-02,8.30D-02,        
     &   8.30D-02,8.30D-02/                                                     
      DATA n_gr1_dl/9.81D-01,9.25D-01,8.48D-01,7.72D-01,7.23D-01,               
     &   7.65D-01,9.91D-01,1.39D+00,2.57D+00,1.94D+00,1.61D+00,1.56D+00,        
     &   1.93D+00,2.17D+00,2.35D+00,2.34D+00,2.29D+00,2.25D+00,2.23D+00,        
     &   2.21D+00,2.20D+00,2.19D+00,2.18D+00,2.17D+00,2.17D+00,2.16D+00,        
     &   2.16D+00,2.15D+00,2.15D+00,2.14D+00,2.13D+00,2.13D+00,2.12D+00,        
     &   2.11D+00,2.10D+00,2.09D+00,2.08D+00,2.07D+00,2.06D+00,2.06D+00,        
     &   2.05D+00,2.05D+00,2.04D+00,2.03D+00,2.01D+00,1.98D+00,2.05D+00,        
     &   2.01D+00,1.99D+00,1.97D+00,1.96D+00,1.95D+00,1.93D+00,1.92D+00,        
     &   1.89D+00,1.87D+00,1.84D+00,1.82D+00,1.80D+00,1.76D+00,1.74D+00,        
     &   1.73D+00,1.72D+00,1.72D+00,1.71D+00,1.71D+00,1.71D+00,1.76D+00,        
     &   1.83D+00,1.92D+00,2.02D+00,2.11D+00,2.21D+00,2.30D+00,2.40D+00,        
     &   2.49D+00,2.57D+00,2.66D+00,2.74D+00,2.82D+00,2.90D+00,2.97D+00,        
     &   3.05D+00,3.19D+00,3.33D+00,3.46D+00,3.58D+00,4.15D+00,4.65D+00,        
     &   5.10D+00,5.90D+00,6.59D+00,7.80D+00,9.33D+00,9.33D+00,9.33D+00,        
     &   9.33D+00,9.33D+00/                                                     
      DATA k_gr1_dl/3.08D-03,2.78D-02,9.28D-02,2.09D-01,3.70D-01,               
     &   5.39D-01,9.54D-01,1.65D+00,6.55D-01,1.94D-01,2.75D-01,6.38D-01,        
     &   8.16D-01,6.57D-01,4.79D-01,2.55D-01,1.41D-01,9.41D-02,6.96D-02,        
     &   5.51D-02,4.60D-02,3.33D-02,2.87D-02,2.68D-02,2.42D-02,2.35D-02,        
     &   2.32D-02,2.36D-02,2.44D-02,2.57D-02,2.72D-02,2.91D-02,3.13D-02,        
     &   3.41D-02,3.74D-02,4.14D-02,4.61D-02,5.16D-02,5.65D-02,5.85D-02,        
     &   6.05D-02,6.26D-02,6.47D-02,7.23D-02,8.11D-02,8.83D-02,9.49D-02,        
     &   9.92D-02,1.10D-01,1.22D-01,1.34D-01,1.47D-01,1.61D-01,1.75D-01,        
     &   2.07D-01,2.42D-01,2.79D-01,3.20D-01,3.63D-01,4.55D-01,5.04D-01,        
     &   5.55D-01,6.06D-01,6.59D-01,7.11D-01,7.64D-01,8.68D-01,1.11D+00,        
     &   1.33D+00,1.52D+00,1.69D+00,1.85D+00,1.99D+00,2.11D+00,2.23D+00,        
     &   2.34D+00,2.44D+00,2.54D+00,2.63D+00,2.72D+00,2.81D+00,2.89D+00,        
     &   2.97D+00,3.12D+00,3.27D+00,3.40D+00,3.53D+00,4.12D+00,4.62D+00,        
     &   5.08D+00,5.88D+00,6.58D+00,7.79D+00,9.32D+00,9.32D+00,9.32D+00,        
     &   9.32D+00,9.32D+00/                                                     
      DATA n_gr2_dl/9.80D-01,9.20D-01,8.39D-01,7.64D-01,5.55D-01,               
     &   5.43D-01,1.01D+00,2.08D+00,1.87D+00,1.27D+00,6.88D-01,1.25D+00,        
     &   2.39D+00,2.58D+00,2.66D+00,2.74D+00,2.87D+00,3.03D+00,3.19D+00,        
     &   3.34D+00,3.47D+00,3.76D+00,3.94D+00,4.05D+00,4.29D+00,4.43D+00,        
     &   4.64D+00,4.82D+00,4.99D+00,5.14D+00,5.29D+00,5.43D+00,5.57D+00,        
     &   5.69D+00,5.80D+00,5.90D+00,6.01D+00,6.11D+00,6.20D+00,6.22D+00,        
     &   6.25D+00,6.28D+00,6.31D+00,6.39D+00,6.47D+00,6.52D+00,6.56D+00,        
     &   6.62D+00,6.67D+00,6.74D+00,6.81D+00,6.89D+00,6.96D+00,7.03D+00,        
     &   7.15D+00,7.26D+00,7.36D+00,7.46D+00,7.53D+00,7.83D+00,7.99D+00,        
     &   8.13D+00,8.25D+00,8.47D+00,8.73D+00,9.01D+00,9.60D+00,1.14D+01,        
     &   1.35D+01,1.59D+01,1.88D+01,2.13D+01,2.33D+01,2.48D+01,2.59D+01,        
     &   2.66D+01,2.70D+01,2.70D+01,2.66D+01,2.62D+01,2.56D+01,2.46D+01,        
     &   2.34D+01,2.05D+01,1.75D+01,1.49D+01,1.33D+01,1.33D+01,1.68D+01,        
     &   2.11D+01,3.02D+01,3.89D+01,5.47D+01,7.40D+01,7.40D+01,7.40D+01,        
     &   7.40D+01,7.40D+01/                                                     
      DATA k_gr2_dl/3.09D-03,2.79D-02,9.38D-02,1.36D-01,3.62D-01,               
     &   7.20D-01,1.48D+00,1.24D+00,3.38D-01,2.77D-01,1.09D+00,2.27D+00,        
     &   2.08D+00,1.67D+00,1.56D+00,1.56D+00,1.68D+00,1.82D+00,1.94D+00,        
     &   2.03D+00,2.12D+00,2.33D+00,2.48D+00,2.58D+00,2.82D+00,2.96D+00,        
     &   3.18D+00,3.39D+00,3.60D+00,3.79D+00,4.00D+00,4.19D+00,4.37D+00,        
     &   4.55D+00,4.72D+00,4.91D+00,5.09D+00,5.27D+00,5.41D+00,5.46D+00,        
     &   5.50D+00,5.55D+00,5.60D+00,5.77D+00,5.94D+00,6.04D+00,6.14D+00,        
     &   6.27D+00,6.44D+00,6.63D+00,6.82D+00,7.00D+00,7.17D+00,7.35D+00,        
     &   7.69D+00,8.05D+00,8.42D+00,8.80D+00,9.24D+00,1.01D+01,1.05D+01,        
     &   1.10D+01,1.15D+01,1.20D+01,1.24D+01,1.29D+01,1.38D+01,1.59D+01,        
     &   1.76D+01,1.90D+01,1.95D+01,1.92D+01,1.83D+01,1.73D+01,1.62D+01,        
     &   1.50D+01,1.38D+01,1.26D+01,1.16D+01,1.08D+01,9.98D+00,9.24D+00,        
     &   8.73D+00,8.70D+00,9.94D+00,1.24D+01,1.54D+01,2.94D+01,3.95D+01,        
     &   4.78D+01,6.08D+01,7.09D+01,8.61D+01,1.03D+02,1.03D+02,1.03D+02,        
     &   1.03D+02,1.03D+02/                                                     
                                                                                
      END                                                                                           
                                                                                                    
      BLOCK DATA InitConst                                                                          
       IMPLICIT none                                                                                
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                                     
       COMMON /constants/ Pi, sigma, Gconst, r_gd                                                   
       DATA Pi/3.14159265359D+00/, sigma/5.67D-08/, Gconst/6.67D-11/,                                   
     &      r_gd/2.0D+02/                                                                           
      END                                                                                           
                                                                                                    
c =====================================================================                             
                                                                                                    
c **********************************************************************                            
      program Dusty                                                                                 
c =====================================================================                             
c This program solves the continuum radiative transfer problem for a                                
c spherically symmetric envelope or for a planD-parallel slab. Only this                            
c file needs to be compiled. It is assumed that all input data are given                            
c in files named *.inp, and that the list of these files is given in a                              
c master input file dusty.inp. For details see the Manual.                                          
c                                                       [Z.I. and M.N.]                             
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      CHARACTER*4 version                                                                           
      CHARACTER*235 dustyinpfile,arg 
      CHARACTER*235 path, apath                                                                     
      CHARACTER*235 nameIn, nameOut, nameQ(npG), nameNK(10)                                         
      INTEGER error, nG, model, Nmodel, GridType, io1, Empty, lpath,                                
     &        Nrec, lambdaOK                                                                        
c     Nrec is the max number of records for TAUgrid in a file                                       
      PARAMETER (Nrec = 1000)                                                                       
      DOUBLE PRECISION ETAzp(npP,npY), TAUin(Nrec), TAU1, TAU2, RDINP                               
      LOGICAL Equal                                                                                 
      Equal = .True.                                                                                
c ----------------------------------------------------------------------                            
c      call setfpu
c     **************************                                                                    
c     *** ABOUT THIS VERSION ***                                                                    
c     **************************                                                                    
      version= '2.08copy1'                                                                               

c     version 2.08: needs testing to prepare the final release ver.
c     version 2.07: to be the final release version. Fixed dyn output.                              
c     version 2.06: added diffuse external illumination of the sph.shell.                           
c                   dynamics subroutines updated according to EI'01.                                
c     version 2.05: with optional Fe1 or T1 input.                                                  
c     Zeljko's and Moshe's changes to dynamics need to be added.                                    
                                                                                                    
c     Updated versions of Dusty(2.0) with minor changes and bug fixes                               
c     start from 2.01.                                                                              
                                                                                                    
c     Version (2.0) is the first public release. The code has been                                  
c     significantly improved in terms of speed and I/O options. All                                 
c     suggestions of the users of version(1.0) had been taken into                                  
c     consideration. Finished Oct.'99                                                               
                                                                                                    
c     Version 1.0 is a beta version sent to a few people before the                                 
c     first public release.  Finished Nov,'96.                                                      
                                                                                                    
c     ********************  MAIN  *******************************                                   
c     first read lambda grid                                                                        
      CALL CHECKLAM(lambdaOK)                                                                       
      IF (lambdaOK.EQ.0) THEN                                                                       
         goto 999                                                                                   
      END IF                                                                                        
c     open master input file dusty.inp       
cc     Matt's addition for multiple runs
      call getarg(1,arg)
      if(arg.ne."")then
        READ(arg,'(A)')dustyinpfile
      else
        dustyinpfile="dusty.inp"
      endif
cc      READ(5,*)dustyinpfile
      open(13,ERR=998,file=dustyinpfile,STATUS='OLD')

c     open master input file dusty.inp                                                              
Cc      open(13,ERR=998,file='dusty.inp',STATUS='OLD')                                                
      io1 = 0                                                                                       
c     read the verbose mode                                                                         
      iVerb = RDINP(Equal,13)                                                                       
cc!   added Jun'07:
c     read flag for spectra in W/m^2                                                                
      iPhys = RDINP(Equal,13)                                                                       
c     loop over input files                                                                         
      DO WHILE (io1.GE.0)                                                                           
c       read a line from master input file using                                                    
100     read(13,'(a)',iostat=io1) apath                                                             
        if(io1.lt.0) then                                                                           
         stop                                                                                       
        end if                                                                                      
        CALL Clean(apath, path, lpath)                                                              
c       if not EOF and if line is not empty, or commented, proceed                                  
        IF (Empty(path).NE.1) THEN                                                                  
c         get input/output file names                                                               
          CALL ATTACH(path,lpath,'.inp',nameIn)                                                     
          CALL ATTACH(path,lpath,'.out',nameOut)                                                    
c         read input data                                                                           
          CALL Input(nameIn,nG,nameOut,nameQ,nameNK,                                                
     &               TAU1,TAU2,TAUin,Nrec,GridType,Nmodel,error,version)                            
           IF (iVerb.GT.0)                                                                          
     &          write(*,'(a24,a235)') ' Working on Input File: ',nameIn                             
           IF (iVerb.EQ.2) write(*,*) 'Done with Reading Input'                                     
c         if an error reading files go to the next input file                                       
c         error=3 means some files are missing                                                      
          IF (error.EQ.3) goto 100                                                                  
c         get optical properties                                                                    
          CALL getOptPr(nG,nameQ,nameNK,error)                                                      
c         if an error reading files go to the next input file                                       
          IF (error.EQ.3) goto 100                                                                  
          IF (iVerb.EQ.2) write(*,*) 'Done with getOptPr'                                           
c         solve for every model                                                                     
          DO model = 1, Nmodel                                                                      
           IF (iVerb.GT.0)  write(*,'(a9,i4)') ' model = ',model                                    
           IF (error.EQ.0) THEN                                                                     
c            open output files                                                                      
             CALL Oppen(model,path,lpath)                                                           
c            calculate optical depth for current model                                              
             CALL GetTau(model,nG,TAU1,TAU2,TAUin,Nrec,GridType,Nmodel)                       
             IF (iVerb.EQ.2)                                                                        
     &          write(*,*) 'Done with GetTau. Going to Solve'                                       
c            solve                                                                                  
             CALL Solve(model,nG,error,ETAzp)                                                       
             IF (error.EQ.0) THEN                                                                   
c              calculate spectral characteristics                                                   
               CALL Spectral(model,denstyp,nL,Lambda)                                               
             IF (iVerb.EQ.2)                                                                        
     &          write(*,*) 'Done with Spectral'                                                     
c              write results out                                                                    
               CALL PrOut(model)                                                                    
             ELSE                                                                                   
              goto 100                                                                              
             END IF                                                                                 
c            close output files                                                                     
             CALL Cllose(error,model,Nmodel)                                                        
           END IF                                                                                   
           IF (iVerb.EQ.2) write(*,*) ' ----------- '                                               
           IF (iVerb.EQ.2) write(*,*) '    '                                                        
c         end of the loop over models                                                               
          END DO                                                                                    
        END IF                                                                                      
c     end of the loop over input files                                                              
      END DO                                                                                        
      IF (iVerb.GT.0) write(*,*) ' End of Input Files '                                             
      close(13)                                                                                     
c     end this run                                                                                  
      goto 999                                                                                      
c     to execute if the master input file is missing                                                
998   write(*,*)' *********** FATAL ERROR IN DUSTY ********************' 
      write(*,*)' * Problem finding input file ',dustyinpfile,'!? '                                    
      write(*,*)' *****************************************************'                                     
c ----------------------------------------------------------------------                            
999   STOP                                                                                          
      END                                                                                           
c **********************************************************************                            
                                                                                                    
c =======================================================================                           
c This is the include file with I/O subroutines              [MN, Apr'99]                           
c =======================================================================                           
C     Table of Contents                                                                             
C                                                                                                   
C     Attach                                                                                        
C     Clean                                                                                         
C     CHECKLAM                                                                                      
C     CLLOSE                                                                                        
C     EMPTY                                                                                         
C     FileMSG                                                                                       
C     GETFS                                                                                         
C     InpStar                                                                                       
C     INPUT                                                                                         
C     InputSLBAng                                                                                   
C     LINE                                                                                          
C     MakeTable                                                                                     
C     MSG                                                                                           
C     OPPEN                                                                                         
C     PrHeader                                                                                      
C     PROUT                                                                                         
C     ReadSpectar                                                                                   
C     RDINP                                                                                         
C     VAL                                                                                           
C     WriteOut                                                                                      
c =======================================================================                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Attach(root,length,ext,fname)                                                      
c     Attaches extensions to the root cleaned by Clean                                              
c =======================================================================                           
      CHARACTER*(*) root, ext, fname                                                                
      INTEGER i, length                                                                             
c -----------------------------------------------------------------------                           
      DO i = 1, LEN(fname)                                                                          
        fname(i:i) = ' '                                                                            
      END DO                                                                                        
      fname(:length) = root(:length)                                                                
      fname(length + 1:) = ext                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Clean(StrIn, StrOut, Length)                                                       
c =======================================================================                           
c     Find meaningful part of StrIn without leading and trailing junk                               
c     It is returned left-justified in StrOut, right-padded with blanks                             
c     The number of meaningful characters is returned in Length.                                    
c     In case of any problems, StrOut is empty. This sub should be used to                          
c     clean every input filename immediately after DUSTY reads it. [ME,'99]                         
c =======================================================================                           
      CHARACTER*(*) StrIn, StrOut                                                                   
      INTEGER i, first, last, Length                                                                
c -----------------------------------------------------------------------                           
      DO i = 1, LEN(StrOut)                                                                         
        StrOut(i:i) = ' '                                                                           
      END DO                                                                                        
      first = 1                                                                                     
      last = LEN(StrIn)                                                                             
      If (first.gt.last) return                                                                     
c     Find end of leading junk:                                                                     
      DO WHILE (StrIn(first:first).LE.' ')                                                          
       first = first + 1                                                                            
       if (first.gt.last) return                                                                    
      END DO                                                                                        
c     Find start of trailing junk:                                                                  
      DO WHILE (StrIn(last:last).LE.' ')                                                            
       last = last - 1                                                                              
       if (last.lt.first) return                                                                    
      END DO                                                                                        
c     Now trim all junk:                                                                            
      StrOut = StrIn(first:last)                                                                    
      Length = last - first + 1                                                                     
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CHECKLAM(lambdaOK)                                                                 
c =======================================================================                           
c This subroutine reads and checks that the wavelength grid satisfies                               
c certain conditions described in the Manual (all wavelengths are given                             
c in microns). If everything went fine it returns lambdaOK = 1, and                                 
c fills the wavelength grid in array lambda passed through COMMON grids2.                           
c                                                  [ZI,Feb'96; MN,Apr'99]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER  iL, Nlam, lambdaOK                                                                   
      DOUBLE PRECISION RDINP                                                                        
      LOGICAL Equal                                                                                 
      Equal = .True.                                                                                
c -----------------------------------------------------------------------                           
c     first open the file with lambda grid                                                          
      open(4, file='lambda_grid.dat', status = 'OLD')                                               
      Nlam = RDINP(Equal,4)                                                                         
      IF (Nlam.NE.npL) THEN                                                                         
        write(*,*)' *************** A BIG ERROR !!! ***************** '                             
        write(*,*)'  The number of wavelengths in lambda_grid.dat is  '                             
        write(*,*)'  not equal to the specified npL in userpar.inc    '                             
        write(*,*)'  Make sure the numbers are the same, recompile    '                             
        write(*,*)'  and try again.                                   '                             
        write(*,*)' ************************************************* '                             
        goto 999                                                                                    
      END IF                                                                                        
c     Initialize lambda array                                                                       
      DO iL = 1, npL                                                                                
        read(4,*,END=99) lambda(iL)                                                                 
      END DO                                                                                        
99    close(4)                                                                                      
      CALL sort(lambda,npL)                                                                         
c     Check the ends of the lambda grid :                                                           
      IF(lambda(1).GT.0.01D+00) THEN                                                                    
        write(*,*)' *************** WARNING! ********************** '                               
        write(*,*)'  The shortest wavelength in lambda_grid.dat has '                               
        write(*,*)'  to be 0.01 microns. Correct this and try again!'                               
        write(*,*)' *********************************************** '                               
        goto 999                                                                                    
      END IF                                                                                        
      IF(lambda(npL).LT.36000.0D+00) THEN                                                                
        write(*,*)' *************** WARNING! ******************* '                                  
        write(*,*)'  The longest wavelength in lambda_grid.dat   '                                  
        write(*,*)'  has to be 3.6e4 um. Correct this and try again!'                               
        write(*,*)' ******************************************** '                                  
        goto 999                                                                                    
      END IF                                                                                        
c     Check the resolution:                                                                         
      DO iL = 2, npL                                                                                
        IF (lambda(iL)/lambda(iL-1).GT.1.51D+00) THEN                                                   
          write(*,*)' ***************** WARNING!  *******************'                              
          write(*,*)' The ratio of two consecutive wavelengths in the'                              
          write(*,*)' grid has to be no bigger than 1.5. You have    '                              
          write(*,'(2(a4,1p,e8.2))') '    ',lambda(iL)/lambda(iL-1),                                
     &                                ' at ', lambda(iL)                                            
          write(*,*)' Correct this and try again!                    '                              
          write(*,*)' ***********************************************'                              
          goto 999                                                                                  
        END IF                                                                                      
      END DO                                                                                        
c     everything is fine                                                                            
      lambdaOK = 1                                                                                  
      goto 111                                                                                      
c     something is wrong                                                                            
999   lambdaOK = 0                                                                                  
c -----------------------------------------------------------------------                           
111   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CLLOSE(error,model,Nmodel)                                                         
c =======================================================================                           
c This subroutine closes output files.             [ZI,Feb'96; MN,Apr'99]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
      CHARACTER*72 su1, su2, s3, s4, txtT, txtF                                                     
      INTEGER  error, model, Nmodel                                                                 
c -----------------------------------------------------------------------                           
c     Close the default output file:                                                                
      IF (iERROR.NE.0.AND.iOUT.EQ.1) THEN                                                           
        write(12,'(a42,i4)')                                                                        
     &                 ' There are some error messages for model:',model                            
        write(12,*)                                                                                 
     &         ' Please check m## file (if not produced then rerun)'                                
      END IF                                                                                        
      IF (iWARNING.NE.0.AND.iOUT.EQ.1.AND.iERROR.EQ.0) THEN                                         
        write(12,'(a36,i4)')                                                                        
     &  ' There are some warnings for model:',model                                                 
        write(12,*)                                                                                 
     &         ' Please check m## file (if not produced then rerun)'                                
      END IF                                                                                        
      iCUMM = iCUMM + iERROR + iWARNING                                                             
      IF (model.EQ.Nmodel.OR.error.EQ.3.OR.error.EQ.4) THEN                                         
      IF (error.NE.3) THEN                                                                          
       su1=                                                                                         
     & ' ============================================================='                             
       su2='============================'                                                           
        IF(RDWA.OR.RDW) THEN                                                                        
          write(12,'(a62,a28)')su1,su2                                                              
        ELSE                                                                                        
         IF(denstyp.NE.0) THEN                                                                      
           write(12,'(a62)')su1                                                                     
         ELSE                                                                                       
        su1=' ========================================================='                            
          IF(ksi.GT.0) THEN                                                                         
           su2='================='                                                                  
           write(12,'(a57,a16)')su1,su2                                                             
          ELSE                                                                                      
           su2='======'                                                                             
           write(12,'(a57,a6)')su1,su2                                                              
          END IF                                                                                    
         END IF                                                                                     
        END IF                                                                                      
        write(12,'(a23,1p,e8.1,a8)')'   (1) Optical depth at',lamfid,                               
     &                              ' microns'                                                      
        IF(SLB) THEN                                                                                
c  ----------  for slab output ----------------------------                                         
      txtF =                                                                                        
     &'  (2) Bol.flux of the left-side source at the slab left boundary'                            
      txtT =                                                                                        
     &'  (2) Dust temperature at the slab left boundary'                                            
         IF(typEntry(1).EQ.1) THEN                                                                  
           write(12,*) txtF                                                                         
         ELSE                                                                                       
           write(12,*) txtT                                                                         
         END IF                                                                                     
         write(12,*)                                                                                
     & '  (3) f1=F/Fi, where F is the overall bol.flux in the slab'                                 

         IF(typEntry(1).EQ.3) THEN                                                                  
         write(12,*)                                                                                
     & '  (4) External bolometrix flux at the slab left boundary'                                    
         ELSE                                                                                       
         write(12,*)                                                                                
     & '  (4) Position of the left slab boundary for L=1E4 Lsun'                                
         END IF 
         write(12,*)                                                                                
     & '  (5) Dust temperature at the right slab face'                                              
         write(12,*)                                                                                
     & '  (6) Effective temperature of the left source (in K)'                                      
         IF(ksi.GT.0.0D+00) THEN                                                                          
           write(12,*)                                                                              
     & '  (7) Effective temperature of the right source (in K)'                                     
           write(12,*)'  (8) Maximum error in flux conservation (%)'                                
         ELSE                                                                                       
           write(12,*)'  (7) Maximum error in flux conservation (%)'                                
         END IF                                                                                     
        ELSE                                                                                        
c    ---------- for spherical shell ----------------------------                                    
         IF(typEntry(1).EQ.1) THEN                                                                  
           write(12,*) '  (2) Bolometric flux at the inner radius '                                 
         ELSE                                                                                       
           write(12,*) '  (2) Dust temperature at the inner radius '                                
         END IF                                                                                     
         IF(typEntry(1).EQ.3) THEN                                                                  
           write(12,*)'  (3) Bolometric flux at the inner radius '                                  
         ELSE                                                                                       
           write(12,*)'  (3) Inner radius for L=1E4 Lsun'                                           
         END IF                                                                                     
         write(12,*)'  (4) Ratio of the inner to the stellar radius'                                
         write(12,*)'  (5) Angular size (in arcsec) when Fbol=1D-6 W/m2'                            
         write(12,*)'  (6) Dust temperature at the outer edge (in K)'                               
         write(12,*)'  (7) Maximum error in flux conservation (%)'                                  
         IF(RDWA.OR.RDW) THEN                                                                       
          write(12,*)'  (8) Mass-loss rate (in Msun/yr)'                                            
          write(12,*)'  (9) Terminal outflow velocity (in km/s)'                                    
          write(12,*)'  (10) Upper limit of the stellar mass (in Msun)'                             
         END IF                                                                                     
        END IF                                                                                      
        write(12,*)'================================================='                              
        IF(iCUMM.EQ.0) write(12,*)' Everything is OK for all models'                                
        IF(iSPP.NE.0) THEN                                                                          
         IF(SLB.AND.iSPP.eq.3) THEN                                                                 
          write(12,*)                                                                               
     & ' Tables with spectral properties are in files *.spp and *.zpp'                              
         ELSE                                                                                       
          write(12,*)' Table with spectral properties is in file *.spp'                             
         END IF                                                                                     
        END IF                                                                                      
c  ---- private file ---                                                                            
        IF(denstyp.EQ.6) THEN                                                                       
          write(12,*)' Table with the wind properties is in file *.rdw'                             
        END IF                                                                                      
c  ------------------------- spectra ------------------                                             
       IF(iA.NE.0) THEN                                                                             
        IF (iA.EQ.1) THEN                                                                           
          write(12,*)' All spectra are in file *.stb'                                               
        ELSE                                                                                        
         IF (SLB.AND.iA.EQ.3) THEN                                                                  
           write(12,*)' Spectra are in files *.s## and *.z##'                                       
         ELSE                                                                                       
           write(12,*)' Spectra are in files *.s##'                                                 
         END IF                                                                                     
        END IF                                                                                      
       END IF                                                                                       
c  ------------------------- images ------------------                                              
       IF (iC.NE.0) THEN                                                                            
        IF (abs(iC).EQ.1) THEN                                                                      
         IF(SLB) THEN                                                                               
          write(12,*)' All intensities are in file *.itb'                                           
         ELSE                                                                                       
          write(12,*)' All imaging quantities are in file *.itb'                                    
         END IF                                                                                     
        ELSE                                                                                        
         IF(SLB) THEN                                                                               
          write(12,*)' Intensities are in files *.i##'                                              
         ELSE                                                                                       
          write(12,*)' Images are in files *.i##'                                                   
         END IF                                                                                     
          IF (iV.NE.0.AND.abs(iC).EQ.3)                                                             
     &      write(12,*)' Visibility curves are in files *.v##'                                      
        END IF                                                                                      
        IF (iC.EQ.-3.AND.iPSF.NE.0) THEN                                                            
          write(12,*)' Convolved images are in files *.c##'                                         
          IF (psftype.LT.3)                                                                         
     &    write(12,*)' Point spread functions are in file *.psf'                                    
        END IF                                                                                      
       END IF                                                                                       
c  ------------------------- radial ------------------                                              
       IF(iB.NE.0) THEN                                                                             
        IF (iB.EQ.1) THEN                                                                           
          write(12,*)' All radial profiles are in file *.rtb'                                       
        ELSE                                                                                        
          write(12,*)' Radial profiles are in files *.r##'                                          
        END IF                                                                                      
       END IF                                                                                       
c  ------------------------- messages ------------------                                            
       IF (iX.EQ.1)                                                                                 
     &     write(12,*)' All run-time messages are in file *.mtb'                                    
       IF (iX.GT.1)                                                                                 
     &     write(12,*)' Run-time messages are in files *.m##'                                       
      ELSE                                                                                          
        write(12,*)' Ending calculations for this input file'                                       
      END IF                                                                                        
      END IF                                                                                        
                                                                                                    
      IF (model.EQ.Nmodel.OR.error.EQ.3.OR.error.EQ.4) THEN                                         
        write(12,*)                                                                                 
     &    '========== THE END =============================='                                       
      END IF                                                                                        
                                                                                                    
c     Table with spectral properties                                                                
      IF (iSPP.NE.0) THEN                                                                           
c       In case of slab: add the zpp table after the spp (if desired)                               
        IF(SLB.AND.model.eq.Nmodel.AND.iSPP.NE.3) THEN                                              
          s3='###   tau0      Psi      fV       fK       f12    C21  '                              
          s4=' C31   C43  b8-13 b14-22 B9.8 B11.4  R9.8-18  '                                       
          write(19,'(a49)')                                                                         
     &              '# ==============================================='                             
          write(19,'(a49)')                                                                         
     &              '# Properties of Spectra from the slab left side  '                             
          write(19,'(a49)')                                                                         
     &              '# -----------------------------------------------'                             
          write(19,'(a55,a46)')s3,s4                                                                
          DO model = 1, Nmodel                                                                      
            write(19,'(a100)') zline(model)                                                         
          END DO                                                                                    
         Close(19)                                                                                  
         Close(24)                                                                                  
        END IF                                                                                      
      END IF                                                                                        
      IF (model.EQ.1.OR.error.EQ.3) THEN                                                            
        IF (iPSF.EQ.1.AND.psftype.LT.3) Close(23)                                                   
      END IF                                                                                        
c     conditionally close the spectral files                                                        
      IF(iA.EQ.1) THEN                                                                              
       IF(model.EQ.Nmodel) close(15)                                                                
      ELSE                                                                                          
       close(15)                                                                                    
      END IF                                                                                        
c     conditionally close the radial files                                                          
      IF(iB.EQ.1) THEN                                                                              
       IF(model.EQ.Nmodel) close(16)                                                                
      ELSE                                                                                          
       close(16)                                                                                    
      END IF                                                                                        
c     conditionally close the imaging files                                                         
      IF(abs(iC).EQ.1) THEN                                                                         
       IF(model.EQ.Nmodel) close(17)                                                                
      ELSE                                                                                          
       close(17)                                                                                    
      END IF                                                                                        
      IF(iX.EQ.1) THEN                                                                              
       IF(model.EQ.Nmodel) close(18)                                                                
      ELSE                                                                                          
       close(18)                                                                                    
      END IF                                                                                        
                                                                                                    
      IF (iPSF.NE.0) Close(21)                                                                      
      IF (iV.NE.0) Close(22)                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      INTEGER FUNCTION EMPTY(line)                                                                  
c =======================================================================                           
c This function is 1 if string 'line' is empty, or if it contains only                              
c '%', and 0 otherwise.                                                                             
c                                                      [Z.I., Nov. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER i, iTeX, l                                                                            
      CHARACTER ch                                                                                  
      CHARACTER*(*) line                                                                            
c -----------------------------------------------------------------------                           
      l = LEN(line)                                                                                 
      EMPTY = 1                                                                                     
      iTeX = 0                                                                                      
      DO i = 1, l                                                                                   
        ch = line(i:i)                                                                              
        IF(EMPTY.EQ.1.AND.ch.EQ.'%') iTeX = 1                                                       
         IF (ch.NE.' ') EMPTY = 0                                                                   
      END DO                                                                                        
      IF (iTeX.EQ.1) EMPTY = 1                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE FileMSG(fname,strg)                                                                
c =======================================================================                           
c     Prints a message in *.out file in case of error opening the user                              
c     supplied files.                                                                               
c =======================================================================                           
      IMPLICIT NONE                                                                                 
      CHARACTER aux*230, strg*(*), fname*(*)                                                        
      INTEGER length, Empty                                                                         
c -----------------------------------------------------------------------                           
1     read(1,'(a)') aux                                                                             
      IF (Empty(aux).EQ.1) goto 1                                                                   
      CALL Clean(aux,fname,length)                                                                  
                                                                                                    
      open(10, ERR=100, FILE=fname, STATUS='OLD')                                                   
      close(10)                                                                                     
      RETURN                                                                                        
                                                                                                    
100   write(12,*)' *** FATAL ERROR IN DUSTY! **************************'                            
      write(12,*)' File with the ',strg                                                             
      write(12,'(a2,a)')'  ',fname                                                                  
      write(12,*)' is missing ?!'                                                                   
      write(12,*)' ****************************************************'                            
      close(12)                                                                                     
c -----------------------------------------------------------------------                           
      STOP                                                                                          
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE GetFS(xx,nm,flag,str)                                                              
c =======================================================================                           
c This subroutine writes number xx to a string str according to a format                            
c f?.nm. Here ? stands for the number of needed places. A blank is                                  
c inserted at the beginning, and for flag.NE.1 another one if number is                             
c positive. If xx<0 second blank is replaced by '-'. For example, for                               
c flag=0 and xx = -0.1234D+02, calling this subroutine with nm=1 will                               
c result in str = ' -12.3', while xx = 0.0123 with nm=3 gives '  0.012'.                            
c If flag=1 minus will be ignored, for example xx = -0.1234D+02 and nm=1                            
c will result in str = ' 12.3',                        [Z.I., Nov. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      CHARACTER ch                                                                                  
      CHARACTER*(*) str                                                                             
      INTEGER  flag, nm, db, i, d(20), j, k, dnmp1                                                  
      DOUBLE PRECISION xx, x, rest                                                                  
c -----------------------------------------------------------------------                           
      DO i = 1, len(str)                                                                            
        str(i:i) = ' '                                                                              
      END DO                                                                                        
                                                                                                    
      x = xx                                                                                        
      str(1:1) = ' '                                                                                
      i = 2                                                                                         
      IF (flag.NE.1) THEN                                                                           
         IF (x.LT.0.0D+0) THEN                                                                         
           str(i:i) = '-'                                                                           
         ELSE                                                                                       
           str(i:i) = ' '                                                                           
         END IF                                                                                     
         i = i + 1                                                                                  
      END IF                                                                                        
      IF (x.LT.0.0D+0) x = -x                                                                          
c     first check if x will have to be rounded up                                                   
c     find (nm+1)-th decimal digit                                                                  
      dnmp1 = int(x*10.0D+00**(nm+1)-int(x*10.0D+00**nm)*10.0D+00)                                                 
      IF (dnmp1.GE.5) x = x + 1./10.0D+00**nm                                                           
      IF (x.GE.1.0) THEN                                                                            
c       number of digits before the decimal sign                                                    
        db = int(log10(x)) + 1                                                                      
c       copy all these digits to str                                                                
        DO j = 1, db                                                                                
          rest = x                                                                                  
          IF (j.GT.1) THEN                                                                          
            DO k = 1, j-1                                                                           
              rest = rest - d(k)*10.0D+00**(db-k)                                                        
            END DO                                                                                  
          END IF                                                                                    
          d(j) = int(rest/10.0D+00**(db-j))                                                              
          write(ch,'(i1)')d(j)                                                                      
          str(i:i) = ch                                                                             
          i = i + 1                                                                                 
        END DO                                                                                      
        rest = rest - d(db)                                                                         
        IF (nm.GT.0) THEN                                                                           
          str(i:i) = '.'                                                                            
          i = i + 1                                                                                 
        END IF                                                                                      
      ELSE                                                                                          
        str(i:i) = '0'                                                                              
        i = i + 1                                                                                   
        IF (nm.GT.0) THEN                                                                           
          str(i:i) = '.'                                                                            
          i = i + 1                                                                                 
        END IF                                                                                      
        rest = x                                                                                    
      END IF                                                                                        
c     now copy all nm remaining decimal digits to str                                               
      IF (nm.GT.0) THEN                                                                             
        DO j = 1, nm                                                                                
          d(j) = int(rest*10.0D+00**j)                                                                   
          IF (j.GT.1) THEN                                                                          
            DO k = 1, j-1                                                                           
              d(j)=d(j)-int(d(k)*10.0D+00**(j-k))                                                        
            END DO                                                                                  
          END IF                                                                                    
          write(ch,'(i1)')d(j)                                                                      
          str(i:i) = ch                                                                             
          i = i + 1                                                                                 
        END DO                                                                                      
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE InpStar(error,is,nameIn)                                                           
c =======================================================================                           
c     This subroutine is for reading the stellar input parameters                                   
c                                                             [MN,Mar'99]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      CHARACTER strg*40, nameIn*(*)                                                                 
      INTEGER error, i, is                                                                          
      DOUBLE PRECISION RDINP, sum, Tsum                                                             
      LOGICAL Equal, NoEqual                                                                        
      Equal = .True.                                                                                
      NoEqual = .False.                                                                             
c ------------------------------------------------------------------------------                    
      error = 0                                                                                     
c     generic temperature for cases other than BB or EngelkD-Marengo shape.                         
      Tstar(is) = 10000.0D+00                                                                          
c     flag for the external spectrum                                                                
      startyp(is) = RDINP(Equal,1)                                                                  
c     if stellar flag is not btw.1 and 6 stop:                                                      
      IF(startyp(is).LT.1 .OR. startyp(is).GT.6) THEN                                               
       CALL MSG(11)                                                                                 
       error = 3                                                                                    
       goto 999                                                                                     
      END IF                                                                                        
c     #1: black body(ies) for startyp=1                                                             
      IF (startyp(is).EQ.1) THEN                                                                    
c       number of black bodies                                                                      
        nBB(is) = RDINP(Equal,1)                                                                    
c       stellar temperature(s)                                                                      
        Tbb(is,1) = RDINP(Equal,1)                                                                  
        IF (nBB(is).GT.1) THEN                                                                      
c       multiple black bodies                                                                       
          Tsum = 0.0D+00                     
          DO i = 2, nBB(is)                                                                         
            Tbb(is,i) = RDINP(NoEqual,1)                                                            
            IF (Tbb(is,i).LE.0.0D+00) THEN                                                              
              CALL MSG(8)                                                                           
              error = 1                                                                             
              GOTO 999                                                                              
            END IF                                                                                  
          END DO                                                                                    
c         read in relative luminosities                                                             
          rellum(is,1) = RDINP(Equal,1)                                                             
          sum = rellum(is,1)                                                                        
          DO i = 2, nBB(is)                                                                         
            rellum(is,i) = RDINP(NoEqual,1)                                                         
            sum = sum + rellum(is,i)                                                                
          END DO                                                                                    
          IF (sum.LE.0.0D+00) THEN                                                                      
             CALL MSG(7)                                                                            
             error = 1                                                                              
             GOTO 999                                                                               
          END IF                                                                                    
c         normalize to 1                                                                            
          DO i = 1, nBB(is)                                                                         
            rellum(is,i) = rellum(is,i) / sum                                                       
            Tsum = Tsum + rellum(is,i)*Tbb(is,i)**4.0D+00                                                 
          END DO                                                                                    
          Tsum= Tsum**0.25D+00                                                                          
          Tstar(is) = Tsum                                                                          
        ELSE                                                                                        
c         this is for a single black body                                                           
          Tstar(is) = Tbb(is,1)                                                                     
          rellum(is,1) = 1.0D+00                                                                        
          IF (Tbb(is,1).LE.0.0D+00) THEN                                                                
             CALL MSG(8)                                                                            
             error = 1                                                                              
             GOTO 999                                                                               
          END IF                                                                                    
c       end if for one or many BB                                                                   
        END IF                                                                                      
c     end if for BB-type                                                                            
      END IF                                                                                        
                                                                                                    
c     #2: EngelkD-Marengo function for startyp=2                                                    
      IF (startyp(is).EQ.2) THEN                                                                    
c        effective stellar temperature                                                              
         Tbb(is,1) = RDINP(Equal,1)                                                                 
         Tstar(is) = Tbb(1,1)                                                                       
c        depth of SiO abs.feature in %                                                              
         xSiO = RDINP(Equal,1)                                                                      
         IF (xSiO.LE.0.0D+00) xSiO = 0.0001D+00                                                             
         IF (xSiO.GT.100.0D+00) xSiO = 100.0D+00                                                            
      END IF                                                                                        
                                                                                                    
c     #3: power-law(s) for startyp=3                                                                
      IF (startyp(is).EQ.3) THEN                                                                    
c       number of transitions                                                                       
        Nlamtr(is)= RDINP(Equal,1)                                                                  
        IF (Nlamtr(is).GT.0) THEN                                                                   
          lamtr(is,1) = RDINP(Equal,1)                                                              
          DO i = 2, Nlamtr(is)+1                                                                    
            lamtr(is,i) = RDINP(NoEqual,1)                                                          
            IF (lamtr(is,i).LT.lamtr(is,i-1)) THEN                                                  
             CALL MSG(6)                                                                            
             error = 1                                                                              
             GOTO 999                                                                               
            END IF                                                                                  
          END DO                                                                                    
          klam(is,1) = RDINP(Equal,1)                                                               
          IF (Nlamtr(is).GT.1) THEN                                                                 
            DO i = 2, Nlamtr(is)                                                                    
              klam(is,i) = RDINP(NoEqual,1)                                                         
            END DO                                                                                  
          END IF                                                                                    
        ELSE                                                                                        
          startyp(is) = 1                                                                           
          Tstar(is) = 10000.0D+00                                                                       
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
c     spectrum from a file for startyp=4,5,6                                                        
c     startyp(is).EQ.4 - file gives lambda*L_lambda                                                 
c     startyp(is).EQ.5 - file gives L_lambda                                                        
c     startyp(is).EQ.6 - file gives Lnu = lambda**2*L_lambda                                        
      IF (startyp(is).GE.4.AND.startyp(is).LE.6) THEN                                               
        strg = 'spectral shape of external radiation:'                                              
        CALL FileMSG(nameStar(is),strg)                                                             
      END IF                                                                                        
                                                                                                    
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE INPUT(nameIn,nG,nameOut,nameQ,nameNK,TAU1,TAU2,TAUin,                              
     &                 Nrec,GridType,Nmodel,error,version)                                          
c =======================================================================                           
c This subroutine reads input data from the file 'filename.inp'. It                                 
c utilizes the subroutine RDINP written by Moshe Elitzur.                                           
c                                                  [ZI,Nov'95; MN,Jan'00]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
      INTEGER Nmu, transmit                                                     
      DOUBLE PRECISION theta(npR),  muobs, tauT, Sfn                             
      COMMON/slbint/ theta,  muobs, tauT, Sfn, Nmu, transmit                    
c      INCLUDE 'disk.inc'                                                                           
      INTEGER ver                                                               
      DOUBLE PRECISION ugas(npY), qF(npY), vrat(npG,npY), Gamma(npY),           
     &       I1, I2, I3, CMdot, Cve, CM, Cr1, G1, Ginf, Prdw, delta,            
     &       winf, Phi, PIrdw, QV, q_star, zeta1, tauFdyn(npY)                  
      COMMON /dyn/ ugas, qF, vrat, Gamma, I1, I2, I3, CMdot, Cve, CM,           
     &       Cr1, G1, Ginf, Prdw, delta, winf, Phi, PIrdw, QV, q_star,          
     &       zeta1, tauFdyn, ver                                                
                                                                                
      CHARACTER LamStr(20)*72, strpow*72, strg*40, version*(*)                                      
      CHARACTER*(*) nameIn,nameOut, nameQ(npG),nameNK(10), namePSF*100,                             
     &         nameTAU*100, ANGgrid*100                                                             
      INTEGER iG, nG, Nmodel, i, EtaOK, error, GridType, istop, nLs,                                
     &        ioverflw, Nrec, Nmax, Nlambdam, Nis, imu, geom, ang_type                              
c     Nmax is the size of user supplied ETA file                                                    
c     Nlambdam is the max number entries for a user supplied stellar spectrum                       
      PARAMETER (Nmax = 1000, Nlambdam = 10000, Nis = 2)                                            
      DOUBLE PRECISION RDINP, TAU1, TAU2, sum, a, b, xx(Nmax), e(Nmax),                             
     &       aa(Nmax), bb(Nmax), TAUin(Nrec), Ceta, x1, psf1, Fi, Fo,                               
     &       Lum, dist, var1, var2, var3, Ji, Jo, Lstar, th1, th2,                                  
     &       lambdaS(Nlambdam), Llamstar(Nlambdam), res                                             
      LOGICAL Equal, NoEqual                                                                        
      Equal = .True.                                                                                
      NoEqual = .False.                                                                             
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
c     open output file                                                                              
      open(12,file=nameOut,STATUS='UNKNOWN')                                                        
      write(12,*)'==========================='                                                      
      write(12,*)' Output from program Dusty '                                                      
      write(12,*)' Version: ',version                                                               
      write(12,*)'==========================='                                                      
      write(12,*)' '                                                                                
      write(12,*)' INPUT parameters from file:'                                                     
      write(12,'(2x,a140)')nameIn                                                                   
      write(12,*)' '                                                                                
c     open input file                                                                               
      open(1,ERR=998,file=nameIn,STATUS='OLD')                                                      
      rewind(1)                                                                                     
                                                                                                    
c     *****************                                                                             
c     ** I. GEOMETRY **                                                                             
c     *****************                                                                             
      geom = RDINP(Equal,1)                                                                         
c     Slab geometry for geom=0                                                                      
c     Spherical for geom=1                                                                          
      IF(geom.eq.0) THEN                                                                            
        SLB = .true.                                                                                
        denstyp = 0                                                                                 
      ELSE                                                                                          
        SLB = .false.                                                                               
c       this is dummy integer, to initialize it when reading/writing                                
c       input data. The real denstyp is read from the .inp file                                     
        denstyp = 9                                                                                 
      END IF                                                                                        
c    (SLB and the rest of the logical variables are in common/density3/)                            
                                                                                                    
c     *****************************                                                                 
c     ** II. PHYSICAL PARAMETERS **                                                                 
c     *****************************                                                                 
c     0) Flags for presence of sources                                                              
c     for slab these have the meaning of "left" and "right" source,                                 
c     keeping these names for convenience; they are in common /stellar/                             
      Left = RDINP(Equal,1)                                                                         
      IF(Left.eq.0) THEN                                                                            
        IF(SLB) THEN                                                                                
          CALL MSG(23)                                                                              
          Left = 1                                                                                  
        END IF                                                                                      
      END IF                                                                                        
      Right = RDINP(Equal,1)                                                                        
                                                                                                    
c     1.1) CENTRAL SOURCE RADIATION (left-side source for slab)                                     
      IF(Left.GT.0) THEN                                                                            
        CALL InpStar(error,1,nameIn)                                                                
        IF(error.NE.0) goto 996                                                                     
c       typEntry is Scale                                                                           
c       typEntry can be 1(Tsub(1)), 2 (Fi), 3(L,r1), 4(Teff)                                        
        typEntry(1)= RDINP(Equal,1)                                                                 
c       check if the entered value is acceptable                                                    
        IF (typEntry(1).LT.1.OR.typEntry(1).GT.4) THEN                                              
          CALL MSG(21)                                                                              
          error = 1                                                                                 
          GOTO 999                                                                                  
        END IF                                                                                      
        IF (typEntry(1).EQ.1) THEN                                                                  
c         typEntry(1)=1: enter dust temperature on inner boundary, T1[K]                            
          Tsub(1) = RDINP(Equal,1)                                                                  
          var1 = Tsub(1)                                                                            
c         in this case Tei (or Fi) is determined from the RE condition                              
c         at the first Y-grid point. The ini.approximation is in                                    
c         InitTemp and Tei is adjusted in FindTemp for ea. Td-iteration.                            
        ELSE IF (typEntry(1).EQ.2) THEN                                                             
           IF (startyp(1).GT.3) THEN                                                                
c            Get the scale of the input flux from the file                                          
             CALL ReadSpectar(lambdaS,Llamstar,Lstar,nLs,1,error)                                   
             dilutn = RDINP(Equal,1)                                                                
             Fi = dilutn*Lstar                                                                      
           ELSE                                                                                     
c            typEntry(1)=2: enter Fi, [W/m2]                                                        
c            N.B. In SLAB case Tei is rD-calculated in this case                                    
c            since the scaling flux is mu1*Fi,the local bol.flux Fi=L/(4*pi*r^2)                    
             Fi = RDINP(Equal,1)                                                                    
           END IF                                                                                   
           Ji = Fi/4.0D+00/Pi                                                                            
           Tei = (Fi/sigma)**0.25D+00                                                                   
           var1 = Fi                                                                                
           var2 = Tei                                                                               
        ELSE IF (typEntry(1).EQ.3) THEN                                                             
c         typEntry(1)=3: enter luminosity,[in Lo] of the source and                                 
c         distance r1,[cm] to the source                                                            
          Lum = RDINP(Equal,1)                                                                      
          dist = RDINP(Equal,1)                                                                     
          var1 = Lum                                                                                
          var2 = dist                                                                               
c         All units in Dusty are in SI, so convert the input                                        
          Lum = Lum * 3.862D+26                                                                     
          dist = dist/100.0D+00                                                                         
c         Cr1 is carried in common/dyn/                                                             
          Cr1 = dist                                                                                
          Fi = Lum / (4.0D+00*Pi*dist*dist)                                                              
          Tei = (Fi/sigma)**0.25D+00                                                                    
        ELSE                                                                                        
c         typEntry(1)=4: enter the effective temperature Tei[K] of the                              
c         illuminating flux Fi = sigma*Tei^4                                                        
          Tei = RDINP(Equal,1)                                                                      
c         Tei is in common /source/                                                                 
          Fi = sigma*Tei**4.0D+00                                                                        
c         var1,var2 are arguments of WriteOut                                                       
          var1 = Tei                                                                                
          var2 = Fi                                                                                 
        END IF                                                                                      
      ELSE                                                                                          
c       if no central source                                                                        
        Tei = 0.0D+00                                                                                   
        typEntry(1) = 0                                                                             
c     end if for presence of central(left) source                                                   
      END IF                                                                                        
c     In case of slab:                                                                              
      IF (SLB) THEN                                                                                 
        write(12,'(a33)') ' Calculation in planar geometry:'                                        
c       ENTER SLAB THETA_IN:                                                                        
c       th1 the left illumination angle (in degrees) measured from the normal                       
        th1 = RDINP(Equal,1)                                                                        
        IF (th1.eq.-1.0D+00) THEN
            write(12,'(a36)')                                                                 
     &               '  Diffuse illumination from the left'                                     
c           in this case th1=-1.0 is a flag for diffuse slab illumination, 
c           mu1is set to -1.0 as a flag as well, not an actual value
            mu1 = -1.0D+00 
          ELSE
            write(12,'(a28,F7.1,a4)')                                                                   
     &                ' left illumination angle = ',th1,' deg'                                      
            CALL ChkAngle(th1)                                                                          
c           convert to radians                                                                          
            th1 = th1*Pi/180.0D+00                                                                          
            mu1 = dcos(th1)                                                                             
         END IF
         IF (typEntry(1).GE.2) THEN                                                                  
c        for oblique illumination the input flux is Fi*mu1,                                         
c        scaling is with this flux. Since mu1 is read here                                          
c        Fi (resp. Tei) need recalculation:                                                         
c        dabs(mu1) to accomodate the case with mu1=-1 (isotropic ill.)                              
         Fi = Fi*dabs(mu1)                                                                          
         Tei = (Fi / sigma)**0.25D+00                                                                   
        END IF                                                                                      
c       even if no second source is supplied, mu2 needs a value                                     
c       of 1 to avoid crashing in the formulae in SLBStar [MN]                                      
        mu2 = 1.0D+00                                                                                    
        ksi = 0.0D+00                                                                                    
      END IF                                                                                        
                                                                                                    
                                                                                                    
c     1.2) EXTERNAL RADIATION (right-side source for slab)                                          
      IF (Right.GT.0) THEN                                                                          
       CALL InpStar(error,2,nameIn)                                                                 
       IF (error.NE.0) goto 996                                                                     
       IF (SLB) THEN                                                                                
c         ksi is the relative bol.flux of the second source                                         
          ksi = RDINP(Equal,1)                                                                      
          IF (ksi.LT.0.0) ksi = 0.0D+00                                                                 
          IF (ksi.GT.1.0) ksi = 1.0D+00                                                                 
          write(12,'(a50,F7.1)')                                                                    
     &   ' Relative bol.flux fraction of right source, R= ',ksi                                     
          th2 = RDINP(Equal,1)                                                                      
          IF (th2.eq.-1.0D+00) THEN
            write(12,'(a37)')                                                                 
     &               '  Diffuse illumination from the right'                                     
c           in this case th2=-1.0 is a flag for diffuse slab illumination, 
c           mu2is set to -1.0 as a flag as well, not an actual value
            mu2 = -1.0D+00
          ELSE
            write(12,'(a28,F7.1,a4)')                                                                   
     &                ' right illumination angle = ',th2,' deg'                                      
            CALL ChkAngle(th2)                                                                          
c           convert to radians                                                                          
            th2 = th2*Pi/180.0D+00                                                                          
            mu2 = dcos(th2)                                                                             
          END IF
       ELSE                                                                                         
c        for sphere:                                                                                
c        typEntry(2) can be 1 (Jo) or 2(dilution factor)                                            
         typEntry(2) = RDINP(Equal,1)                                                               
         IF (typEntry(2).ge.3) THEN                                                                
           CALL MSG(22)                                                                             
           error = 1                                                                                
           GOTO 999                                                                                 
         END IF                                                                                     
         IF (typEntry(2).EQ.1) THEN                                                                 
           IF (startyp(2).GT.3) THEN                                                                
c            If typEntry is 1 by mistake when spectrum is from a file                               
c            warn the user ...                                                                      
             CALL MSG(26)                                                                           
c            ... and get Jo from the file with dilutn=1 (instead of stopping the                    
             CALL ReadSpectar(lambdaS,Llamstar,Lstar,nLs,2,error)                                   
             Jo = Lstar                                                                             
           ELSE                                                                                     
c            if spectrum is analytical profile read Jo[W/m2]                                        
             Jo = RDINP(Equal,1)                                                                    
           END IF                                                                                   
           Fo = Pi*Jo                                                                               
           Teo = (Fo / sigma)**0.25D+00                                                                 
           var3 = Jo                                                                                
         ELSE IF(typEntry(2).EQ.2) THEN                                                             
c          typEntry(2)=2 for entry of dilution (normalization) factor                               
           dilutn = RDINP(Equal,1)                                                                  
           IF (startyp(2).GT.3) THEN                                                                
c            Get the scale of the input flux from the file                                          
             CALL ReadSpectar(lambdaS,Llamstar,Lstar,nLs,2,error)                                   
             Jo = dilutn*Lstar                                                                      
           ELSE                                                                                     
c            for one BB Tstar=Tbb, for any other shape                                              
c            Dusty's default is Tstar =1e4 K.                                                       
             Jo = dilutn* sigma/Pi*Tstar(2)**4.0D+00                                                     
           END IF                                                                                   
           Fo = Pi*Jo                                                                               
           Teo = (Fo / sigma)**0.25D+00                                                                 
c           var3 = dilutn                                                                           
           var3 = Jo                                                                                
         END IF                                                                                     
c      end if for geometry                                                                          
       END IF                                                                                       
      ELSE                                                                                          
c       if no external radiation -- set to 0                                                        
        Teo = 0.0D+00                                                                                   
        typEntry(2) = 0                                                                             
c     end if for second source                                                                      
      END IF                                                                                        
c    =========  END READING OF SOURCE PARAMETERS ===================                                
                                                                                                    
c     2) DUST PROPERTIES                                                                            
c     # of different dust grains, to be used in a future version                                    
      nG = 1                                                                                        
c     2.1 Chemical Composition                                                                      
c     type of optical properties                                                                    
      top = RDINP(Equal,1)                                                                          
      IF (top.NE.1.AND.top.NE.2.AND.top.NE.3) THEN                                                  
        CALL MSG(9)                                                                                 
        error = 1                                                                                   
        GOTO 999                                                                                    
      END IF                                                                                        
c     for top.LT.3 read in abundances for supported grains                                          
      IF (top.LT.3) THEN                                                                            
        xC(1) = RDINP(Equal,1)                                                                      
        IF (xC(1).LT.0.0D+00) xC(1) = 0.0D+00                                                               
        sum = xC(1)                                                                                 
        DO i = 2, 7                                                                                 
c         special care to be taken of graphite (1/3-2/3 rule):                                      
          IF (i.NE.5) THEN
            xC(i) = RDINP(NoEqual,1)
            IF (xC(i).LT.0.0D+00) xC(i) = 0.0D+00
c            this was the graphite bug in old versions                                              
c             IF (i.EQ.4) xC(i) = 2.0D+00*xC(i)/3.0D+00
c            i.eq.4 is data for graphite (parallel to c axis):
c            graphite (parallel to c axis):
             IF(i.EQ.4) xC(i) = 2.0D+00*xC(i)/3.0D+00
          ELSE                                                                                      
c           this was the graphite bug in all previous versions                                      
c            xC(i) = 1.0D+00 * xC(i-1)/3.0D+00
c           graphite (perpendicular to c axis):
            xC(i) = 5.0D-01 * xC(i-1)!/3.0D+00 
          END IF                                                                                    
          sum = sum + xC(i)                                                                         
        END DO                                                                                      
      END IF    
      print*, xC
c     user supplied n and k:                                                                        
      IF (top.EQ.2) THEN                                                                            
        Nfiles = RDINP(Equal,1)                                                                     
c       file names                                                                                  
        strg = 'optical constants:'                                                                 
        DO i = 1, Nfiles                                                                            
          CALL FileMSG(nameNK(i),strg)                                                              
        END DO                                                                                      
        IF(error.NE.0) goto 996                                                                     
c       abundances                                                                                  
        xCuser(1) = RDINP(Equal,1)                                                                  
        IF (xCuser(1).LT.0.0D+00) xCuser(1) = 0.0D+00                                                       
        sum = sum + xCuser(1)                                                                       
        IF (Nfiles.GT.1) THEN                                                                       
          DO i = 2, Nfiles                                                                          
            xCuser(i) = RDINP(NoEqual,1)                                                            
            IF (xCuser(i).LT.0.0D+00) xCuser(i) = 0.0D+00                                                   
            sum = sum + xCuser(i)                                                                   
          END DO                                                                                    
        END IF                                                                                      
      END IF                                                                                        
      IF (top.LT.3) THEN                                                                            
        IF (sum.LE.0.0D+00) THEN                                                                        
          CALL MSG(5)                                                                               
          error = 1                                                                                 
          GOTO 999                                                                                  
        END IF                                                                                      
c       normalize abundances for supported grains:                                                  
        DO i = 1, 7                                                                                 
          xC(i) = xC(i) / sum                                                                       
        END DO                                                                                      
c       normalize abundances for user supplied grains                                               
        IF (top.EQ.2) THEN                                                                          
          DO i = 1, Nfiles                                                                          
            xCuser(i) = xCuser(i) / sum                                                             
          END DO                                                                                    
        END IF                                                                                      
      END IF                                                                                        
c     user supplied cross-sections:                                                                 
      IF (top.EQ.3) THEN                                                                            
c       filename for Qabs and Qsca                                                                  
        strg= 'abs. and scatt. cross-sections:'                                                     
        DO iG = 1, nG                                                                               
          CALL FileMSG(nameQ(iG),strg)                                                              
        END DO                                                                                      
      END IF                                                                                        
                                                                                                    
c     2.2 Grain size distribution                                                                   
      IF (top.NE.3) THEN                                                                            
c       type of size distribution                                                                   
        szds = RDINP(Equal,1)                                                                       
        IF (szds.NE.1.AND.szds.NE.2.AND.szds.NE.3) THEN                                             
          CALL MSG(10)                                                                              
          error = 1                                                                                 
          GOTO 999                                                                                  
        END IF                                                                                      
c       grain sizes                                                                                 
        IF (szds.GT.1) THEN                                                                         
          qsd = RDINP(Equal,1)                                                                      
          a1 = RDINP(Equal,1)                                                                       
          IF (a1.LE.0.0) a1 = 0.0001D+00                                                                
          a2 = RDINP(Equal,1)                                                                       
          IF (szds.EQ.2.AND.a2.LT.a1) a2 = a1                                                       
        ELSE                                                                                        
          qsd = 3.5D+00                                                                                 
          a1 = 0.005D+00                                                                                
          a2 = 0.25D+00                                                                                 
        END IF                                                                                      
      END IF                                                                                        
c    =========  END READING DUST PROPERTIES ===================                                     
                                                                                                    
c     WriteOut prints all input data, read so far, in fname.out                                     
c     var1 is T1,Fe1,Luminosity or Teff; var2 is r1; var3 is ext.rad. input                         
      CALL WriteOut(var1,var2,var3,nG,nameQ,nameNK)                                                 
                                                                                                    
                                                                                                    
c     3) DENSITY DISTRIBUTION                                                                       
c     for sphere:                                                                                   
      IF(geom.NE.0) THEN                                                                            
c      parameter describing eta function:                                                           
       denstyp = RDINP(Equal,1)                                                                     
c      Broken (or smooth) power low                                                                 
       IF (denstyp.EQ.1) THEN                                                                       
        POWD = .true.                                                                               
       ELSE                                                                                         
        POWD = .false.                                                                              
       END IF                                                                                       
c      Exponential density profile                                                                  
       IF(denstyp.eq.2) THEN                                                                        
        EXPD = .true.                                                                               
       ELSE                                                                                         
        EXPD = .false.                                                                              
       END IF                                                                                       
c     *** WINDS ***                                                                                 
c     denstyp.eq.6 is a private option with additional input for v1/ve and                          
c     GravCor=max(Fgrav/Frad);                                                                      
c     for denstyp.eq.3 these have default values of v1/ve=0.2, GravCor=0.5                          
      IF(denstyp.eq.3.OR.denstyp.eq.6) THEN                                                         
        RDW = .true.                                                                                
      ELSE                                                                                          
        RDW = .false.                                                                               
      END IF                                                                                        
c      Analytical (gray) approximation for RDW                                                      
       IF(denstyp.eq.4) THEN                                                                        
        RDWA = .true.                                                                               
       ELSE                                                                                         
        RDWA = .false.                                                                              
       END IF                                                                                       
c      File with user supplied density distribution                                                 
       IF(denstyp.eq.5) THEN                                                                        
        FILD = .true.                                                                               
       ELSE                                                                                         
        FILD = .false.                                                                              
       END IF                                                                                       
                                                                                                    
       EtaOK = 0                                                                                    
       Ntr = 0                                                                                      
c      Read parameters for each type of density distribution                                        
c      smooth or broken power laws                                                                  
       IF (denstyp.EQ.1.OR.POWD) THEN                                                               
        EtaOK = 1                                                                                   
        Ntr = RDINP(Equal,1)                                                                        
c       changed definition                                                                          
        Ntr = Ntr - 1                                                                               
c       read in transition radii                                                                    
        IF (Ntr.GT.0) THEN                                                                          
          Ytr(1) = RDINP(Equal,1)                                                                   
          IF (Ntr.GT.1) THEN                                                                        
            DO i = 2, Ntr                                                                           
              Ytr(i) = RDINP(NoEqual,1)                                                             
            END DO                                                                                  
          END IF                                                                                    
          Yout = RDINP(NoEqual,1)                                                                   
        ELSE                                                                                        
          Yout = RDINP(Equal,1)                                                                     
        END IF                                                                                      
        IF (Yout.LE.1.0D+00) Yout = 1.001D+00                                                               
c       read in powers                                                                              
        pow = RDINP(Equal,1)                                                                        
        IF (Ntr.GT.0) THEN                                                                          
          DO i = 1, Ntr                                                                             
            ptr(i) = RDINP(NoEqual,1)                                                               
          END DO                                                                                    
        END IF                                                                                      
c       print info to the output file                                                               
        IF (Ntr.EQ.0) THEN                                                                          
          CALL getfs(pow,2,0,strpow)                                                                
          write(12,'(a38,a5)')                                                                      
     &      ' Density described by 1/r**k with k =',strpow                                          
          write(12,'(a21,1p,e10.3)')'  Relative thickness:',Yout                                    
        ELSE                                                                                        
          IF (denstyp.EQ.1) THEN                                                                    
            write(12,*)' Density described by smooth power law'                                     
          ELSE                                                                                      
            write(12,*)' Density described by a broken power law:'                                  
          END IF                                                                                    
          write(12,*)'  power   Ytransition'                                                        
          write(12,*)'  -------------------'                                                        
          write(12,*)'              1.0'                                                            
          CALL getfs(pow,2,0,strpow)                                                                
          write(12,'(a2,a5)')'  ',strpow                                                            
          DO i = 1, Ntr                                                                             
            write(12,'(a10,1p,e10.3)')'          ',Ytr(i)                                           
            CALL getfs(ptr(i),2,0,strpow)                                                           
            write(12,'(a2,a5)')'  ',strpow                                                          
          END DO                                                                                    
          write(12,'(a10,1p,e10.3)')'          ',Yout                                               
        END IF                                                                                      
       END IF                                                                                       
c      exponential law                                                                              
       IF (EXPD) THEN                                                                               
        EtaOK = 1                                                                                   
        Yout = RDINP(Equal,1)                                                                       
        IF (Yout.LE.1.0D+00) Yout = 1.001D+00                                                               
        pow = RDINP(Equal,1)                                                                        
        IF (pow.LE.0.0D+00) THEN                                                                        
          EtaOK = 0                                                                                 
          ELSE                                                                                      
          write(12,*)' Density described by exponential distribution'                               
          write(12,'(a21,1p,e10.3)')'               Sigma:',pow                                     
          write(12,'(a21,1p,e10.3)')'  Relative thickness:',Yout                                    
        END IF                                                                                      
       END IF                                                                                       
c      default approximation and default numerics for rad. driven winds                             
       IF (RDWA.OR.RDW) THEN                                                                        
        EtaOK = 1                                                                                   
        Yout = RDINP(Equal,1)                                                                       
        IF (Yout.LE.1.0D+00) Yout = 1.001D+00                                                               
c       ** DEFAULT ** for epsilon = v1/ve = u1/ue:                                                  
        pow = 0.2D+00                                                                                   
        IF(RDW) THEN                                                                                
c         ** DEFAULT ** for Max(GravCor = Fgrav/Frad_press):                                        
          ptr(1) = 0.5D+00                                                                              
c         convergence criterion:                                                                    
          ptr(2) = 1.0D+00                                                                              
c         default linear version of the eq. for velocity                                            
          ver = 1                                                                                   
        END IF                                                                                      
        write(12,*)' Density for radiatively driven winds from'                                     
        IF (RDWA) THEN                                                                              
          write(12,*)' analytic approximation for gray dust.'                                       
        ELSE                                                                                        
          write(12,*)' full dynamic calculation.'                                                   
        END IF                                                                                      
        write(12,'(a21,1p,e10.3)')'  Relative thickness:',Yout                                      
       END IF                                                                                       
c      full dynamical calculation for radiatively driven winds (private option)                     
c      the user can specify parameters that have default values in denstyp=3                        
       IF (denstyp.EQ.6) THEN                                                                       
        EtaOK = 1                                                                                   
c       Yout has been read above                                                                    
c       pow = v1/ve = u1/ue (default value 0.2)                                                     
        pow = RDINP(Equal,1)                                                                        
c       GravCor: Max(GravCor = Fgrav/Frad_press) has default value of 0.5                           
        ptr(1) = RDINP(Equal,1)                                                                     
c       version of velocity equation in Winds: 1) linear; 2) quadratic                              
c       1) has faster convergence                                                                   
        ver = RDINP(Equal,1)                                                                        
c       convergence criterion:                                                                      
        ptr(2) = 1.0D+00                                                                                
c       default limits                                                                              
        IF (ptr(1).GT.1.0D+00) ptr(1) = 0.9999D+00                                                          
        IF (ptr(1).LT.0.0D+00) ptr(1) = 0.0D+00                                                             
        write(12,*)' Extended dynamical input (denstyp.EQ.6)'                                       
        write(12,'(a6,1p,e10.3,a20,e10.3)')                                                         
     &                   '  u1 =',pow,' Gamma^{-1}_{max} =',ptr(1)                                  
        IF (ver.eq.1) THEN                                                                          
          write(12,*)' Linear version of the velocity equation'                                     
        ELSE IF (ver.eq.2) THEN                                                                     
          write(12,*)' Quadratic version of the velocity equation'                                  
        ELSE                                                                                        
          CALL MSG(24)                                                                              
          error = 1                                                                                 
          GOTO 999                                                                                  
        END IF                                                                                      
       END IF                                                                                       
c      user specified table for ETA                                                                 
       IF(FILD) THEN                                                                                
        EtaOK = 1                                                                                   
        strg = 'dust density distribution:'                                                         
        CALL FileMSG(nameETA,strg)                                                                  
        write(12,*)' Density distribution supplied from file:'                                      
        write(12,'(2x,a100)') nameETA                                                               
        CALL PrHeader(3,nameETA)                                                                    
c       read in the density                                                                         
        open(26,ERR=997,file=nameETA,STATUS='OLD')                                                  
c       three lines in the header:                                                                  
        DO i = 1, 3                                                                                 
          read(26,*,ERR=997) strpow                                                                 
        END DO                                                                                      
        istop = 0                                                                                   
        i = 0                                                                                       
        DO WHILE (istop.GE.0)                                                                       
          read(26,*,END=900,ERR=997,iostat=istop) a, b                                              
          IF (istop.GE.0) THEN                                                                      
            i = i + 1                                                                               
            xx(i) = a                                                                               
            e(i) = b                                                                                
            IF (i.EQ.1) x1 = xx(i)                                                                  
            yEtaf(i) = xx(i) / x1                                                                   
          END IF                                                                                    
        END DO                                                                                      
900     close(26)                                                                                   
        nYEtaf = i                                                                                  
        IF (nYEtaf.LT.2) goto 997                                                                   
c       if input positions in descending order turn them around                                     
        IF (yEtaf(1).GT.yEtaf(2)) THEN                                                              
          DO i = 1, nYEtaf                                                                          
            aa(i) = yEtaf(i)                                                                        
            bb(i) = e(i)                                                                            
          END DO                                                                                    
          DO i = 1, nYEtaf                                                                          
            yEtaf(i) = aa(nYEtaf+1-i)                                                               
            e(i) = bb(nYEtaf+1-i)                                                                   
          END DO                                                                                    
        END IF                                                                                      
c       relative thickness                                                                          
        Yout = yEtaf(nYEtaf)                                                                        
        write(12,'(a21,1p,e10.3)')'  Relative thickness:',Yout                                      
        IF (Yout.LE.1.0D+00) Yout = 1.001D+00                                                               
c       integrate and ...                                                                           
        CALL SIMPSON(Nmax,1,nYEtaf,yEtaf,e,Ceta)                                                    
c       ... renormalize                                                                             
        DO i = 1, nYEtaf                                                                            
          Etaf(i) = e(i) / Ceta                                                                     
        END DO                                                                                      
       END IF                                                                                       
c      done with the reading of density distribution                                                
       IF (EtaOK.NE.1) THEN                                                                         
         CALL MSG(3)                                                                                
         error = 1                                                                                  
         GOTO 999                                                                                   
       END IF                                                                                       
       write(12,*)' --------------------------------------------'                                   
      END IF                                                                                        
c    =========  END READING DENSITY DISTRIBUTION ===================                                
                                                                                                    
c     chi is the relative contribution of the external radiation                                    
c     at the outer edge of the sph.shell; it is internal parameter.                                 
c     chi has to be found here since it depends on Ji,Jo and                                        
c     is needed in STAR. It is an internal parameter.                                               
      IF(denstyp.NE.0) THEN                                                                         
        IF(Left.eq.0.AND.Right.eq.1) THEN                                                           
          chi = 1.0D+00                                                                                 
        ELSE IF(Left.eq.1.AND.Right.eq.0) THEN                                                      
          chi = 0.0D+00                                                                                 
        ELSE                                                                                        
          IF(typEntry(1).eq.1) Tei = Tsub(1)*4.0D+00**0.25D+00                                               
          chi = (Teo**4.0D+00) / (0.25D+00*Tei**4.0D+00 + Teo**4.0D+00)                                                
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
c     4) OPTICAL DEPTH                                                                              
c     grid type                                                                                     
      GridType = RDINP(Equal,1)                                                                     
      IF (GridType.EQ.3) THEN                                                                       
c       TAU-grid from a file                                                                        
        strg = 'user supplied TAU-grid:'                                                            
        CALL FileMSG(nameTAU,strg)                                                                  
c       read optical depths                                                                         
        open(27,ERR=992,file=nameTAU,STATUS='OLD')                                                  
c       fiducial wavelength                                                                         
c       (the second argument of RDINP is the unit)                                                  
        lamfid = RDINP(Equal,27)                                                                    
c       number of models in the list                                                                
        Nmodel = RDINP(Equal,27)                                                                    
        DO i = 1, Nmodel                                                                            
          read(27,*) TAUin(i)                                                                       
        END DO                                                                                      
902     close(27)                                                                                   
c       sort the tau-grid if there is more than one model:                                          
        IF(Nmodel.GT.1) THEN                                                                        
          CALL Sort(TAUin,Nmodel)                                                                   
        END IF                                                                                      
        TAU1 = TAUin(1)                                                                             
        IF (TAU1.LE.0.0D+00) TAU1 = 0.0001D+00                                                              
        TAU2 = TAUin(Nmodel)                                                                        
      ELSE                                                                                          
c      fiducial wavelength                                                                          
       lamfid = RDINP(Equal,1)                                                                      
c      total optical depths at lamfid                                                               
       TAU1 = RDINP(Equal,1)                                                                        
       IF (TAU1.LE.0.0D+00) TAU1 = 0.0001D+00                                                               
       TAU2 = RDINP(Equal,1)                                                                        
       IF (TAU2.LE.TAU1) THEN                                                                       
         TAU2 = TAU1                                                                                
         Nmodel = 1                                                                                 
       END IF                                                                                       
c      read number of models                                                                        
       Nmodel = RDINP(Equal,1)                                                                      
c      Nrec = 1000, initialized in main                                                             
       IF (Nmodel.GT.(Nrec-1)) Nmodel = Nrec-1                                                      
       IF (Nmodel.LT.1) Nmodel = 1                                                                  
      END IF                                                                                        
      IF (Nmodel.GT.1) THEN                                                                         
        write(12,'(a19,1p,e8.1,a8)')' Optical depths at',lamfid,                                    
     &                              'microns'                                                       
        write(12,'(a14,1p,e9.2,a3,e9.2)')' ranging from',TAU1,' to',TAU2                            
        IF (GridType.EQ.1) strg=' models with linear grid    '                                      
        IF (GridType.EQ.2) strg=' models with logarithmic grid'                                     
        IF (GridType.EQ.3) strg=' models with grid from file  '                                     
        write(12,'(a1,i4,a)')' ', Nmodel, strg                                                      
        IF (GridType.EQ.3) write(12,'(a4,a70)')'    ',nameTAU                                       
      ELSE                                                                                          
        write(12,'(a18,1p,e8.1,a9,e9.2)')' Optical depth at',lamfid,                                
     &                                  ' microns:',TAU1                                            
      END IF                                                                                        
                                                                                                    
c     5) DISK                                                                                       
c     For disk calculations - make sure you have npX>1                                              
c     in 'userpar.inc' !!!                                                                          
      IF (npX.GT.1) THEN                                                                            
       IF (iVerb.GE.1) write(*,*) 'No disk option in this version'                                  
           GOTO 999                                                                                 
c      remove the above 2 lines after checking the disk option                                      
c      if iD=1 - only fname.d## file; iD=2 - find images and visibilities                           
c       iD = RDINP(Equal,1)                                                                         
cc         stellar temperature to be used in disk calculation                                       
c          TstarD = RDINP(Equal,1)                                                                  
cc         type of boundary condition (1 for T(xout), 2 for xout)                                   
c          bndtype = RDINP(Equal,1)                                                                 
cc         value for boundary condition                                                             
c          bndpar = RDINP(Equal,1)                                                                  
cc         type of viscosity prescription                                                           
cc         (only 1 supported = Lynden-Bell & Pringle model)                                         
c          visctype = RDINP(Equal,1)                                                                
cc         viscosity parameter, for 1 -> Lacc/L*                                                    
c          viscpar = RDINP(Equal,1)                                                                 
cc         a few sanity checks:                                                                     
c          IF (TstarD.LE.0.0.OR.viscpar.LT.0) THEN                                                  
c             CALL MSG(11)                                                                          
c             error = 1                                                                             
c             GOTO 999                                                                              
c          END IF                                                                                   
c          IF (bndtype.EQ.1.AND.                                                                    
c     &       (bndpar.LT.0.0.OR.bndpar.GT.0.84*TstarD)) THEN                                        
c             CALL MSG(11)                                                                          
c             error = 1                                                                             
c             GOTO 999                                                                              
c          END IF                                                                                   
c          IF (bndtype.EQ.2.AND.bndpar.LE.1.0) THEN                                                 
c             CALL MSG(11)                                                                          
c             error = 1                                                                             
c             GOTO 999                                                                              
c          END IF                                                                                   
c          IF ((bndtype.NE.1.AND.bndtype.NE.2).OR.visctype.NE.1) THEN                               
c             CALL MSG(12)                                                                          
c             error = 1                                                                             
c             GOTO 999                                                                              
c          END IF                                                                                   
       END IF                                                                                       
                                                                                                    
c     *****************************                                                                 
c     ** III. NUMERICAL ACCURACY **                                                                 
c     *****************************                                                                 
c     some of the parameters were originally left to user to                                        
c     specify them, most of them are now unchangeable defaults                                      
c     max. increase of scaled TAU/TAUtot                                                            
c      delTAUsc = RDINP(Equal,1)                                                                    
c      IF (delTAUsc.LE.0.0) delTAUsc = 0.3                                                          
      delTAUsc = 0.3D+00                                                                                
c     max. increase in the ratio of two y                                                           
c      facc = RDINP(Equal,1)                                                                        
c      IF (facc.LE.0.0) facc = 2.0                                                                  
      facc = 2.0D+00                                                                                    
c     max allowed ratio of Eta for two consecutive pts.                                             
      EtaRat = 4.0D+00                                                                                  
c      EtaRat = 10.0                                                                                
c     # of rays per radial step                                                                     
c      Nins = RDINP(Equal,1)                                                                        
c      IF (Nins.LE.0) Nins = 2                                                                      
      Nins = 2                                                                                      
c     accuracy for numerical integration in ROMBERG                                                 
c      accRomb = RDINP(Equal,1)                                                                     
c      IF (accRomb.LE.0.0) accRomb = 0.0001                                                         
c      IF (accRomb.GT.0.005) accRomb = 0.005                                                        
      accRomb = 0.0001D+00                                                                              
c     accuracy for flux conservation                                                                
      accuracy = RDINP(Equal,1)                                                                     
      IF (accuracy.LE.0.0D+00) accuracy = 0.02D+00                                                          
c     protect against a very large value for accuracies                                             
      IF (accuracy.GT.0.25D+00) accuracy = 0.25D+00                                                         
c     accuracy for convergence (typical 0.0001)                                                     
      accConv = accuracy / 500.0D+00                                                                    
      accFbol = 10.0D+00*accConv                                                                         
c     dynamical range                                                                               
      dynrange = 1.0D-15                                                                            
      IF (accuracy.GE.0.1) THEN                                                                     
        CALL getfs(accuracy*100.0D+00,0,1,strpow)                                                         
        write(12,'(a20,a3,a1)')' Required accuracy:',strpow,'%'                                     
      ELSE                                                                                          
        CALL getfs(accuracy*100.0D+00,0,1,strpow)                                                         
        write(12,'(a20,a2,a1)')' Required accuracy:',strpow,'%'                                     
      END IF                                                                                        
      write(12,*)' --------------------------------------------'                                    
                                                                                                    
c     **********************                                                                        
c     ** IV. OUTPUT FLAGS **                                                                        
c     **********************                                                                        
c     A flag for additional miscellaneous output  [MN]:                                             
c     If iInn=1: print err.vs.iter in unt=38 (fname.err) for all models                             
c     and additionally list scaled fbol(y) and Ubol(y) in m-files.                                  
      iInn = 1                                                                                      
c     this by default                                                                               
      iOUT = 1                                                                                      
c     spectral properties                                                                           
      iSPP = RDINP(Equal,1)                                                                         
c     spectra                                                                                       
      iA = RDINP(Equal,1)                                                                           
      iC = RDINP(Equal,1)                                                                           
c     images (intensity)                                                                            
      IF (iC.NE.0) THEN                                                                             
       IF (SLB) THEN                                                                                
c        read angular grid (this is theta_out) for slab intensity output.                           
c        The output intensities are in units of lambda*I_lambda*cos(theta_out)/F                    
c        where Fe=L/(4*pi*r^2), the local bolometric flux.                                          
         ang_type = RDINP(Equal,1)                                                                  
c       create the grid depending on grid type                                                      
c       1-equidistant in theta, 2-equidistant in cos(theta), 3-from a file                          
        CALL InputSLBAng(ang_type)                                                                  
c       convert to radians                                                                          
        DO imu = 1, Nmu                                                                             
          theta(imu) = theta(imu)*Pi/180.0D+00                                                          
        END DO                                                                                      
        iV = 0                                                                                      
        iPSF = 0                                                                                    
       ELSE                                                                                         
c      for spherical case                                                                           
        NlambdaOut = RDINP(Equal,1)                                                                 
        IF (NlambdaOut.GE.1) THEN                                                                   
          DO i = 1, NlambdaOut                                                                      
            LambdaOut(i) = RDINP(NoEqual,1)                                                         
c           make sure the wavelengths are inside Dusty's range                                      
            IF (LambdaOut(i).LE.0.01D+00) LambdaOut(i) = 0.01D+00                                           
            IF (LambdaOut(i).GT.36000.0D+00) LambdaOut(i) = 36000.0D+00                                         
          END DO                                                                                    
          ioverflw = 0                                                                              
          DO i = 1, NlambdaOut                                                                      
            IF (LambdaOut(i).LT.0.995D+00) THEN                                                         
              CALL getfs(LambdaOut(i),2,1,LamStr(i))                                                
            ELSE                                                                                    
              IF (LambdaOut(i).LT.9.95D+00) THEN                                                        
               CALL getfs(LambdaOut(i),1,0,LamStr(i))                                               
              ELSE                                                                                  
                IF (LambdaOut(i).LT.99.5D+00) THEN                                                      
                 CALL getfs(LambdaOut(i),0,0,LamStr(i))                                             
                ELSE                                                                                
                 CALL getfs(LambdaOut(i),0,1,LamStr(i))                                             
                END IF                                                                              
              END IF                                                                                
            END IF                                                                                  
            IF (LambdaOut(i).GT.9999.5D+00) THEN                                                        
              ioverflw = 1                                                                          
              strpow = LamStr(i)                                                                    
              strpow(4:4) = '*'                                                                     
              strpow(5:5) = ' '                                                                     
              LamStr(i) = strpow                                                                    
            END IF                                                                                  
          END DO                                                                                    
        END IF                                                                                      
        write(12,*)' Images requested for these wavelengths (mic)'                                  
        write(12,'(a1,20a5)')' ',(LamStr(i),i=1,NlambdaOut)                                         
        IF (ioverflw.EQ.1) write(12,*)'  *: in mm'                                                  
c       convolved images  (only for our use)                                                        
        IF (iC.LT.0) THEN                                                                           
         iPSF = 1                                                                                   
c        iPSF = RDINP(Equal,1)                                                                      
         IF (iPSF.NE.0) THEN                                                                        
           Theta1 = RDINP(Equal,1)                                                                  
           write(12,'(a39,1p,e7.1)')                                                                
     &           ' Convolved images produced for theta1=',Theta1                                    
           psftype = RDINP(Equal,1)                                                                 
           IF (psftype.NE.1.AND.psftype.NE.2.AND.psftype.NE.3) goto 994                             
           IF (psftype.LT.3) THEN                                                                   
c            Gaussians, read in parameters                                                          
c            FWHM for the first component                                                           
             FWHM1(1) = RDINP(Equal,1)                                                              
             IF (NlambdaOut.GT.1) THEN                                                              
               DO i = 2, NlambdaOut                                                                 
                FWHM1(i) = RDINP(NoEqual,1)                                                         
               END DO                                                                               
             END IF                                                                                 
             IF (psftype.EQ.2) THEN                                                                 
c             relative strength for the second component                                            
              kPSF(1) = RDINP(Equal,1)                                                              
              IF (NlambdaOut.GT.1) THEN                                                             
                DO i = 2, NlambdaOut                                                                
                  kPSF(i) = RDINP(NoEqual,1)                                                        
                END DO                                                                              
              END IF                                                                                
c             FWHM for the second component                                                         
              FWHM2(1) = RDINP(Equal,1)                                                             
              IF (NlambdaOut.GT.1) THEN                                                             
                DO i = 2, NlambdaOut                                                                
                  FWHM2(i) = RDINP(NoEqual,1)                                                       
                END DO                                                                              
              END IF                                                                                
             END IF                                                                                 
             write(12,*)' The point spread functions are Gaussians'                                 
           ELSE                                                                                     
c           user supplied PSF                                                                       
            strg = 'point spread function:'                                                         
            CALL FileMSG(namePSF,strg)                                                              
            write(12,*)' The point spread function supplied from file'                              
            write(12,'(2x,a100)')namePSF                                                            
            open(28,ERR=995,file=namePSF,STATUS='OLD')                                              
c           three lines in the header:                                                              
            DO i = 1, 3                                                                             
              read(28,*,ERR=995)                                                                    
            END DO                                                                                  
            istop = 0                                                                               
            i = 0                                                                                   
            DO WHILE (istop.GE.0)                                                                   
              read(28,*,END=901,ERR=995,iostat=istop)a, b                                           
              IF (istop.GE.0) THEN                                                                  
                i = i + 1                                                                           
                IF (i.EQ.1) THEN                                                                    
                  psf1 = b                                                                          
                  IF (a.NE.0.0D+00) goto 995                                                            
                END IF                                                                              
                xpsf(i) = a                                                                         
                ypsf(i) = b / psf1                                                                  
              END IF                                                                                
            END DO                                                                                  
901         close(28)                                                                               
            Npsf = i                                                                                
c           scale to 1 at the center. This is only to get FWHM here.                                
c           ypsf is normalized to area in Sub Convolve [MN]                                           
            CALL ScaleTo1(1000,Npsf,ypsf)                                                           
c           find equivalent FWHM                                                                    
            istop = 0                                                                               
            i = 1                                                                                   
            DO WHILE (istop.EQ.0)                                                                   
              i = i + 1                                                                             
              IF (ypsf(i).LE.0.5D+00) istop = 1                                                         
            END DO                                                                                  
c           linear interpolation                                                                    
            FWHM1(1) = (xpsf(i)-xpsf(i-1))/(ypsf(i)-ypsf(i-1))                                      
            FWHM1(1) = (FWHM1(1)*(0.5D+00-ypsf(i-1))+xpsf(i-1))*2.0D+00                                       
            FWHM2(1) = 0.0D+00                                                                          
            write(12,'(a18,1p,e8.1)')' Equivalent FWHM:',FWHM1(1)                                   
c !!!!!!!!!!! for tests of PSF:                                                                     
c            CALL ScaletoArea(1000,Npsf,xpsf,ypsf,res)                                               
c  	       write(12,'(a11,1p,e12.3)') '  psfArea =', res                                                
c            open (50, file='test-PSF.dat', status='unknown')                                       
c            write(50,*) ' xpsf(i)     yscaled(i) '                                                 
c            DO i = 1, Npsf                                                                         
c               write(50,'(1p,2e12.4)') xpsf(i), ypsf(i)                                            
c            END DO                                                                                 
c            STOP                                                                                   
c !!!!!!!!!!!!!!!!!                                                                                 
c          end if for PSF from a file                                                               
           END IF                                                                                   
c        end if for PSF                                                                             
         END IF                                                                                     
c       end if for convolved images    	                                                            
        END IF                                                                                      
	                                                                                                   
c       visibility (only if the intensity is requested)                                             
        iV = RDINP(Equal,1)                                                                         
        IF(iV.NE.0) iV = abs(iC)                                                                    
c      end if for geometry                                                                          
       END IF                                                                                       
      write(12,*)' --------------------------------------------'                                    
      ELSE                                                                                          
c     if iC=0 set the other flags to 0 (just in case).                                              
       iPSF = 0                                                                                     
       iV = 0                                                                                       
      write(12,*)' --------------------------------------------'                                    
      END IF                                                                                        
c     radial quantities                                                                             
      iB = RDINP(Equal,1)                                                                           
c     run-time messages                                                                             
      iX = RDINP(Equal,1)                                                                           
c     *** DONE ***                                                                                  
c     if everything is OK, close the input file and finish                                          
999   goto 996                                                                                      
c     or in the case of err reading files...                                                        
920   write(12,*)' ***  FATAL ERROR IN DUSTY  *************'                                        
      write(12,*)' File with user supplied angular grid:   '                                        
      write(12,*)'     slab_ang_grid.dat                   '                                        
      write(12,*)' is missing or not properly formatted?!  '                                        
      write(12,*)' ****************************************'                                        
      close(12)                                                                                     
      error = 3                                                                                     
      goto 996                                                                                      
992   write(12,*)' ***  FATAL ERROR IN DUSTY  *************'                                        
      write(12,*)' File with user supplied TAU-grid:       '                                        
      write(12,'(2x,a100)') nameTAU                                                                 
      write(12,*)' is missing or not properly formatted?!  '                                        
      write(12,*)' ****************************************'                                        
      close(12)                                                                                     
      error = 3                                                                                     
      goto 996                                                                                      
994   CALL MSG(12)                                                                                  
      close(12)                                                                                     
      error = 3                                                                                     
      goto 996                                                                                      
995   write(12,*)' ***  FATAL ERROR IN DUSTY  *************'                                        
      write(12,*)' File with the point spread function:    '                                        
      write(12,'(a2,a100)')'  ', namePSF                                                            
      write(12,*)' is missing or not properly formatted?!  '                                        
      write(12,*)' ****************************************'                                        
      close(12)                                                                                     
      error = 3                                                                                     
997   write(12,*)' ***  FATAL ERROR IN DUSTY  *************'                                        
      write(12,*)' File with the dust density distribution:'                                        
      write(12,'(2x,a100)') nameETA                                                                 
      write(12,*)' is missing or not properly formatted?!  '                                        
      write(12,*)' ****************************************'                                        
      close(12)                                                                                     
      error = 3                                                                                     
998   write(12,*)' ***  FATAL ERROR IN DUSTY  ****'                                                 
      write(12,*)' Input file:'                                                                     
      write(12,'(2x,a100)') nameIn                                                                  
      write(12,*)' is missing?!'                                                                    
      write(12,*)' *******************************'                                                 
      close(12)                                                                                     
      error = 3                                                                                     
c -----------------------------------------------------------------------                           
996   close(1)                                                                                      
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE InputSLBAng(ang_type)                                                              
c =======================================================================                           
c     This subroutine reads the set of input or output illumination angles                          
c     for slab case.                                           [MN, 2005]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
      COMMON /constants/ Pi, sigma, Gconst, r_gd
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                          
      INTEGER Nmu, transmit                                                     
      DOUBLE PRECISION theta(npR),  muobs, tauT, Sfn                             
      COMMON/slbint/ theta,  muobs, tauT, Sfn, Nmu, transmit                    
      INTEGER ang_type, error, imu                                                                  
      DOUBLE PRECISION th_min, th_max, AngStep, Cth_min, Cth_max, Caux,                             
     &        RDINP                                                                                 
      CHARACTER*70 ANGgrid, strg                                                                    
      LOGICAL Equal, NoEqual                                                                        
      Equal = .True.                                                                                
      NoEqual = .False.                                                                             
c -----------------------------------------------------------------------                           
c        if ang_type=1 (equidistant in theta, given min,max,step)                                   
         IF (ang_type.eq.1) THEN                                                                    
	     th_min = RDINP(Equal,1)                                                                       
           CALL ChkAngle(th_min)                                                                    
           th_max = RDINP(Equal,1)                                                                  
           CALL ChkAngle(th_max)                                                                    
           IF (th_max.LE.th_min) THEN                                                               
             th_max = th_min                                                                        
             Nmu = 1                                                                                
           END IF                                                                                   
c          step equidistant in theta                                                                
           AngStep = RDINP(Equal,1)                                                                 
c          create the grid:                                                                         
  	     imu = 1                                                                                     
           theta(1)=th_min                                                                          
           DO WHILE(theta(imu).LT.th_max)                                                           
             theta(imu+1) = theta(imu) + AngStep                                                    
	       imu = imu+1                                                                                 
	     END DO                                                                                        
	     Nmu = imu                                                                                     
           theta(Nmu) = th_max                                                                      
         END IF                                                                                     
c        if ang_type=2 (equidistant in cos theta)                                                   
         IF (ang_type.eq.2) THEN                                                                    
           th_min = RDINP(Equal,1)                                                                  
           CALL ChkAngle(th_min)                                                                    
           th_max = RDINP(Equal,1)                                                                  
           CALL ChkAngle(th_max)                                                                    
           Cth_min = dcos(th_min*Pi/180.0D+00)                                                           
           Cth_max = dcos(th_max*Pi/180.0D+00)                                                           
c          step, equidistant in cos(theta)                                                          
           AngStep = RDINP(Equal,1)                                                                 
c          create the grid:                                                                         
  	     imu = 1                                                                                     
	     Caux = Cth_min                                                                                
           DO WHILE (Caux.GT.0.0D+00)                                                                    
             theta(imu) = dacos(Caux)*180.0D+00/Pi                                                       
		   Caux = Caux - AngStep                                                                          
		   imu = imu+1                                                                                    
           END DO                                                                                   
	     Nmu = imu                                                                                     
           theta(Nmu) = th_max                                                                      
         END IF                                                                                     
         IF (ang_type.eq.3) THEN                                                                    
c          angular grid from a file, angles in degrees                                              
           CALL FileMSG(ANGgrid,strg)                                                               
           open(7,ERR=92,file=ANGgrid,STATUS='OLD')                                                 
           Nmu = RDINP(Equal,7)                                                                     
           DO imu = 1, Nmu                                                                          
            read(7,*) theta(imu)                                                                    
           END DO                                                                                   
92         close(7)                                                                                 
         END IF                                                                                     
         write(12,*)' Intensity requested for these theta_out(deg):'                                
         write(12,'(a1,8F7.1,/,x,8F7.1,/,x,10F7.1)')' ',                                            
     &                                (theta(imu), imu = 1, Nmu)                                    
         IF (ang_type.eq.1) write(12,'(a34,F4.1)')                                                  
     &        '  equidistant in theta_out, step=', AngStep                                          
         IF (ang_type.eq.2) write(12,'(a39,F4.1)')                                                  
     &        '  equidistant in cos(theta_out), step=', AngStep                                     
         IF (ang_type.eq.3) write(12,'(a18,a70)')                                                   
     &        '  Grid from file: ', ANGgrid                                                         
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE LINE(com,typ,unt)                                                                  
c =======================================================================                           
c This subroutine writes a line into file open as unt. For type = 1                                 
c the line is '---', and for type = 2 '==='.If com=1 a comment sign # is                            
c added in the beginning (this is when line is used in file headers)                                
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER com, typ, unt                                                                         
c -----------------------------------------------------------------------                           
      IF(typ.EQ.1) THEN                                                                             
       IF(com.eq.1) THEN                                                                            
        write(unt,'(a50)')                                                                          
     &   '# ------------------------------------------------'                                       
       ELSE                                                                                         
        write(unt,*)'--------------------------------------------------'                            
       END IF                                                                                       
      ELSE                                                                                          
       IF(com.eq.1) THEN                                                                            
        write(unt,'(a50)')                                                                          
     &   '# ================================================'                                       
       ELSE                                                                                         
        write(unt,*)'=================================================='                            
       END IF                                                                                       
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MakeTable(Elems,Nrows,Ncols,rows,cols,unt)                                         
c =======================================================================                           
c     This is an auxiliary subroutine for print out of tables                                       
c     of Elems(Nrows,Ncols) in output unit 'unt'. Nrows = max{npL,npY}.                             
c     The array size is defined in Subroutine PrOut.                                                
c                                                       [MN, Mar'98]                                
c =======================================================================                           
      IMPLICIT NONE                                                                                 
      INTEGER Nrows, Ncols, rows, cols, unt, k, i                                                   
      DOUBLE PRECISION Elems(Nrows,Ncols)                                                           
c -----------------------------------------------------------------------                           
      DO k = 1, rows                                                                                
        write(unt,'(1p,21E11.3)') (Elems(k,i),i=1,cols)                                             
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MSG(msgno)                                                                         
c =======================================================================                           
c This subroutine writes runtime messages to auxiliary file fname.m##                               
c or to the output file fname.out.             [ZI,Feb'96; MN,Jul'99]                               
c =======================================================================                           
      IMPLICIT none                                                                                 
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER  msgno                                                                                
c -----------------------------------------------------------------------                           
      IF (msgno.EQ.1.AND.iX.GT.0) THEN                                                              
       write(18,*)' ************  WARNING  ************'                                            
       write(18,*)' Temperature calculation in FindTemp'                                            
       write(18,*)' achieved the limit of 500 iterations'                                           
      END IF                                                                                        
      IF (msgno.EQ.2.AND.iX.GT.0) THEN                                                              
       write(18,*)' ************  WARNING  ************'                                            
       write(18,*)' Energy density iterations in RADTRANSF'                                         
       write(18,*)' achieved the limit of 50000 iterations'                                         
      END IF                                                                                        
      IF (msgno.EQ.3) THEN                                                                          
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' * Denstyp is not between 0 and 5!*'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.4.AND.iX.GT.0) THEN                                                              
       write(18,*)' ************  WARNING  *****************'                                       
       write(18,*)' Could not bracket in Zbrac (in sub FindTemp)'                                   
       write(18,*)' Something might be wrong in your input.     '                                   
      END IF                                                                                        
      IF (msgno.EQ.5) THEN                                                                          
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' *  All abundances must be >= 0!  *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.6) THEN                                                                          
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' * Wavelengths for the power-law  *'                                             
       write(12,*)' * spectrum must be ascending!    *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.7) THEN                                                                          
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' * Relative luminosities must add *'                                             
       write(12,*)' * up to a number >0!!!           *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.8) THEN                                                                          
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' *    A black body temperature    *'                                             
       write(12,*)' *        should be > 0 !!!       *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.9) THEN                                                                          
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' * Flag for optical properties    *'                                             
       write(12,*)' * should be between 1 and 3!!!   *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.10) THEN                                                                         
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' * Flag for size distribution     *'                                             
       write(12,*)' * should be between 1 and 3!!!   *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.11) THEN                                                                         
       write(12,*)' ********** A BIG ERROR ***********'                                             
       write(12,*)' * The flag for external spectrum *'                                             
       write(12,*)' * should be between 1 and 6 !!!  *'                                             
       write(12,*)' * Check input file and try again *'                                             
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
      IF (msgno.EQ.12) THEN                                                                         
       write(12,*)' ***  FATAL ERROR IN DUSTY  **********'                                          
       write(12,*)' Only three types of the point spread '                                          
       write(12,*)' function are allowed: 1, 2 or 3 !!!  '                                          
       write(12,*)' Check input file and try again       '                                          
       write(12,*)' ***********************************'                                            
      END IF                                                                                        
c     msg 14 is not called in this version.                                                         
      IF (msgno.EQ.14.AND.iX.GT.0) THEN                                                             
       write(18,*)' ******** MESSAGE FROM SLBSolve *********'                                       
       write(18,*)' Convergence on en.density is too slow.  '                                       
       write(18,*)' If the accuracy is not reached yet the  '                                       
       write(18,*)' code will increase grid size and try again.'                                    
       write(18,*)' ****************************************'                                       
      END IF                                                                                        
      IF (msgno.EQ.15) THEN                                                                         
       write(12,*) ' ***************** WARNING *******************'                                 
       write(12,*) '  NO calculation for next model. Parameter npY'                                 
       write(12,*) '  needs to be at least 50. Use of the slab    '                                 
       write(12,*) '  parameters is suggested (see userpar.inc)   '                                 
       write(12,*) ' *********************************************'                                 
      END IF                                                                                        
      IF (msgno.EQ.16) THEN                                                                         
       write(12,*)' ****************  WARNING  ******************'                                  
       write(12,*)'  The density profile Eta is too steep and the'                                  
       write(12,*)'  code can not handle this. Try decreasing the'                                  
       write(12,*)'  outer radius Y (see Manual, 3.3.3).         '                                  
       write(12,*)' *********************************************'                                  
       IF(iX.GT.0) THEN                                                                             
       write(18,*)' ****************  WARNING  ******************'                                  
       write(18,*)'  The density profile Eta is too steep and the'                                  
       write(18,*)'  code can not handle this. Try decreasing the'                                  
       write(18,*)'  outer radius Y (see Manual, 3.3.3).         '                                  
       write(18,*)' *********************************************'                                  
       END IF                                                                                       
      END IF                                                                                        
      IF (msgno.EQ.17) THEN                                                                         
       write(12,*)' *****************  WARNING  ********************'                               
       write(12,*)'  Eta is too steep and reaches values less than  '                               
       write(12,*)'  1D-12. Try decreasing the outer radius Y.      '                               
       write(12,*)'  (see Manual,3.3.3)                             '                               
       write(12,*)' ************************************************'                               
       IF(iX.GT.0) THEN                                                                             
       write(18,*)' *****************  WARNING  ********************'                               
       write(18,*)'  Eta is too steep and reaches values less than  '                               
       write(18,*)'  1D-12. Try decreasing the outer radius Y.      '                               
       write(18,*)'  (see Manual,3.3.3)                             '                               
       write(18,*)' ************************************************'                               
       END IF                                                                                       
      END IF                                                                                        
      IF (msgno.EQ.18) THEN                                                                         
       write(12,*)' ************  WARNING  ************************ '                               
       write(12,*)'  Dynamical range of Eta more than 1.D-12.       '                               
       write(12,*)'  The outer radius Y must be decreased so that   '                               
       write(12,*)'  Eta does not go below 1.D-12 (see Manual,3.3.3)'                               
       write(12,*)' *********************************************** '                               
       IF(iX.GT.0) THEN                                                                             
       write(18,*)' ************  WARNING  ************************ '                               
       write(18,*)'  Dynamical range of Eta more than 1.D-12.       '                               
       write(18,*)'  The outer radius Y must be decreased so that   '                               
       write(18,*)'  Eta does not go below 1.D-12 (see Manual,3.3.3)'                               
       write(18,*)' *********************************************** '                               
       END IF                                                                                       
      END IF                                                                                        
      IF (msgno.EQ.19) THEN                                                                         
       write(12,*)' ************ A BIG ERROR!!!************* '                                      
       write(12,*)'  Singular matrix in LUDCMP when called   '                                      
       write(12,*)'  from ANALINT. Stopping the calculation. '                                      
       write(12,*)' **************************************** '                                      
      END IF                                                                                        
      IF (msgno.EQ.20) THEN                                                                         
       write(12,*)' ************ A BIG ERROR!!! ************ '                                      
       write(12,*)'  Singular matrix in LUDCMP when called   '                                      
       write(12,*)'  from INVERT. Stopping the calculation.  '                                      
       write(12,*)' **************************************** '                                      
      END IF                                                                                        
      IF (msgno.EQ.21) THEN                                                                         
       write(12,*)' ************ A BIG ERROR ******************'                                    
       write(12,*)' * The TypD-of-Entry value for the central *'                                    
       write(12,*)' * source has to be between 1 and 4 !!!    *'                                    
       write(12,*)' * Correct your input and try again        *'                                    
       write(12,*)' *******************************************'                                    
      END IF                                                                                        
      IF (msgno.EQ.22) THEN                                                                         
       write(12,*)' ************ A BIG ERROR ***************'                                       
       write(12,*)' * The TypD-of-Entry value for external *'                                       
       write(12,*)' * radiation has to be 1 or 2!          *'                                       
       write(12,*)' * Correct your input and try again!    *'                                       
       write(12,*)' ****************************************'                                       
      END IF                                                                                        
      IF (msgno.EQ.23) THEN                                                                         
       write(12,*)' ******** Message from INPUT: **************'                                    
       write(12,*)' * Left-hand side source is always present *'                                    
       write(12,*)' * in slab geometry. Setting Left=1.       *'                                    
       write(12,*)' *******************************************'                                    
      END IF                                                                                        
      IF (msgno.EQ.24) THEN                                                                         
       write(12,*)' ******** Message from INPUT: ************'                                      
       write(12,*)' * Please choose the version of velocity *'                                      
       write(12,*)' * equation: 1 -linear, 2 -quadratic!    *'                                      
       write(12,*)' * Correct your input and try again!     *'                                      
       write(12,*)' *****************************************'                                      
      END IF                                                                                        
      IF (msgno.EQ.25) THEN                                                                         
       write(12,*)' ************ A BIG ERROR ***************'                                       
       write(12,*)' * The TypD-of-Entry value for spectrum *'                                       
       write(12,*)' * from a file can be only 1 or 2!      *'                                       
       write(12,*)' * Correct your input and try again!    *'                                       
       write(12,*)' ****************************************'                                       
      END IF                                                                                        
      IF (msgno.EQ.26) THEN                                                                         
       write(12,*)' ********** Message from INPUT: *************'                                   
       write(12,*)' * If external spectrum is from a file      *'                                   
       write(12,*)' * typD-of-entry is always 2 (normalization *'                                   
       write(12,*)' * factor). Taking factor = 1               *'                                   
       write(12,*)' ********************************************'                                   
      END IF                                                                                        
c -----------------------------------------------------------------------                           
101   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE OPPEN(model,RootName,length)                                                       
c =======================================================================                           
c This subroutine prints the results out.              [Z.I., Feb. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
      CHARACTER ch5*5, RootName*(*), fname*235                                                      
      CHARACTER*72 header1, s3, s4                                                                  
      INTEGER model, length, i                                                                      
c -----------------------------------------------------------------------                           
c     set up the status indicators                                                                  
      iERROR = 0                                                                                    
      iWARNING = 0                                                                                  
      IF (model.EQ.1) iCUMM = 0                                                                     
c     The following files pertain to ALL models and are open if model.EQ.1                          
      IF (model.EQ.1) THEN                                                                          
c      the header to output file *.OUT is moved to PrOut [MN,Sep'99]                                
                                                                                                    
c      open file with spectral properties RootName.SPP                                              
       IF (iSPP.NE.0) THEN                                                                          
        CALL Attach(RootName,length,'.spp',fname)                                                   
        open(19,file=fname,STATUS='UNKNOWN')                                                        
        IF(SLB) THEN                                                                                
          write(19,'(a49)')                                                                         
     &              '# ==============================================='                             
          write(19,'(a49)')                                                                         
     &              '# Properties of Spectra from the slab right side '                             
          write(19,'(a49)')                                                                         
     &              '# -----------------------------------------------'                             
        ELSE                                                                                        
          call line(1,2,19)                                                                         
          write(19,'(a23)')'#  Spectral Properties '                                                
          call line(1,1,19)                                                                         
        END IF                                                                                      
         s3='###   tau0      Psi      fV       fK       f12    C21  '                               
         s4=' C31   C43  b8-13 b14-22 B9.8 B11.4  R9.8-18  '                                        
         write(19,'(a55,a46)')s3,s4                                                                 
        IF (SLB.AND.iSPP.EQ.3) THEN                                                                 
        CALL Attach(RootName,length,'.zpp',fname)                                                   
          open(24,file=fname,STATUS='UNKNOWN')                                                      
          write(24,'(a49)')                                                                         
     &              '# ==============================================='                             
          write(24,'(a49)')                                                                         
     &              '# Properties of Spectra from the slab left side  '                             
          write(24,'(a49)')                                                                         
     &              '# -----------------------------------------------'                             
         s3='###   tau0      Psi      fV       fK       f12    C21  '                               
         s4=' C31   C43  b8-13 b14-22 B9.8 B11.4  R9.8-18  '                                        
           write(24,'(a55,a46)')s3,s4                                                               
        END IF                                                                                      
       END IF                                                                                       
c       open file for point spread function                                                         
        IF (iPSF.NE.0.AND.psftype.LT.3) THEN                                                        
c         wavelength dependent PSF are also printed out                                             
          CALL Attach(RootName,length,'.psf',fname)                                                 
          open(23,file=fname,STATUS='UNKNOWN')                                                      
          header1 = '    Offset'                                                                    
          write(23,'(a10,20f10.2)')header1,(lambdaOut(i),i=1,NlambdaOut)                            
        END IF                                                                                      
c       Spectra for all models in one file '*.stb' if flag=1                                        
        IF(iA.eq.1) THEN                                                                            
         CALL Attach(RootName,length,'.stb',fname)                                                  
         open(15,file=fname,STATUS='UNKNOWN')                                                       
        END IF                                                                                      
c       All radial profiles in one file '*.rtb' if flag=1                                           
        IF(iB.eq.1) THEN                                                                            
         CALL Attach(RootName,length,'.rtb',fname)                                                  
         open(16,file=fname,STATUS='UNKNOWN')                                                       
        END IF                                                                                      
c       All imaging files in  '*.itb' if flag=1                                                     
        IF (abs(iC).eq.1) THEN                                                                      
         CALL Attach(RootName,length,'.itb',fname)                                                  
         open(17,file=fname,STATUS='UNKNOWN')                                                       
        END IF                                                                                      
c       All message files in  '*.mtb' if flag=1                                                     
        IF(iX.eq.1) THEN                                                                            
         CALL Attach(RootName,length,'.mtb',fname)                                                  
         open(18,file=fname,STATUS='UNKNOWN')                                                       
        END IF                                                                                      
c       Open the file for error vs. iterations in '*.err'                                           
        IF(iInn.eq.1) THEN                                                                          
         CALL Attach(RootName,length,'.err',fname)                                                  
         open(38,file=fname,STATUS='UNKNOWN')                                                       
        END IF                                                                                      
c       for private RDW option                                                                      
        IF(denstyp.eq.6) THEN                                                                       
         CALL Attach(RootName,length,'.rdw',fname)                                                  
         open(66,file=fname,STATUS='UNKNOWN')                                                       
        END IF                                                                                      
c     end if for model=1                                                                            
      END IF                                                                                        
c -------------------------------------------------------------                                     
c     the following files are open for EVERY model                                                  
                                                                                                    
c     (the headers for .s## and .r## files are moved to PrOut, MN)                                  
c     open the spectrum file RootName.s##  (## = model number)                                      
      IF(iA.GT.1) THEN                                                                              
       write(ch5,'(a2,I3.3)') '.s', model                                                           
       CALL Attach(RootName,length,ch5,fname)                                                       
       open(15,file=fname,STATUS='UNKNOWN')                                                         
       IF(SLB) THEN                                                                                 
         IF(iA.eq.3) THEN                                                                           
           write(ch5,'(a2,I3.3)') '.z', model                                                       
           CALL Attach(RootName,length,ch5,fname)                                                   
           open(25,file=fname,STATUS='UNKNOWN')                                                     
         END IF                                                                                     
       END IF                                                                                       
      END IF                                                                                        
c     open the file RootName.r## (y-dependent quantities)                                           
      IF(iB.GT.1) THEN                                                                              
        write(ch5,'(a2,I3.3)') '.r', model                                                          
        CALL Attach(RootName,length,ch5,fname)                                                      
        open(16,file=fname,STATUS='UNKNOWN')                                                        
      END IF                                                                                        
c     open the file RootName.i## (surface brightness)                                               
      IF(abs(iC).GT.1) THEN                                                                         
        write(ch5,'(a2,I3.3)') '.i', model                                                          
        CALL Attach(RootName,length,ch5,fname)                                                      
        open(17,file=fname,STATUS='UNKNOWN')                                                        
      END IF                                                                                        
c     open the file RootName.c## (convolved images) for flag iC<0                                   
c      if iC=-3 - in a separate file fname.c##                                                      
      IF(iC.EQ.-3.AND.iPSF.GT.0) THEN                                                               
        write(ch5,'(a2,I3.3)') '.c', model                                                          
        CALL Attach(RootName,length,ch5,fname)                                                      
        open(21,file=fname,STATUS='UNKNOWN')                                                        
      END IF                                                                                        
c     open the file RootName.v## (visibility curves)                                                
      IF((abs(iC).EQ.3).AND.(iV.GT.0)) THEN                                                         
        write(ch5,'(a2,I3.3)') '.v', model                                                          
        CALL Attach(RootName,length,ch5,fname)                                                      
        open(22,file=fname,STATUS='UNKNOWN')                                                        
      END IF                                                                                        
c     open the output file RootName.m##                                                             
      IF (iX.GT.1) THEN                                                                             
        write(ch5,'(a2,I3.3)') '.m', model                                                          
        CALL Attach(RootName,length,ch5,fname)                                                      
        open(18,file=fname,STATUS='UNKNOWN')                                                        
      END IF                                                                                        
c     open the disk files RootName.d##, RootName.e## and RootName.w##                               
c      IF (iD.GE.1) THEN                                                                            
c        write(ch5,'(a2,I3.3)') '.d', model                                                         
c        CALL Attach(RootName,length,ch5,fname)                                                     
c        open(30,file=fname,status='unknown')                                                       
c        IF (iD.GT.1) THEN                                                                          
c          write(ch5,'(a2,I3.3)') '.e', model                                                       
c          CALL Attach(RootName,length,ch5,fname)                                                   
c           open(31,file=fname,status='unknown')                                                    
c          write(ch5,'(a2,I3.3)') '.w', model                                                       
c          CALL Attach(RootName,length,ch5,fname)                                                   
c           open(32,file=fname,status='unknown')                                                    
c        END IF                                                                                     
c      END IF                                                                                       
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE PrHeader(nlines,filenm)                                                            
c =======================================================================                           
c This subroutine prints headers of input data files in fname.out                                   
c =======================================================================                           
      IMPLICIT none                                                                                 
      CHARACTER filenm*(*), line*80                                                                 
      INTEGER nlines, i                                                                             
c ----------------------------------------------------------------------                            
      open(28, file=filenm, status = 'OLD')                                                         
      DO i = 1, nlines-1                                                                            
       read(28,'(a)') line                                                                          
       write(12,'(a2,a80)') '  ', line                                                              
      END DO                                                                                        
      REWIND(28)                                                                                    
      close(28)                                                                                     
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE PROUT(model)                                                                       
c =======================================================================                           
c This subroutine prints the results out.        [ZI,Feb'96; MN,Mar'99]                             
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER Nmu, transmit                                                     
      DOUBLE PRECISION theta(npR),  muobs, tauT, Sfn                             
      COMMON/slbint/ theta,  muobs, tauT, Sfn, Nmu, transmit                    
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER ver                                                               
      DOUBLE PRECISION ugas(npY), qF(npY), vrat(npG,npY), Gamma(npY),           
     &       I1, I2, I3, CMdot, Cve, CM, Cr1, G1, Ginf, Prdw, delta,            
     &       winf, Phi, PIrdw, QV, q_star, zeta1, tauFdyn(npY)                  
      COMMON /dyn/ ugas, qF, vrat, Gamma, I1, I2, I3, CMdot, Cve, CM,           
     &       Cr1, G1, Ginf, Prdw, delta, winf, Phi, PIrdw, QV, q_star,          
     &       zeta1, tauFdyn, ver                                                
                                                                                
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
c      INCLUDE 'disk.inc'                                                                           
c      CHARACTER*49 h1, h2                                                                          
      CHARACTER*72 SC21,SC31,SC43,SB98,SB11,Sbet1,Sbet2,STemp,Serr,                                 
     &             hdint, hdcon, hdvis, s1, su1, s2, su2, Tstr*10                                   
      CHARACTER*132 hdsp1,hdsp2,hdrslb1,hdrslb2,hdrsph1,hdrsph2,hdrdyn                              
      INTEGER iY, iL, i, model, j, unt, imu, Nrows, Ncols                                           
      PARAMETER (Nrows=200, Ncols=25)                                                               
      DOUBLE PRECISION PSFN, PSFfunc(20,1000), Elems(Nrows,Ncols), ETA,                             
     &    faux(npL), tht1, xs, xds, xde, res, fnorm, var1, var2,  dmax,                             
     &    limval, GinfG1, Jo, Fscale                                          
c      for the added disk                                                                           
c      DOUBLE PRECISION Tenv                                                                        
c ----------------------------------------------------------------------                            
c     this is the cut-off for printout of small values (in spectra)                                 
      limval = 1.0D-20                                                                               
c     SmC(1..5, model) are found in ANALYSIS                                                        
      SmC(6,model) = Td(1,nY)                                                                       
c     SmC(7,model) and SmC(8,model) are Teff(L) and Teff(R), respectively,                          
c     the Teff of the slab illumination sources, found from Fi in Analysis                          
      tht1 = 412.6D+00/(dsqrt(Fi))                                                                      
c     colors                                                                                        
      CALL getFS(SpecChar(9,model),2,0,SC21)                                                        
      CALL getFS(SpecChar(10,model),2,0,SC31)                                                       
      CALL getFS(SpecChar(11,model),2,0,SC43)                                                       
c     error in %                                                                                    
      IF (SmC(5,model).LT.0.1D+00) THEN                                                                 
        CALL getFS(SmC(5,model)*100.0D+00,0,0,Serr)                                                       
      ELSE IF (SmC(5,model).LT.1.0) THEN                                                            
        CALL getFS(SmC(5,model)*100.0D+00,0,1,Serr)                                                       
      ELSE                                                                                          
        CALL getFS(SmC(5,model)*100.0D+00,0,2,Serr)                                                       
      END IF                                                                                        
c     dust temperature at y=Y                                                                       
      IF (SmC(6,model).LT.99.5D+00) THEN                                                                
        CALL getFS(SmC(6,model),0,0,STemp)                                                          
      ELSE                                                                                          
        CALL getFS(SmC(6,model),0,1,STemp)                                                          
      END IF                                                                                        

cc! vvvvvv added optional output in physical units [MN,'07]                                        
      IF(SLB) THEN 
        IF(mu1.eq.-1.0D+00) THEN 
           Fscale = Fdiff
        ELSE
           Fscale = Fi/dabs(mu1)
        END IF 
      ELSE
c     for sphere: 
        IF (Left.eq.0) THEN                                                                      
c         no central source. Fdiff is the bolometric emission of the shell                     
          Fscale = Fdiff                                                                         
        ELSE                                                                                     
c         if there is a central source the bolometric emission of the shell                      
c         includes fluxes due to both central and external source                                
          Fscale = Fout                                                                          
c         if only central, no external                                                   
          IF(Right.eq.0) Fscale = Fi/Y(nY)/Y(nY)                                                 
        END IF                                                                                   
      END IF
c ^^^^^^^^^^^	                                              
                                                                                                    
c --------------  overall parameters to *.OUT file -----------------------                          
c     write header to output file *.OUT                                                             
      IF (model.EQ.1) THEN                                                                          
       write(12,*)'         '                                                                       
       write(12,*)' RESULTS:'                                                                       
       write(12,*)' --------'                                                                       
       IF (SLB) THEN                                                                                
c     ---------- slab output ----------------                                                       
       IF(typEntry(1).EQ.1) THEN                                                                    
        s1=' ###   tau0   F_L(W/m2)   f1      r1(cm)    Td(K)    Te_L'                              
       ELSE IF (typEntry(1).EQ.3) THEN                                                              
        s1=' ###   tau0     T1(K)     f1     F_L(W/m2)  Td(K)    Te_L'                              
       ELSE                                                                                         
        s1=' ###   tau0     T1(K)     f1      r1(cm)    Td(K)    Te_L'                              
       END IF                                                                                       
       su1=' ###     1        2        3        4         5        6 '                              
        IF(ksi.GT.0) THEN                                                                           
          s2='    Te_R    err'                                                                      
         su2='      7      8 '                                                                      
         write(12,'(a57,a16)')s1,s2                                                                 
         write(12,'(a57,a16)')su1,su2                                                               
         su1=' ========================================================'                            
         su2='================'                                                                     
         write(12,'(a57,a16)')su1,su2                                                               
        ELSE                                                                                        
          s2='   err'                                                                               
         su2='    7 '                                                                               
         write(12,'(a57,a6)')s1,s2                                                                  
         write(12,'(a57,a6)')su1,su2                                                                
         su1=' ========================================================'                            
         su2='======'                                                                               
         write(12,'(a57,a6)')su1,su2                                                                
        END IF                                                                                      
       ELSE                                                                                         
c     ------------- output for sphere -----------------------------                                 
       IF(typEntry(1).EQ.1) THEN                                                                    
         s1=                                                                                        
     & ' ###   tau0   Fi(W/m2)  r1(cm)    r1/rc   theta1   Td(Y)   err'                             
       ELSE IF (typEntry(1).EQ.3) THEN                                                              
         s1=                                                                                        
     & ' ###   tau0     T1(K)   Fi(W/m2)  r1/rc   theta1   Td(Y)   err'                             
       ELSE                                                                                         
         s1=                                                                                        
     & ' ###   tau0     T1(K)    r1(cm)   r1/rc   theta1   Td(Y)   err'                             
       END IF                                                                                       
         su1=                                                                                       
     & ' ###     1        2        3        4        5       6      7 '                             
        IF(RDWA.OR.RDW) THEN                                                                        
        s2='   Mdot      Ve       M> '                                                              
       su2='     8        9       10 '                                                              
         write(12,'(a62,a25)')s1,s2                                                                 
         write(12,'(a62,a25)')su1,su2                                                               
       su1=                                                                                         
     &' =============================================================='                             
       su2='============================'                                                           
         write(12,'(a63,a28)')su1,su2                                                               
c        ** private RDW file **                                                                     
         IF (denstyp.EQ.6) THEN                                                                     
           s1= '###   tau0      tauF     Mdot      Ve       M>       '                              
           su1='###    1          2        3        4       5       6'                              
           s2=                                                                                      
     &       'Ginf/G1   P    delta  d/sqrt(w1)  winf     Phi    zeta(1)'                            
           su2='        7        8        9        10       11       12'                            
           write(66,'(a53,a57)')s1,s2                                                               
           write(66,'(a53,a55)')su1,su2                                                             
         END IF                                                                                     
        ELSE                                                                                        
         write(12,'(a63)')s1                                                                        
         write(12,'(a63)')su1                                                                       
       su1=                                                                                         
     & ' ============================================================='                             
         write(12,'(a63)')su1                                                                       
        END IF                                                                                      
       END IF                                                                                       
      END IF                                                                                        
c     print output tables for ea.model                                                              
       IF(typEntry(1).EQ.1) THEN                                                                    
c       if T1 in input                                                                              
        var1 = Fi                                                                                   
        var2 = Cr1                                                                                  
       ELSE IF (typEntry(1).EQ.3) THEN                                                              
c       if L,r1 in input                                                                            
        var1 = Td(1,1)                                                                              
        var2 = Fi                                                                                   
       ELSE                                                                                         
c       if Fi or Tei in input                                                                       
        var1 = Td(1,1)                                                                              
        var2 = Cr1                                                                                  
       END IF                                                                                       
c     ---------------- for slab: ---------------------------                                        
      IF(SLB) THEN                                                                                  
      IF (fmed.LE.accFbol) fmed = 0.0D+00                                                                
       IF (ksi.GT.0) THEN                                                                           
c      if second source on the right                                                                
          write(12,'(i4,1p,2E9.2,E10.2,1p,4E9.2,a4)')                                               
     &    model, TAUfid, var1, fmed, var2, Td(1,nY), SmC(7,model),                                  
     &                                         SmC(8,model), Serr                                   
       ELSE                                                                                         
          write(12,'(i4,1p,2E9.2,E10.2,1p,3E9.2,a4)')                                               
     &    model, TAUfid, var1, fmed, var2, Td(1,nY), SmC(7,model), Serr                             
       END IF                                                                                       
                                                                                                    
      ELSE                                                                                          
c     ---------- for spherical shell ------------------------                                       
       IF (RDWA.OR.RDW) THEN                                                                        
          write(12,'(i4,1p,6E9.2,a1,a3,1p,3E9.2)')                                                  
     &    model, TAUfid, var1, var2, r1rs, tht1,Td(1,nY),' ',Serr,                                  
     &                                    CMdot, CVe, CM                                            
       ELSE                                                                                         
           write(12,'(i4,1p,6E9.2,a1,a3)')                                                          
     &     model, TAUfid, var1, var2, r1rs, tht1,Td(1,nY),' ',Serr                                  
       END IF                                                                                       
        IF (denstyp.EQ.6) THEN                                                                      
c       ** private RDW file **                                                                      
           IF (model.EQ.1) THEN                                                                     
             write(66,'(a11,1p,E9.3,a10,1p,E9.3,a12,1p,E9.3,a13,E9.3)')                             
     &          '###   QV = ',QV,', qstar = ',q_star,', v1/vinf = ',pow,                            
     &          ', (g/r)max = ',ptr(1)                                                              
           END IF                                                                                   
           dmax = dsqrt(pow*winf)                                                                   
           IF (G1.GT.0) THEN                                                                        
              GinfG1 =  Ginf / G1                                                                   
           ELSE                                                                                     
              GinfG1 = 0                                                                            
           END IF                                                                                   
           write(66,'(i4,1p,5E9.2,7E9.2)')                                                          
     &           model, TAUfid, tauF(nY), CMdot, CVe, CM,                                           
     &           GinfG1, Prdw, delta, delta/dmax, winf, Phi, zeta1                                  
        END IF                                                                                      
                                                                                                    
       IF(Right.eq.0) THEN                                                                          
        IF (startyp(1).EQ.1.OR.startyp(1).EQ.2) THEN                                                
         IF(Tstar(1).LT.Te_min) THEN                                                                
           CALL GetFS(Tstar(1),0,1,Tstr)                                                            
           write(12,'(a50,a5,a5)')                                                                  
     &' ** WARNING: the input spectrum is a black-body at ',Tstr,' K **'                            
           CALL GetFS(Te_min,0,1,Tstr)                                                              
           write(12,'(a50,a5,a5)')                                                                  
     &' *The point-source assumption requires min Teff of ',Tstr,' K **'                            
          END IF                                                                                    
        END IF                                                                                      
       END IF                                                                                       
c     end if for geometry                                                                           
      END IF                                                                                        
                                                                                                    
      CALL getFS(SpecChar(1,model),2,0,SB98)                                                        
      CALL getFS(SpecChar(2,model),2,0,SB11)                                                        
      CALL getFS(SpecChar(4,model),2,0,Sbet1)                                                       
      CALL getFS(SpecChar(5,model),2,0,Sbet2)                                                       
c --------------     spectral properties to *.SPP file   -----------------------                    
      IF (iSPP.NE.0) THEN                                                                           
       write(19,'(i3,1p,5E9.2,7a6,E9.2)') model, TAUfid, SmC(1,model),                              
     &      (SpecChar(i,model),i=6,8), SC21, SC31, SC43, Sbet1, Sbet2,                              
     &       SB98, SB11, SpecChar(3,model)                                                          
      END IF                                                                                        
                                                                                                    
c --------------   spectrum to *.s## (old *.Axx) file   ------------------------                    
      IF (iA.NE.0) THEN                                                                             
       IF(SLB) THEN                                                                                 
        hdsp1 = '#  lambda     fRight       xAtt       xDs   '                                      
       ELSE                                                                                         
        hdsp1 = '#  lambda      fTot        xAtt       xDs   '                                      
       END IF                                                                                       
        hdsp2 = '     xDe       fInp       tauT      albedo  '                                      
c        hdsp2 = '     xDe       fInp        fsRp       fsRm   '                                    
        unt = 15                                                                                    
        call line(1,2,unt)                                                                          
        IF(SLB) THEN                                                                                
          write(unt,'(a7,i3,a8,F8.3,a36)')                                                          
     &         '# model',model,' TAUfid=',TAUfid,                                                   
     &           '   SPECTRUM from the right slab side '                                            
        ELSE                                                                                        
          write(unt,'(a7,i3,a8,F8.3,a12)') '# model',model,                                         
     &                          ' TAUfid=',TAUfid,'   SPECTRUM '                                    
        END IF                                                                                      
        call line(1,1,unt)                                                                          
        DO iL = 1, nL                                                                               
          IF(SLB) THEN                                                                              
c         The right-side spectra for slab: ftot + ksi*fsR = fsL + fds + fde                         
            ftot(iL,nYok) = ftot(iL,nYok) + ksi*fsR(iL,nYok)                                        
          ELSE                                                                                      
c           only the outward propagating fluxes                                                     
c           fsL - for the central source; fsRp - for the external rad.                              
c            ftot(iL,nYok) = fsL(iL,nYok) + fsRp(iL,nYok)                                           
c     &                    + fde(iL,nYok) + fds(iL,nYok)                                            
c           only the shell sp.shape, external source not added                                      
            ftot(iL,nYok) = fsL(iL,nYok)                                                            
     &                    + fde(iL,nYok) + fds(iL,nYok)                                             
          END IF                                                                                    
          faux(iL) = ftot(iL,nYok)/lambda(iL)                                                       
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,faux,res)                                                      
c       Normalization factor for output spectra                                                     
        fnorm = res                                                                                 
        DO iL = 1, nL                                                                               
           IF (ftot(iL,nYok).NE.0.0D+00) THEN                                                           
c             xs = dabs(fs(iL,nYok)/ftot(iL,nYok))                                                  
c             to include additional external illumination                                           
c             xs = (fsL(iL,nYok) + fsRp(iL,nYok))/ftot(iL,nYok)                                     
c            Only shell's spectral shape, external not included                                     
             xs = fsL(iL,nYok)/ftot(iL,nYok)                                                        
             xds = fds(iL,nYok)/ftot(iL,nYok)                                                       
             xde = fde(iL,nYok)/ftot(iL,nYok)                                                       
           ELSE                                                                                     
             xs = 0.0D+00                                                                               
             xds = 0.0D+00                                                                              
             xde = 0.0D+00                                                                              
           END IF                                                                                   
c          change introduced for ver.11a - no need to print negligible values                       
           IF (ftot(iL,nYok).LT.limval) ftot(iL,nYok) = 0.0D+00                                         
           IF (xs.LT.limval) xs = 0.0D+00                                                               
           IF (xds.LT.limval) xds = 0.0D+00                                                             
           IF (xde.LT.limval) xde = 0.0D+00                                                             
           IF (fs(iL,1).LT.limval) fs(iL,1) = 0.0D+00                                                   
           IF (fsL(iL,1).LT.limval) fsL(iL,1) = 0.0D+00                                                 
c          rescale fTot with the bolom flux                                                         
           ftot(iL,nYok) = ftot(iL,nYok)/fnorm                                                      
c          If flag-selected, print fTot in [W/m2]                                                   
           IF(iPhys.eq.1) ftot(iL,nYok) = ftot(iL,nYok)*Fscale                                      
cc! ^^^^^^^                                                                                           
           Elems(iL,1) = lambda(iL)                                                                 
           Elems(iL,2) = fTot(iL,nYok)                                                              
           Elems(iL,3) = xs                                                                         
           Elems(iL,4) = xds                                                                        
           Elems(iL,5) = xde                                                                        
           IF (SLB) THEN                                                                            
             Elems(iL,6) = fsL(iL,1)                                                                
           ELSE                                                                                     
c          the input radiation is from central source, at y=1                                       
c          and/or from external, at y=Yout                                                          
c             Elems(iL,6) = (fsL(iL,1) + fsRm(iL,nYok))/fnorm                                       
             Elems(iL,6) = fsL(iL,1) / fnorm                                                        
           END IF                                                                                   
           Elems(iL,7) = TAUtot(iL)                                                                 
           Elems(iL,8) = omega(iL,1)                                                                
        END DO                                                                                      
c     ------ Tabulate the spectra in the desired form ----------                                    
        write(unt,'(2(a45))') hdsp1,hdsp2                                                           
        CALL MakeTable(Elems,Nrows,Ncols,nL,8,unt)                                                  
c       spectra from the illuminated slab side (file *.z##)                                         
        IF (SLB) THEN                                                                               
           DO iL = 1, nL                                                                            
c           The left-side spectra are: |R*fsR + fm|=|fsL-ftot|                                      
            ftot(iL,1) = dabs(fsL(iL,1) - ftot(iL,1))                                               
c           normalization of z-spectra for slab                                                     
            faux(iL) = ftot(iL,1)/lambda(iL)                                                        
           END DO                                                                                   
           CALL Simpson(npL,1,nL,lambda,faux,res)                                                   
           fnorm = res                                                                              
           DO iL = 1, nL                                                                            
             IF (ftot(iL,1).NE.0.0D+00) THEN                                                            
                xs =  ksi*fsR(iL,1)/ftot(iL,1)                                                      
                xds = dabs(fds(iL,1)/ftot(iL,1))                                                    
                xde = dabs(fde(iL,1)/ftot(iL,1))                                                    
             ELSE                                                                                   
                xs = 0.0D+00                                                                            
                xds = 0.0D+00                                                                           
                xde = 0.0D+00                                                                           
             END IF                                                                                 
             IF (xs.LT.limval) xs =0.0D+00                                                              
             IF (xds.LT.limval) xds =0.0D+00                                                            
             IF (xde.LT.limval) xde =0.0D+00                                                            
             IF(fsR(iL,nYok).LT.limval) fsR(iL,nYok) = 0.0D+00                                          
             IF(ftot(iL,1).LT.limval) ftot(iL,1) = 0.0D+00                                              
c            rescale fTot with the bolom flux for z-spectra                                         
             ftot(iL,1) = ftot(iL,1)/fnorm                                                          
             IF(iPhys.eq.1) ftot(iL,1) = ftot(iL,1)*Fscale
             Elems(iL,1) = lambda(iL)                                                               
             Elems(iL,2) = fTot(iL,1)                                                               
             Elems(iL,3) = xs                                                                       
             Elems(iL,4) = xds                                                                      
             Elems(iL,5) = xde                                                                      
             Elems(iL,6) = ksi*fsR(iL,nYok)                                                         
             Elems(iL,7) = TAUtot(iL)                                                               
             Elems(iL,8) = omega(iL,1)                                                              
           END DO                                                                                   
           IF (iA.EQ.3) unt=25                                                                      
c          append to the .s## file or write in a separate .z## file (if iA=3)                       
           call line(1,1,unt)                                                                       
           write(unt,'(a7,i3,a8,F8.3,a36)') '# model',model,                                        
     &         ' TAUfid=',TAUfid,'   SPECTRUM from the left slab side'                              
           call line(1,1,unt)                                                                       
           hdsp1 = '#  lambda      fLeft       xAtt       xDs   '                                   
           write(unt,'(2(a45))') hdsp1,hdsp2                                                        
           CALL MakeTable(Elems,Nrows,Ncols,nL,8,unt)                                               
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
c     spectral properties for *.ZPP file in slab case                                               
      IF (SLB.AND.iSPP.NE.0) THEN                                                                   
        CALL getFS(SpecChar(12,model),2,0,SB98)                                                     
        CALL getFS(SpecChar(13,model),2,0,SB11)                                                     
        CALL getFS(SpecChar(15,model),2,0,Sbet1)                                                    
        CALL getFS(SpecChar(16,model),2,0,Sbet2)                                                    
        CALL getFS(SpecChar(20,model),2,0,SC21)                                                     
        CALL getFS(SpecChar(21,model),2,0,SC31)                                                     
        CALL getFS(SpecChar(22,model),2,0,SC43)                                                     
c       write spectral properties to *.ZPP file                                                     
         IF (iSPP.EQ.3) THEN                                                                        
            write(24,'(i3,1p,5E9.2,7a6,E9.2)')                                                      
     &      model, TAUfid, SmC(1,model), (SpecChar(i,model),i=17,19),                               
     &      SC21,SC31,SC43, Sbet1,Sbet2, SB98,SB11,SpecChar(14,model)                               
         ELSE                                                                                       
            write(zline(model),'(i3,1p,5E9.2,7a6,E9.2)')                                            
     &      model, TAUfid, SmC(1,model), (SpecChar(i,model),i=17,19),                               
     &      SC21,SC31,SC43, Sbet1,Sbet2,SB98,SB11,SpecChar(14,model)                                
         END IF                                                                                     
      END IF                                                                                        
                                                                                                    
c -----------  y-dependent quantities to *.r## (old *.Bxx) file -------------                       
      IF (iB.NE.0) THEN                                                                             
       hdrslb1= '#     t        tauF      epsilon       Td '                                        
       hdrslb2= '      febol      fRbol      fLbol '                                                
       hdrsph1= '#     y         eta         t         tauF '                                       
       hdrsph2= '     epsilon      Td         rg '                                                  
        hdrdyn= '         u        drift'                                                           
       unt = 16                                                                                     
       call line(1,2,unt)                                                                           
       IF(SLB) THEN                                                                                 
          write(unt,'(a7,i3,a8,F8.3,a18)') '# model',model,                                         
     &                           ' TAUfid=',TAUfid,'  SPATIAL PROFILES'                             
       ELSE                                                                                         
          write(unt,'(a7,i3,a8,F8.3,a18)') '# model',model,                                         
     &                           ' TAUfid=',TAUfid,'  RADIAL PROFILES '                             
       END IF                                                                                       
       call line(1,1,unt)                                                                           
c    --------- for slab ---------                                                                   
       IF (SLB) THEN                                                                                
         DO iY = 1, nYok                                                                            
           Elems(iY,1) = tr(iY)                                                                     
           Elems(iY,2) = tauF(iY)                                                                   
           Elems(iY,3) = Eps(iY)                                                                    
           Elems(iY,4) = Td(1,iY)                                                                   
           Elems(iY,5) = fsbol(iY)                                                                  
           Elems(iY,6) = fpbol(iY)                                                                  
           Elems(iY,7) = fmbol(iY)                                                                  
         END DO                                                                                     
         write(unt,'(a42,a34)') hdrslb1,hdrslb2                                                     
         CALL MakeTable(Elems,Nrows,Ncols,nYok,7,unt)                                               
       ELSE                                                                                         
c     ------  for spherical shell --------                                                          
        DO iY = 1, nYok                                                                             
          Elems(iY,1) = Yok(iY)                                                                     
          Elems(iY,2) = ETA(Y(iY))                                                                  
          Elems(iY,3) = tr(iY)                                                                      
          Elems(iY,4) = tauF(iY)                                                                    
          Elems(iY,5) = Eps(iY)                                                                     
          Elems(iY,6) = Td(1,iY)                                                                    
          Elems(iY,7) = rg(1,iY)                                                                    
          IF (denstyp.EQ.6) THEN                                                                    
c            redefine for private rdw (denstyp.eq.6) option                                         
             Elems(iY,5) = Gamma(iY)                                                                
             Elems(iY,7) = qF(iY)                                                                   
          END IF                                                                                    
        END DO                                                                                      
c       check values:                                                                               
        DO i = 1, 7                                                                                 
          DO iY = 1, nYok                                                                           
            IF(Elems(iY,i).LT.limval) Elems(iY,i) = 0.0D+00                                             
          END DO                                                                                    
        END DO                                                                                      
c       with dynamics                                                                               
        IF (RDW) THEN                                                                               
         DO iY = 1, nYok                                                                            
           Elems(iY,8) = ugas(iY)/ugas(nYok)                                                        
           Elems(iY,9) = vrat(1,iY)                                                                 
         END DO                                                                                     
c        check values:                                                                              
         DO i = 8, 9                                                                                
           DO iY = 1, nYok                                                                          
             IF(Elems(iY,i).LT.limval) Elems(iY,i) = 0.0D+00                                            
           END DO                                                                                   
         END DO                                                                                     
         write(unt,'(a42,a32,a23)') hdrsph1,hdrsph2,hdrdyn                                          
         CALL MakeTable(Elems,Nrows,Ncols,nYok,9,unt)                                               
        ELSE                                                                                        
         write(unt,'(a42,a32)') hdrsph1,hdrsph2                                                     
         CALL MakeTable(Elems,Nrows,Ncols,nYok,7,unt)                                               
        END IF                                                                                      
c      end if for geometry                                                                          
       END IF                                                                                       
c     end if for the iB (radial) flag                                                               
      END IF                                                                                        
                                                                                                    
c --------------   intensities to *.inn (old *.Cxx) file  --------------                            
      IF (abs(iC).NE.0) THEN                                                                        
c      slab intensity (found at the end of subroutine SLBRadT)                                      
c      theta(Nmu) are the angles of output intensities                                              
       IF (SLB) THEN                                                                                
        hdint = '   lambda'                                                                         
        unt = 17                                                                                    
        CALL LINE(1,2,unt)                                                                          
        write(unt,'(a7,i3,a8,F8.3,a32)')'# model',model,                                            
     &          ' TAUfid=',TAUfid,' Transmitted I(theta)*cos(theta)'                                
        CALL LINE(1,1,unt)                                                                          
        DO iL = 1, nL                                                                               
          Elems(iL,1) = lambda(iL)                                                                  
          DO imu = 1, Nmu                                                                           
            IF(iPhys.eq.1) SLBIntR(imu,iL) = SLBIntR(imu,iL)*Fscale
            Elems(iL,imu+1) = SLBIntR(imu,iL)                                                       
          END DO                                                                                    
          Elems(iL,Nmu+2) = IstR(iL)                                                                
        END DO                                                                                      
c        write(unt,'(a9,21f11.3)')hdint,(theta(imu),imu=1,Nmu)                                      
c       printout angles in degrees                                                                  
c        write(unt,'(a9,37f11.1,a9)') hdint,                                                        
c     &                    (theta(imu)*180.0D+00/Pi,imu=1,Nmu),'     IstR'                               
        write(unt,'(a9,100f11.1)') hdint,                                                            
     &                    (theta(imu)*180.0D+00/Pi,imu=1,Nmu)                                            
        CALL MakeTable(Elems,Nrows,Ncols,nL,Nmu+1,unt)                                             
c       adding the column with stellar Ints at the end of the table                                 
c        CALL MakeTable(Elems,Nrows,Ncols,nL,Nmu+2,unt)                                              
                                                                                                    
        hdint = '   lambda'                                                                         
        unt = 17                                                                                    
        CALL LINE(1,2,unt)                                                                          
         write(unt,'(a7,i3,a8,F8.3,a32)')'# model',model,                                           
     &            ' TAUfid=',TAUfid,' Reflected cos(theta)*I(theta)'                                
        CALL LINE(1,1,unt)                                                                          
        DO iL = 1, nL                                                                               
          Elems(iL,1) = lambda(iL)                                                                  
          DO imu = 1, Nmu                                                                           
            IF(iPhys.eq.1) SLBIntL(imu,iL) = SLBIntL(imu,iL)*Fscale
            Elems(iL,imu+1) = SLBIntL(imu,iL)                                                       
          END DO                                                                                    
        END DO                                                                                      
c        write(unt,'(a9,21f11.3)')hdint,(theta(imu),imu=1,Nmu)                                      
c       printout angles in degrees                                                                  
      write(unt,'(a9,99f11.1)')hdint,(theta(imu)*180.0D+00/Pi,imu=1,Nmu)                               
        CALL MakeTable(Elems,Nrows,Ncols,nL,Nmu+1,unt)                                              
                                                                                                    
       ELSE                                                                                         
c      for spherical:                                                                               
        hdint = '#     b          t(b)'                                                             
        hdcon = '#   Offset '                                                                       
        hdvis = '#     q    '                                                                       
        unt = 17                                                                                    
        CALL LINE(1,2,unt)                                                                          
        write(unt,'(a7,i3,a8,F8.3,a14)') '# model',model,                                           
     &                             ' TAUfid=',TAUfid,'   RAW IMAGE  '                               
        CALL LINE(1,1,unt)                                                                          
        DO i = 1, nPok+2                                                                            
          Elems(i,1) = bOut(i)                                                                      
          Elems(i,2) = tauZout(i)                                                                   
          DO j = 1, NLambdaOut                                                                      
c           check values:                                                                           
            IF(IntOut(j,i).NE.IntOut(j,i).OR.IntOut(j,i).LT.limval) THEN                            
               IntOut(j,i) = 0.0D+00                                                                    
            END IF                                                                                  
            Elems(i,j+2) = IntOut(j,i)                                                              
c           we want intensity in Jy/arcsec2                                                         
c            This was the bug in intensity output for sphere,  
c            the missing 4piY^2 factor for intensity output [June 2006]
c            Elems(i,j+2) = 7.83 * lambdaOut(j) * Fi * Elems(i,j+2)                                  
            IF(Right.eq.1 .AND. Left.eq.0) THEN 
               Jo = sigma/pi*(Teo**4.0D+00)
               Elems(i,j+2) = 7.834D+00*lambdaOut(j)*
     *                 (Jo*4.0D+00*Pi*Yout**2.0D+00)*Elems(i,j+2) 
            ELSE  
               Elems(i,j+2) = 7.834D+00*lambdaOut(j)*
     *                 (Fi*4.0D+00*Pi*Yout**2.0D+00)*Elems(i,j+2)                                  
            END IF
          END DO                                                                                    
        END DO                                                                                      
        write(unt,'(a21,20f11.2)')hdint,(lambdaOut(j),j=1,NlambdaOut)                               
        CALL MakeTable(Elems,Nrows,Ncols,nPok+2,NlambdaOut+2,unt)                                   
       END IF                                                                                       
      END IF                                                                                        
      IF (iC.LT.0) THEN                                                                             
c ---------  convolved images either add to .i## file or write in *.c## file --                     
        IF(iC.EQ.-3) unt = 21                                                                       
        call line(1,2,unt)                                                                          
        write(unt,'(a7,i3,a8,F8.3,a20)') '# model',model,                                           
     &                          ' TAUfid=',TAUfid,'   CONVOLVED IMAGE  '                            
        call line(1,1,unt)                                                                          
        DO i = 1, Nconv                                                                             
         Elems(i,1) = Offset(i)                                                                     
         DO j = 1, NLambdaOut                                                                       
           IF(ConvInt(j,i).LT.limval) ConvInt(j,i) = 0.0D+00                                            
           Elems(i,j+1) = ConvInt(j,i)                                                              
         END DO                                                                                     
        END DO                                                                                      
        write(unt,'(a11,20f11.2)')hdcon,(lambdaOut(i),i=1,NlambdaOut)                               
        CALL MakeTable(Elems,Nrows,Ncols,Nconv,NLambdaOut+1,unt)                                    
        IF (psftype.LT.3.AND.model.EQ.1) THEN                                                       
c         Wavelength dependent PSFs, print them separately in *.psf                                 
c         first generate wavelength dependent PSFs                                                  
          DO j = 1, NlambdaOut                                                                      
            iLambda = j                                                                             
c           added Dec.04 [MN]                                                                       
            DO i = 1, Nconv                    		                                                   
              PSFfunc(j,i) = PSFN(Offset(i))                                                        
c             norm.needs to be done here again (after call to PSFN)                                 
      	    PSFfunc(j,i) = PSFfunc(j,i)/psfArea(j)                                                   
c             check dynamic range                                                                   
              CALL CHKRANGE(dynrange,PSFfunc(j,i))                                                  
            END DO                                                                                  
          END DO                                                                                    
c         print them out                                                                            
          DO i = 1, Nconv                                                                           
           write(23,'(1p,e12.5,20e10.3)')Offset(i),                                                 
     &                                 (PSFfunc(j,i),j=1,NlambdaOut)                                
         END DO                                                                                    
        END IF                                                                                      
      END IF                                                                                        
c --------------     visibility curves to *.vnn file    ------------------------                    
      IF (iV.NE.0.AND.denstyp.NE.0) THEN                                                            
        IF(abs(iC).EQ.3) unt = 22                                                                   
        call line(1,2,unt)                                                                          
        write(unt,'(a7,i3,a8,F8.3,a14)') '# model',model,                                           
     &                                ' TAUfid=',TAUfid,'  VISIBILITY  '                            
        call line(1,1,unt)                                                                          
        DO i = 1, Nvisi                                                                             
          Elems(i,1) = qtheta1(i)                                                                   
          DO j = 1, NLambdaOut                                                                      
            IF(Visib(j,i).LT.limval) Visib(j,i) = 0.0D+00                                               
            Elems(i,j+1) = Visib(j,i)                                                               
          END DO                                                                                    
        END DO                                                                                      
        write(unt,'(a11,20f11.2)')hdvis,(lambdaOut(i),i=1,NlambdaOut)                               
        CALL MakeTable(Elems,Nrows,Ncols,Nvisi,NLambdaOut+1,unt)                                    
      END IF                                                                                        
                                                                                                    
c --------------  DISK  OUTPUT:     -------------------------                                       
c      IF (iD.GE.1) THEN                                                                            
cc       first fractional luminosities and spectrum                                                 
c        write(30,'(a)')                                                                            
c     &    '# Frac. contr. to disk heating for *, acc, Em, Sc (2 sides)'                            
c        write(30,'(1p,4e11.3)')zs,zv,zemis,zscat                                                   
c        write(30,'(a)')'# Total Disk heating / Ltot:'                                              
c        write(30,'(1p,e11.3)')LhLtot                                                               
c        write(30,'(a)')'# Overall Observed Disk L / Ltot:'                                         
c        write(30,'(1p,e11.3)')LdLtot                                                               
c        write(30,'(a)')'# Rdust(1)/Rstar:'                                                         
c        write(30,'(1p,e11.3)')r1rstar                                                              
c        h1 = '  lambda     fdisk          y        x      Tenv'                                    
c        h2 = '  Tdisk     hstar     hvisc    hemis    hscat   '                                    
c        write(30,'(2(a49))')h1,h2                                                                  
c        DO i = 1, nL                                                                               
c          IF (i.LE.nY) THEN                                                                        
c              Tenv = 0.0                                                                           
c          ELSE                                                                                     
c              Tenv = Td(1,i-nY)                                                                    
c          ENDIF                                                                                    
c          IF (i.LE.nX) THEN                                                                        
c            write(30,'(1p,2e10.3,3x,8e9.2)')lambda(i),fdisk0(i),                                   
c     &                 x(i)/r1rstar, x(i), Tenv, Tdisk(i),                                         
c     &                 dhstar(i), dhvisc(i), dhemis(i), dhscat(i)                                  
c          ELSE                                                                                     
c            write(30,'(1p,2e10.3)')lambda(i),fdisk0(i)                                             
c          END IF                                                                                   
c        END DO                                                                                     
c        IF (nX.GT.nL) THEN                                                                         
c            DO i = nL+1, nX                                                                        
c               write(30,'(1p,24x,8e9.2)')x(i)/r1rstar,x(i), Tenv,                                  
c     &           Tdisk(i), dhstar(i), dhvisc(i), dhemis(i), dhscat(i)                              
c            END DO                                                                                 
c        END IF                                                                                     
c        IF (iD.GT.1) THEN                                                                          
cc          images at the selected wavelengths...                                                   
c           h1 = '      x    '                                                                      
c           write(31,'(a11,20f10.2)')h1,(lambdaD(i),i=1,nLd)                                        
c           DO i = 1, nX                                                                            
c             write(31,'(1p,e12.5,21e10.3)')x(i),(Idisk(j,i),j=1,nLd)                               
c           END DO                                                                                  
cc          ...and visibilities                                                                     
c           h1 = '  q theta*'                                                                       
c           write(32,'(a10,20f10.2)')h1,(lambdaD(i),i=1,nLd)                                        
c           DO i = 1, NvisiD                                                                        
c            write(32,'(1p,e12.5,21e10.3)')qtheta(i),(Vdisk(j,i),j=1,nLd)                           
c           END DO                                                                                  
c        END IF                                                                                     
c      END IF                                                                                       
	                                                                                                   
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ReadSpectar(lambdaS,Llamstar,Lstar,nLs,is,error)                                   
c =======================================================================                           
c     Reads the source spectrum from a file. This was part of Sub Star,                             
c     separated for clarity. is=1 for central s-ce, is=2 for external	[MN'01]                       
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      CHARACTER*235 line                                                                            
      INTEGER ios1, iLs, nLs, error, Nlambdam, Nis, is                                              
c     Nlambdam is the max number entries for a user supplied stellar spectrum                       
      PARAMETER (Nlambdam = 10000, Nis = 2)                                                         
      DOUBLE PRECISION lambdaS(Nlambdam), Llamstar(Nlambdam),                                       
     &        llS(Nlambdam), lS(Nlambdam), Lstar, a, b                                              
c -----------------------------------------------------------------------                           
c     for  startyp.GE.4 stellar spectrum is read from the file 'nameStar'                           
c     which is unit=3 (unit=1 is the input file)                                                    
c     is=1 for the enclosed source, is=2 for the external shell illumination                        
c       possible problems with the file are checked in Sub InpStar                                  
        open(3,file=nameStar(is),STATUS='OLD')                                                      
        rewind(3)                                                                                   
        read(3,'(a235)',ERR=998) line                                                               
        read(3,'(a235)',ERR=998) line                                                               
        read(3,'(a235)',ERR=998) line                                                               
        ios1 = 0                                                                                    
        iLs = 0                                                                                     
        DO WHILE (ios1.ge.0)                                                                        
          read(3,*,END=900,ERR=998,iostat=ios1) a, b                                                
          IF (ios1.ge.0) THEN                                                                       
            iLs = iLs + 1                                                                           
            lambdaS(iLs) = a                                                                        
            IF (a.LE.0.0) goto 998                                                                  
c           it is assumed that Llamstar is L_Lambda, but...                                         
c           if startyp.EQ.4 then file gives lambda*L_lambda                                         
            IF (startyp(is).EQ.4) Llamstar(iLs) = b / a                                             
c           if startyp.EQ.5 then file gives L_lambda                                                
            IF (startyp(is).EQ.5) Llamstar(iLs) = b                                                 
c           if startyp.EQ.6 then file gives Lnu=lambda**2*L_lambda                                  
            IF (startyp(is).EQ.6) Llamstar(iLs) = b / a / a                                         
          END IF                                                                                    
        END DO                                                                                      
900     close(3)                                                                                    
        IF (iLs.LT.2) goto 998                                                                      
        nLs = iLs                                                                                   
c       if input wavelengths in descending order turn them around                                   
        IF (lambdaS(1).GT.lambdaS(2)) THEN                                                          
          DO iLs = 1, nLs                                                                           
            llS(iLs) = lambdaS(iLs)                                                                 
            lS(iLs) = Llamstar(iLs)                                                                 
          END DO                                                                                    
          DO iLs = 1, nLs                                                                           
            lambdaS(iLs) = llS(nLs+1-iLs)                                                           
            Llamstar(iLs) = lS(nLs+1-iLs)                                                           
          END DO                                                                                    
        END IF                                                                                      
c       get the scale, Lstar, of the stellar spectrum                                               
        CALL Simpson(Nlambdam,1,nLs,lambdaS,Llamstar,Lstar)                                         
      error = 0                                                                                     
      goto 999                                                                                      
998   write(12,*)' *** FATAL ERROR IN DUSTY! *************************'                             
      write(12,*)' File with the spectral shape of external radiation:'                             
      write(12,'(a2,a100)')'  ',nameStar(1)                                                         
      write(12,*)' is missing or not properly formatted?!'                                          
      write(12,*)' ***************************************************'                             
      error = 3                                                                                     
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
c This function is taken from Moshe Elitzur.           [Z.I., Nov. 1995]                            
c =======================================================================                           
      DOUBLE PRECISION FUNCTION RDINP(Equal,IUNIT)                                                  
c =======================================================================                           
C     Read lines, up to 232 long, from prD-opened unit IUNIT and extract                            
C     all input numbers from them. When EQUAL is set, numeric input data                            
C     must be preceded by an equal sign.All non-numeric data and numbers                            
C     not preceded by = when EQUAL is on are ignored.RDINP = next number                            
C     encountered (after equal sign) and terminated by a nun-numeric                                
C     symbol (termination with blank is best). Commas and exponential                               
C     notation are allowed.  All text after % is ignored, as in TeX.                                
C     Lines with * in the first column are echoed to the output device.                             
C     The number is comprised of an actual VALUE, decimal part FRAC and                             
C     (integer) exponent PWR.  It has a SIGN, and the exponential power                             
C     has sign SIGNEX. Logical flag to the decimal part is set in                                   
C     DECIMAL. The search is conducted between FIRST, which is                                      
C     continuously increased, and LAST.  A new line is read when FIRST                              
C     exceeds LAST, and can be forced by calling with -IUNIT.  Actual                               
C     extraction of numerical value is done in separate FUNCTION VAL.                               
c =======================================================================                           
      IMPLICIT None                                                                                 
      Integer IUnit,Ind,First, Last                                                                 
      DOUBLE PRECISION Value,Val,Frac,Pwr,Sign,Signex                                               
      CHARACTER Card*(232),CR,prev,Term,Next                                                        
      Logical Equal,digit,minus,sgn,dot,E,decimal                                                   
      Save Card,First,Last                                                                          
      DATA First/1/, Last/0/                                                                        
c -----------------------------------------------------------------------                           
C FUNCTION STATEMENTS                                                                               
      digit(CR) = CR.GE.'0' .AND. CR.LE.'9'                                                         
      minus(CR) = CR.EQ.'-'                                                                         
      sgn(CR)   = CR.EQ.'+' .OR. CR.EQ.'-'                                                          
      dot(CR)   = CR.EQ.'.'                                                                         
      E(CR)     = CR.EQ.'E' .OR. CR.EQ.'e'                                                          
C                                                                                                   
      IF (IUnit.lt.0) Then                                                                          
         First = Last + 1                                                                           
         IUnit = -IUnit                                                                             
      END IF                                                                                        
c     Start the search for the next number:                                                         
  1   RDINP  = 0.0D+00                                                                                   
      VALUE  = 0.0D+00                                                                                   
      FRAC   = 0.0D+00                                                                                   
      PWR    = 0.0D+00                                                                                   
      SIGN   = 1.0D+00                                                                                   
      SIGNEX = 1.0D+00                                                                                   
      Decimal = .False.                                                                             
      If (first.gt.last) then                                                                       
c     Time to get a new line                                                                        
         READ (IUNIT, '(A)' , END = 99) Card                                                        
         first = 1                                                                                  
         last = len(Card)                                                                           
c        Find start of trailing junk:                                                               
         DO WHILE (Card(last:last).LE.' ')                                                          
          last = last - 1                                                                           
          if (last.lt.first) goto 1                                                                 
         END DO                                                                                     
         IF (Card(first:first).EQ.'*') WRITE (12,'(A)') Card(1:last)                                
         ind = Index(Card,'%')                                                                      
         if (ind.gt.0) last = ind - 1                                                               
      End If                                                                                        
                                                                                                    
c     Get past the next '=' when the EQUAL flag is set                                              
      If (Equal) then                                                                               
        DO WHILE (Card(first:first).NE.'=')                                                         
          first = first + 1                                                                         
          IF (first.GT.last) goto 1                                                                 
        END DO                                                                                      
      End If                                                                                        
c     OK, start searching for the next digit:                                                       
c      Do While (.not.digit(Card(first:first)))                                                     
       Do While                                                                                     
     &    (.not.(Card(first:first).ge.'0'.AND.Card(first:first).le.'9'))                            
          first = first + 1                                                                         
          if (first.gt.last) goto 1                                                                 
      End Do                                                                                        
c     Check if it is a negative or decimal number                                                   
      If (first.gt.1) then                                                                          
         prev = Card(first-1:first-1)                                                               
c         necessary syntax changes, otherwise the code crushes on ncx[MN]                           
c         if (minus(prev)) sign = -1.                                                               
         if (prev.eq.'-') sign = -1.                                                                
c         if (dot(prev)) then                                                                       
         if (prev.eq.'.') then                                                                      
           decimal = .True.                                                                         
           if (first.gt.2 .and.                                                                     
     &        (Card(first-2:first-2).eq.'-')) sign = -1.                                            
         end if                                                                                     
      End If                                                                                        
c     Extract the numerical value                                                                   
      IF (.not.Decimal) Then                                                                        
         Value = VAL(Card,first,last,decimal,Term)                                                  
c        Check for a possible decimal part.  Termination with '.E' or                               
c        '.e' is equivalent to the same ending without '.'                                          
c         if (first.lt.last.and.dot(Term)) then                                                     
         if (first.lt.last.and.Term.eq.'.') then                                                    
            first = first + 1                                                                       
            next = Card(first:first)                                                                
c            if (digit(next)) decimal = .true.                                                      
            if (next.GE.'0' .AND. next.LE.'9') decimal = .true.                                     
c            if (E(next)) Term = 'E'                                                                
            if (next.eq.'E' .OR. next.EQ.'e') Term = 'E'                                            
         end if                                                                                     
      END IF                                                                                        
c     Extract the decimal fraction, when it exists                                                  
      IF (Decimal) Frac = VAL(Card,first,last,decimal,Term)                                         
c     An exponential may exist if any part terminated with 'E' or 'e'                               
c       IF (first.lt.last.and.E(term)) then                                                         
       IF (first.lt.last.AND.(term.eq.'E'.or.term.eq.'e')) then                                     
         first = first + 1                                                                          
         next = Card(first:first)                                                                   
c         if (first.lt.last.and.sgn(next))then                                                      
         if (first.lt.last.AND.(next.EQ.'+'.or.next.EQ.'-')) then                                   
            first = first + 1                                                                       
c            if (minus(next)) Signex = -1.                                                          
            if (next.eq.'-') Signex = -1.                                                           
         end if                                                                                     
         decimal = .False.                                                                          
         PWR = VAL(Card,first,last,decimal,Term)                                                    
      END IF                                                                                        
c     Finally, put the number together                                                              
      RDINP = Sign*(Value + Frac)*10.0D+00**(Signex*PWR)                                                  
      Return                                                                                        
                                                                                                    
99    WRITE (12,'(3(1x,a,/))')                                                                      
     *' ****TERMINATED. EOF reached by RDINP while looking for input. ',                            
     *' *** Last line read:',Card                                                                   
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
c This function is taken from Moshe Elitzur            [Z.I., Nov. 1995]                            
c =======================================================================                           
      DOUBLE PRECISION FUNCTION VAL(Card,first,last,decimal,Term)                                   
c     Extract numerical value from CARD, begining at position FIRST up                              
c     to the first non-digit encountered.  The terminating character is                             
c     returned in TERM, its position in FIRST. Commas are treated as                                
c     simple separators.                                                                            
c =======================================================================                           
      IMPLICIT None                                                                                 
      Character Card*(*), Term, CH                                                                  
      Logical Decimal, digit                                                                        
      Integer IVAL, first, last, first0                                                             
      DOUBLE PRECISION pwr                                                                                      
c -----------------------------------------------------------------------                           
C     FUNCTION STATEMENTS                                                                           
      IVAL(CH) = ICHAR(CH) - ICHAR('0')                                                             
      digit(CH) = CH.GE.'0' .AND. CH.LE.'9'                                                         
c                                                                                                   
      VAL = 0.0D+00                                                                                      
      pwr = 1.0D+00                                                                                      
      first0 = first                                                                                
      DO 10 first = first0, last                                                                    
         Term = Card(first:first)                                                                   
         if (Term.eq.',') goto 10                                                                   
c         if (.not.digit(Term)) Return                                                              
         if (.not.(Term.GE.'0' .AND. Term.LE.'9')) Return                                           
         If (decimal) then                                                                          
            pwr = pwr*0.1D+00
            Val = Val + pwr*IVAL(Term)                                                              
         Else                                                                                       
            Val = 10.0D+00*Val + IVAL(Term)                                                              
         End If                                                                                     
  10  CONTINUE                                                                                      
      Term = ' '                                                                                    
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE WriteOut(var1,var2,var3,nG,nameQ,nameNK)                                           
c =======================================================================                           
c     WriteOut prints in fname.out all input, read before density                                   
c     distribution type.                                                                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER is, iG, nG, i, length                                                                 
      DOUBLE PRECISION var1, var2, var3                                                             
      CHARACTER*72 strpow, aux, src, chaux*3                                                        
      CHARACTER*(*) nameQ(npG), nameNK(10)                                                          
      LOGICAL first                                                                                 
      first = .true.                                                                                
c -------------------------------------------------------------------------                         
      is = 1                                                                                        
15    IF (SLB) THEN                                                                                 
        IF (is.eq.1) THEN                                                                           
          src = 'Left-side source spectrum described by'                                            
        ELSE                                                                                        
          src = 'Right-side source spectrum described by'                                           
        END IF                                                                                      
      ELSE                                                                                          
        IF (is.eq.1) THEN                                                                           
          src = 'Central source spectrum described by'                                              
        ELSE                                                                                        
          src = 'External source spectrum described by'                                             
        END IF                                                                                      
      END IF                                                                                        
      CALL Clean(src, aux, length)                                                                  
                                                                                                    
      IF(Left.eq.0.AND.is.eq.1) THEN                                                                
        write(12,*) ' No central source.'                                                           
      ELSE                                                                                          
c     #1: black body(ies) for startyp=1                                                             
       IF (startyp(is).EQ.1) THEN                                                                   
        IF (nBB(is).GT.1) THEN                                                                      
         CALL ATTACH(aux, length, ' ', src)                                                         
c        multiple black bodies                                                                      
         write(12,'(a2,a37,i2,a13)')'  ', src, nBB(is),' black bodies'                              
         write(12,'(a27)')' with temperatures (in K):'                                              
         write(12,'(2x,1p,10e10.3)')(Tbb(is,i),i=1,nBB(is))                                         
         write(12,'(a42)')' and relative luminosities, respectively:'                               
         write(12,'(1p,10e10.1)')(rellum(is,i),i=1,nBB(is))                                         
        ELSE                                                                                        
c        for a single black body:                                                                   
         CALL ATTACH(aux,length,' a black body',src)                                                
         write(12,'(a2,a)') '  ',src                                                                
        write(12,'(a19,1p,e10.3,a2)')' with temperature:',Tbb(is,1),' K'                            
        END IF                                                                                      
       END IF                                                                                       
                                                                                                    
c     #2: EngelkD-Marengo function for startyp=2                                                    
       IF (startyp(is).EQ.2) THEN                                                                   
         CALL ATTACH(aux, length,' EngelkD-Marengo function', src)                                  
         write(12,'(a2,a)') '  ',src                                                                
         write(12,'(a13,1p,e10.3,a16)')' with Teff =',Tbb(is,1),                                    
     &                                ' K and depth of'                                             
         write(12,'(a30,F6.1,a2)')' the SiO absorption feature =',                                  
     &                              xSiO,' %'                                                       
       END IF                                                                                       
                                                                                                    
c     #3: power-law(s) for startyp=3                                                                
       IF (startyp(is).EQ.3) THEN                                                                   
         IF (Nlamtr(is).GT.0) THEN                                                                  
           CALL ATTACH(aux,length,' power law:',src)                                                
           write(12,'(a2,a)') '  ',src                                                              
           write(12,*)'    lambda      k'                                                           
           DO i = 1, Nlamtr(is)                                                                     
            write(12,'(1x,1p,e10.3)')lamtr(is,i)                                                    
            write(12,'(11x,1p,e10.3)')klam(is,i)                                                    
           END DO                                                                                   
           write(12,'(1x,1p,e10.3)')lamtr(is,Nlamtr(is)+1)                                          
         ELSE                                                                                       
           write(12,*)                                                                              
     &      ' Input data for the source spectrum is not good.'                                      
           write(12,*)' Changed to a 10000 K black body'                                            
         END IF                                                                                     
       END IF                                                                                       
                                                                                                    
c      spectrum from a file for startyp=4,5,6                                                       
       IF (startyp(is).GE.4.AND.startyp(is).LE.6) THEN                                              
         IF (is.eq.1) THEN                                                                          
           write(12,*)' Stellar spectrum supplied from file:'                                       
         ELSE                                                                                       
           write(12,*)' External spectrum supplied from file:'                                      
         END IF                                                                                     
         write(12,'(a2,a100)') '  ',nameStar(is)                                                    
         CALL PrHeader(3,nameStar(is))                                                              
       END IF                                                                                       
      END IF                                                                                        
      write(12,*)' --------------------------------------------'                                    
      IF(first) THEN                                                                                
c       if there is a second source go back to read its parameters                                  
        IF(Right.GT.0) THEN                                                                        
c          repeat printout of source info for the external radiation                                
c          its index is is=2                                                                        
           is = 2                                                                                   
           first = .false.                                                                          
           goto 15                                                                                  
        END IF                                                                                      
      END IF                                                                                        
      is = 1                                                                                        
c -----------------------------------------------------                                             
c     Boundary Condition data: typEntry(is) and value                                               
      IF(Left.GT.0) THEN                                                                            
        IF(typEntry(1).eq.1) THEN                                                                   
          DO iG = 1, nG                                                                             
           IF (SLB) THEN                                                                            
             write(12,'(a45,1p,e9.2,a2)')                                                           
     &    ' Dust temperature on the slab left boundary:', Tsub(iG),' K'                             
           ELSE                                                                                     
            write(12,'(a41,1p,e9.2,a2)')                                                            
     &        ' Dust temperature on the inner boundary:', Tsub(iG),' K'                             
           END IF                                                                                   
          END DO                                                                                    
        ELSE IF (typEntry(1).eq.2) THEN                                                             
c         if spectrum from a file the bol.flux is found from the file                               
c         with normalization factor from input (using the same variable                             
c         dilutin, in 'stellar.inc')                                                                
          IF (startyp(1).GT.3) THEN                                                                 
            write(12,'(a29,1p,e9.2,a6)')                                                            
     &      ' Flux at the inner boundary:', dilutn*var1,' W/m^2'                                    
          ELSE                                                                                      
            write(12,'(a29,1p,e9.2,a6)')                                                            
     &      ' Flux at the inner boundary:', var1,' W/m^2'                                           
          END IF                                                                                    
        ELSE IF (typEntry(1).eq.3) THEN                                                             
          write(12,'(a20,1p,e9.2,a17,1p,e9.3,a3)')                                                  
     &    ' Source luminosity ', var1,' Lo and distance ', var2, ' cm'                              
        ELSE                                                                                        
          write(12,'(a48,1p,e10.3,a2)')                                                             
     &    ' Effective temperature of the illuminating flux:', var1,' K'                             
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
      IF(Right.GT.0.AND.denstyp.NE.0) THEN                                                          
        IF(typEntry(2).eq.1) THEN                                                                   
          write(12,'(a43,1p,e9.2,a6)')                                                              
     &    '  Mean intensity of the external radiation:', var3,' W/m^2'                              
        ELSE                                                                                        
          IF (startyp(2).GT.3) THEN                                                                 
            write(12,'(a48,1p,e9.2)')                                                               
     &      '  Normalization factor of the external radiation:', dilutn                             
            write(12,'(a52,1p,e9.2,a6)')                                                            
     &      '  Mean intensity from the file after renormalization:',                                
     &         var3,' W/m^2'                                                                        
          ELSE                                                                                      
            write(12,'(a43,1p,e9.2)')                                                               
     &      '  Dilution factor of the external radiation:', dilutn                                  
          END IF                                                                                    
        END IF                                                                                      
      END IF                                                                                        
      write(12,*)' --------------------------------------------'                                    
c -----------------------------------------------------                                             
c      2) DUST PROPERTIES                                                                           
c      2.1 Chemical Composition                                                                     
       IF (top.LT.3) THEN                                                                           
        write(12,*)' Abundances for supported grains:'                                              
        write(12,*)' Sil-Ow Sil-Oc Sil-DL grf-DL amC-Hn SiC-Pg'                                     
        write(12,'(6f7.3)')(xC(i),i=1,3),xC(4)+xC(5),(xC(i),i=6,7)                                  
        IF (top.EQ.2) THEN                                                                          
          write(12,*)' Abundances for user supplied grains:'                                        
          write(12,'(i6,9i7)')(i,i=1,Nfiles)                                                        
          write(12,'(10f7.3)')(xCuser(i),i=1,Nfiles)                                                
          write(12,*)' User supplied n and k from:'                                                 
          DO i = 1, Nfiles                                                                          
            write(12,'(a2,i1,a2,a70)')'  ',i,') ',nameNK(i)                                         
          END DO                                                                                    
        END IF                                                                                      
c      user supplied cross-sections:                                                                
       ELSE                                                                                         
        DO iG = 1, nG                                                                               
          write(12,*)' Optical properties from file(s):'                                            
          write(12,'(a2,a70)')'  ',nameQ(iG)                                                        
          CALL PrHeader(3,nameQ(iG))                                                                
        END DO                                                                                      
       END IF                                                                                       
c      2.2 Grain size distribution                                                                  
       IF (top.NE.3) THEN                                                                           
         IF (szds.EQ.3) THEN                                                                        
          chaux = 'KMH'                                                                             
         ELSE                                                                                       
          chaux = 'MRN'                                                                             
         END IF                                                                                     
         write(12,'(a2,a3,a19)')'  ',chaux,'size distribution:'                                     
         CALL getfs(qsd,1,0,strpow)                                                                 
         write(12,'(a15,a5)')'      Power q:',strpow                                                
         write(12,'(a15,1p,e9.2,a8)')                                                               
     &                         ' Minimal size:',a1,' microns'                                       
         IF (szds.EQ.3) THEN                                                                        
            write(12,'(a22,1p,e9.2,a8)')                                                            
     &                            ' Characteristic size:',a2,' microns'                             
         ELSE                                                                                       
           write(12,'(a15,1p,e9.2,a8)')' Maximal size:',a2,' microns'                               
         END IF                                                                                     
       END IF                                                                                       
       write(12,*)' --------------------------------------------'                                   
                                                                                                    
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
c =========================================================================                         
c     These are the subroutines related to the radiative transfer calculation.                      
c                                                             [MN, Mar'99]                          
c =========================================================================                         
C     Table of Contents                                                                             
C                                                                                                   
C     DblYgrid                                                                                      
C     EMISSION                                                                                      
C     EMfunc                                                                                        
C     GetSPShape                                                                                    
C     GFUN                                                                                          
C     FINDTEMP                                                                                      
C     GRAYBODY                                                                                      
C     INITTEMP                                                                                      
C     INSERT                                                                                        
C     IntegExt                                                                                      
C     INTETA                                                                                        
C     INVERT                                                                                        
C     KINT4                                                                                         
C     MATRIX                                                                                        
C     NORDLUND                                                                                      
C     OCCLTMSG                                                                                      
C     PGRID                                                                                         
C     PLANCK                                                                                        
C     RADTRANSF                                                                                     
C     SETGRIDS                                                                                      
C     SOLVE                                                                                         
C     STAR                                                                                          
C     TRAPZD2                                                                                       
C     TWOFUN                                                                                        
C     WEIGHTS                                                                                       
C     YGRID                                                                                         
c =========================================================================                         
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE DblYgrid(error)                                                                    
c =======================================================================                           
c     Doubles the initial Y grid for tests of external radiation. [MN]                              
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER iYins(npY), k, kins, iY, error                                                        
      DOUBLE PRECISION Yins(npY)                                                                    
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
      kins = 0                                                                                      
      DO iY = 2, nY                                                                                 
          kins = kins + 1                                                                           
          Yins(kins) = Y(iY-1)+0.5D+00*(Y(iY)-Y(iY-1))                                                  
          iYins(kins) = iY-1                                                                        
      END DO                                                                                        
c     Add all new points to Y(nY). This gives the new Y(nY+kins).                                   
c     However, check if npY is large enough to insert all points:                                   
      IF ((nY+kins).GT.npY) THEN                                                                    
        IF (iX.GE.1) THEN                                                                           
         write(18,*)' ****************     WARNING   ******************'                            
         write(18,*)'  The new Y grid can not accomodate more points!'                              
         write(18,'(a,i3)')'   Specified accuracy would require',nY+kins                            
         write(18,'(a,i3,a)')'   points, while npY =',npY,'.'                                       
         write(18,*)'  For the required accuracy npY must be increased,'                            
         write(18,*)'  (see the manual S3.5 Numerical Accuracy).'                                   
         write(18,*)' *************************************************'                            
        END IF                                                                                      
        kins = npY - nY                                                                             
        iWARNING = iWARNING + 1                                                                     
        error = 2                                                                                   
      END IF                                                                                        
c      insert the extra points                                                                      
       DO k = 1, kins                                                                               
         CALL SHIFT(Y,npY,nY+k-1,Yins(k),iYins(k)+k-1)                                              
       END DO                                                                                       
c     new size of the Y grid                                                                        
      nY = nY + kins                                                                                
c -----------------------------------------------------------------------                           
777   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Emission(geom,flag,nG,Td,abund,Uin,Emiss)                                          
c =======================================================================                           
c This subroutine calculates emission term from the temperature and abund                           
c arrays for flag=0, and adds U to it for flag=1.                                                   
c                                                      [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iG, iY, iL, nG, flag, geom                                                            
      DOUBLE PRECISION Uin(npL,npY), Td(npG,npY), Emiss(npL,npY),                                   
     &        abund(npG,npY), EmiG, TT, xP, Planck                                                  
c -----------------------------------------------------------------------                           
c     first initialize Emiss                                                                        
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       loop over radial coordinate                                                                 
        DO iY = 1, nY                                                                               
          Emiss(iL,iY) = 0.0D+00                                                                        
        END DO                                                                                      
      END DO                                                                                        
c     calculate emission term for each component and add it to Emiss                                
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       loop over radial coordinate                                                                 
        DO iY = 1, nY                                                                               
c         loop over grains                                                                          
          DO iG = 1, nG                                                                             
            xP = 14400.0D+00 / lambda(iL) / Td(iG,iY)                                                   
            IF(geom.NE.0) THEN                                                                      
              IF(Left.eq.0) THEN                                                                    
                TT = (Td(iG,iY)**4.0D+00)/
     &         (0.25D+00*Tei**4.0D+00+Y(nY)*Y(nY)*Teo**4.0D+00)                            
              ELSE                                                                                  
                TT = (Td(iG,iY)**4.0D+00)/
     &                     (0.25D+00*Tei**4.0D+00+Teo**4.0D+00)                                        
              END IF                                                                                
              TT = TT * Y(iY)**2.0D+00                                                                   
            ELSE                                                                                    
              TT = 4.0D+00 * (Td(iG,iY)/Tei)**4.0D+00                                                         
            END IF                                                                                  
            EmiG = abund(iG,iY) * TT * Planck(xP)                                                   
c           add contribution for current grains                                                     
            Emiss(iL,iY) = Emiss(iL,iY) + EmiG                                                      
          END DO                                                                                    
c         if needed add Uin                                                                         
          IF (flag.EQ.1) THEN                                                                       
            Emiss(iL,iY) = Emiss(iL,iY) + Uin(iL,iY)                                                
          END IF                                                                                    
          IF (Emiss(iL,iY).LT.dynrange*dynrange) Emiss(iL,iY) = 0.0D+00
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION EMfunc(lambda,Teff,xSiO)                                            
c This is modeled after subroutine engelke by M. Marengo. Here are his                              
c original comments:                                                                                
c     =================================================================                             
c     This subroutine computes a modified black body spectrum using an                              
c     "Engelke" function (see Engelke 1992, AJ 104, 1248):                                          
c     Bnu = Bnu(Tb) with Tb = 0.738*Teff*(1+79450/(lambda*Teff))**0.182                             
c                                                                                                   
c     Molecular SiO absorption is modelled from the alpha Tau spectrum                              
c     of Cohen et al. 1992, AJ 104,2030 with a 5th order polinomial,                                
c     and added to the modified bb.                                                                 
c                                                                                                   
c     M. Marengo - mmarengo@cfa.harvard.edu - Sep 1998                                              
c     =================================================================                             
c                                                                                                   
c                                                                                                   
c This version makes use of the scaled quantities and Dusty's function                              
c Planck(x)                                                  [ZI, Feb 99]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER j                                                                                     
      DOUBLE PRECISION lambda, Teff, xSiO, x, Planck, Teng, SiOc(6),                                
     &                 lambda1, lambda2, SiO8m, SiOf                                                
c -----------------------------------------------------------------------                           
c  SiO fit data from Massimo:                                                                       
c     Polinomial coeff for SiO absorption model (5th order),                                        
c     wavelength interval in which to apply the absorption                                          
c     and given absorption at 8 micron (to rescale for SiO)                                         
      lambda1 =  7.8636D+00                                                                             
      lambda2 = 11.4280D+00                                                                             
        SiO8m = 1.0701447D+00                                                                           
      SiOc(1) = -300.43916D+00                                                                          
      SiOc(2) =  149.32134D+00                                                                          
      SiOc(3) =  -29.493280D+00                                                                         
      SiOc(4) =    2.9067144D+00                                                                        
      SiOc(5) =   -0.14304663D+00                                                                       
      SiOc(6) =    0.0028134070D+00                                                                     
c -----------------------------------------------------------------------                           
c     Engelke's effective temperature                                                               
      Teng = 0.738D+00*Teff*(1.0D+00 + 79450.0D+00/
     &                           (lambda*Teff))**0.182D+00                                    
      x = 14400.0D+00 / lambda / Teng                                                                   
      EMfunc = (Teng/Teff)**4.0D+00 * Planck(x)                                                           
c     If lambda is in SiO region, compute and apply the SiO absorption                              
      IF ((lambda-lambda1)*(lambda-lambda2).LT.0.0D+00) THEN                                              
          SiOf = 0.0D+00                                                                                
          DO j = 1, 6                                                                               
             SiOf = SiOf + SiOc(j) * lambda**(1.0D+00*j-1)                                              
          END DO                                                                                    
          EMfunc = EMfunc / (1.0 D+00+ (SiOf-1)/(SiO8m-1)*xSiO*0.01D+00)                                    
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE GetSPShape(Shp,is)                                                                 
c =======================================================================                           
c     Produces source sp.shape. This was part of Star, separated                                    
c     here for clarity.  [MN]                                                                       
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iY, iL, iLs, nLs, k, kstop, i, error, Nlambdam,                                       
     &        Nis, is                                                                               
c     Nlambdam is the max number entries for a user supplied stellar spectrum                       
      PARAMETER (Nlambdam = 10000, Nis = 2)                                                         
      DOUBLE PRECISION lambdaS(Nlambdam), Llamstar(Nlambdam), Shp(npL),                             
     &       Stellar(Nlambdam), fL(100), fpl(npL), Lstar, EMfunc, BP,                               
     &       Bb, x, Planck                                                                          
c -----------------------------------------------------------------------                           
c     is=1 for the enclosed source, is=2 for the external shell illumination                        
      IF ((startyp(is).GE.4).AND.(startyp(is).LE.6)) THEN                                           
        CALL ReadSpectar(lambdaS,Llamstar,Lstar,nLs,is,error)                                       
c       generate dimensionless stellar spectrum                                                     
        DO iLs = 1, nLs                                                                             
          Stellar(iLs) = lambdaS(iLs) * Llamstar(iLs) / Lstar                                       
        END DO                                                                                      
      ELSE                                                                                          
c       if startyp.EQ.3 generate power-law spectrum                                                 
        IF (startyp(is).EQ.3) THEN                                                                  
          fL(1) = 1.0D+00                                                                               
          IF (Nlamtr(1).GT.1) THEN                                                                  
            DO i = 2, Nlamtr(1)                                                                     
              fL(i) = fL(i-1)*(lamtr(is,i-1)/lamtr(is,i))**klam(is,i-1)                             
            END DO                                                                                  
          END IF                                                                                    
          DO iL = 1, nL                                                                             
            IF ((lambda(iL)-lamtr(is,1))*(lambda(iL)-                                               
     &                          lamtr(is,Nlamtr(1)+1)).LE.0.0D+00) THEN                             
              kstop = 0                                                                             
              k = 0                                                                                 
              DO WHILE (kstop.EQ.0)                                                                 
                k = k + 1                                                                           
                IF (lambda(iL).GE.lamtr(is,k).and.     
     *                 lambda(iL).LE.lamtr(is,k+1)) THEN                                                  
                  kstop = 1                                                                         
                  fpl(iL) = fL(k) * (lamtr(is,k)/lambda(iL))**klam(is,k)                            
                END IF                                                                              
              END DO                                                                                
            ELSE                                                                                    
              fpl(iL) = 0.0D+00                                                                         
            END IF                                                                                  
          END DO                                                                                    
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
      DO iY = 1, nY                                                                                 
c       loop over wavelengths                                                                       
        DO iL = 1, nL                                                                               
          IF (startyp(is).EQ.1) THEN                                                                
            Bb = 0.0D+00                                                                                
            DO k = 1, nBB(is)                                                                       
              x = 14400.0D+00 / lambda(iL) / Tbb(is,k)                                                  
              Bb = Bb + rellum(is,k)*Planck(x)                                                      
            END DO                                                                                  
          ELSE IF (startyp(is).EQ.2) THEN                                                           
              Bb = EMfunc(lambda(iL),Tbb(is,1),xSiO)                                                
          ELSE IF (startyp(is).EQ.3) THEN                                                           
              Bb = fpl(iL)                                                                          
          ELSE IF (lambda(iL).GT.lambdaS(nLs)) THEN                                                 
c             for lambda longer than the longest entry in nameStar                                  
c             assume Rayleigh-Jeans tail                                                            
              Bb = Stellar(nLs) * (lambdaS(nLs)/lambda(iL))**3.0D+00                                     
          ELSE IF (lambda(iL).LT.lambdaS(1)) THEN                                                   
c             if shorter than the shortest assume 0                                                 
              Bb = 0.0D+00                                                                              
          ELSE                                                                                      
c             if within limits interpolate                                                          
c !!!!!!!!!!!!!!!!!! (after comment by Chad Young)                                                  
c              CALL LinInter(Nlambdam,nLs,lambdaS,Stellar,                                          
c     &                                             lambda(iL),iLs,BP)                              
                                                                                                    
              CALL PowerInter(Nlambdam,nLs,lambdaS,Stellar,                                         
     &                                             lambda(iL),iLs,BP)                               
                                                                                                    
              Bb = BP                                                                               
          END IF                                                                                    
         Shp(iL) = Bb                                                                               
        END DO                                                                                      
      END DO                                                                                        
                                                                                                    
      error = 0                                                                                     
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION Gfun(Tt)                                                            
c =======================================================================                           
c This is an auxiliary function used in determining the dust temperature                            
c                                                      [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER iW, nW                                                                                
      DOUBLE PRECISION Tt, wav(npL), Eff(npL), ff(npL), xP, gg, f1, f2,                             
     &       Planck                                                                                 
      COMMON /gfunction/ wav, Eff, f1, f2, nW                                                       
c -----------------------------------------------------------------------                           
      DO iW = 1, nW                                                                                 
        xP = 14400.0D+00 / wav(iW) / Tt                                                                 
        ff(iW) = Eff(iW) * Planck(xP) / wav(iW)                                                     
      END DO                                                                                        
      CALL Simpson(npL,1,nW,wav,ff,gg)                                                              
c     gg is qP(T)                                                                                   
      Gfun = f1 - f2 * gg * Tt**4.0D+00                                                                 
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE FindTemp(geom,Utot,nG,Td)                                                          
c =======================================================================                           
c This subroutine finds new temperature and alpha arrays from Utot.                                 
c Temperature is obtained by solving:                                                               
c   f1(y) - f2(y)*g(T) = 0                                                                          
c where                                                                                             
c   f1(y) = Int(Qabs*Utot*dlambda)                                                                  
c   f2(y) = 4/Te4*y**2                                                                              
c   g(T) = qP(Td)*Td**4                                                                             
c   Te4 = Te**4 , Te is the effective T of the illuminating radiation                               
c The equation is solved by Ridder's method.                                                        
c                                                     [ZI'96, MN,'00]                               
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iG, iY, iL,nG, nW, succes, geom                                                       
      DOUBLE PRECISION Utot(npL,npY), Td(npG,npY), fnum(npL),                                       
     &        fdenum(npL), xP, Tin, Planck, qPT1, qU1,                                              
     &        wav(npL), Eff(npL), f1, f2, gfun, x1, x2,  Zriddr                                     
      EXTERNAL gfun                                                                                 
      COMMON /gfunction/ wav, Eff, f1, f2, nW                                                       
c -----------------------------------------------------------------------                           
      nW = nL                                                                                       
c     loop over grains                                                                              
      DO iG = 1, nG                                                                                 
c       if T1 given in input:                                                                       
        IF(typEntry(1).eq.1) THEN                                                                   
          DO iL = 1, nL                                                                             
            fnum(iL) = SigmaA(iG,iL) * Utot(iL,1) / lambda(iL)                                      
            xP = 14400.0D+00 / lambda(iL) / Tsub(1)                                                     
            fdenum(iL) = SigmaA(iG,iL) * Planck(xP) / lambda(iL)                                    
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,fnum,qU1)                                                    
          CALL Simpson(npL,1,nL,lambda,fdenum,qPT1)                                                 
          Tei = Tsub(1)*(4.0D+00*qPT1/qU1)**0.25D+00                                                         
        END IF                                                                                      
                                                                                                    
c       loop over radial positions (solving f1-f2*g(T)=0)                                           
        DO iY = 1, nY                                                                               
c         calculate f1 and f2                                                                       
          DO iL = 1, nL                                                                             
c           these are needed in Gfun:                                                               
            wav(iL) = lambda(iL)                                                                    
            Eff(iL) = SigmaA(iG,iL)                                                                 
            fnum(iL) = SigmaA(iG,iL) * Utot(iL,iY) / lambda(iL)                                     
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,fnum,f1)                                                     
          IF(geom.NE.0) THEN                                                                        
c           for sphere (with or w/o external rad.)                                                  
            IF (Left.eq.1.AND.Right.eq.1) THEN                                                      
             f2 = 1.0D+00 / (0.25D+00*Tei**4.0D+00 + Teo**4.0D+00)                                                     
            ELSE IF(Left.eq.1.AND.Right.eq.0) THEN                                                  
             f2 = 1.0D+00 / (0.25D+00*Tei**4.0D+00)                                                               
            ELSE IF(Left.eq.0.AND.Right.eq.1) THEN                                                  
c             f2 = 1.0D+00 / (Teo**4.0D+00)                                                                   
             f2 = 1.0D+00 / (Y(nY)*Y(nY)*Teo**4.0D+00)                                                        
            END IF                                                                                  
            f2 = f2 * Y(iY)**2.0D+00                                                                     
          ELSE                                                                                      
c           for slab                                                                                
            f2 = 4.0D+00 / Tei**4.0D+00                                                                       
          END IF                                                                                    
c         estimate range for temperature                                                            
          x1 = Td(iG,iY)                                                                            
          x2 = 1.01D+00*Td(iG,iY)                                                                       
c         make sure that correct solution is bracketted                                             
          CALL Zbrac(gfun,x1,x2,100,succes)                                                         
          IF (succes.NE.1) THEN                                                                     
            CALL Msg(4)                                                                             
          ELSE                                                                                      
c           save the old value of Td                                                                
            Tin = Td(iG,iY)                                                                         
c           get new temperature                                                                     
            Td(iG,iY) = Zriddr(gfun,x1,x2,500,accConv)                                              
          END IF                                                                                    
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE GrayBody(albedo,TAUgbTot,Ugb,fgb,ETAzp)                                            
c =======================================================================                           
c This subroutine solves the gray body problem for albedo=1 (or                                     
c equivalently pure scattering) and scattering with absorption (but no                              
c emission) for albedo<1, in a spherically symmetric envelope. Total                                
c optical depth is TAUtot, and density law is specified elsewhere.                                  
c This subroutine was designed to be a part of Dusty and to use already                             
c existing subroutines as much as possible, so some parts might seem to                             
c be a little awkward.                           [ZI,Jul'96;MN,Sep'97]                              
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER iPGB, iY, nLstore, error                                                              
      DOUBLE PRECISION ETAzp(npP,npY), mat0(npL,npY,npY),                                           
     &       mat1(npL,npY,npY), Em(npL,npY), Ugb(npY), fgb(npY),                                    
     &       Dummy1(npL,npP,npY), Dummy2(npL,npP,npY), Dummy3(npL,npY),                             
     &       albedo, pGB, TAUgbTot, TAUstore                                                        
c ----------------------------------------------------------------------                            
c     Values needed in this subroutine only                                                         
      pGB = 0.0D+00                                                                                     
      iPGB = 0                                                                                      
      nLstore = nL                                                                                  
      nL = 1                                                                                        
      TAUstore = TAUtot(1)                                                                          
      TAUtot(1) = TAUgbTot                                                                          
c     generate spline coefficients for ETA                                                          
      CALL setupETA                                                                                 
c     evaluate ETAzp                                                                                
      CALL getETAzp(ETAzp)                                                                          
c     generate some temporary arrays                                                                
      DO iY = 1, nY                                                                                 
        Us(1,iY) = dexp(-ETAzp(1,iY)*TAUgbTot)                                                      
        fs(1,iY) = Us(1,iY)                                                                         
        Em(1,iY) = 0.0D+00                                                                              
        fde(1,iY) = 0.0D+00                                                                             
        omega(1,iY) = albedo                                                                        
      END DO                                                                                        
c     find radiative transfer matrices                                                              
      CALL Matrix(ETAzp,pGB,iPGB,mat0,mat1,Dummy1,Dummy2)                                           
c     solve for Utot                                                                                
      CALL Invert(nY,nL,mat0,Us,Em,omega,Utot,Dummy3,error)                                         
c     calculate flux, ftot                                                                          
      CALL Multiply(1,npY,nY,npL,nL,mat1,Utot,omega,1,fs,ftot)                                      
c     store to the output arrays                                                                    
      DO iY = 1, nY                                                                                 
        Ugb(iY) = Utot(1,iY)                                                                        
        fgb(iY) = ftot(1,iY)                                                                        
      END DO                                                                                        
      nL = nLstore                                                                                  
      TAUtot(1) = TAUstore                                                                          
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE InitTemp(ETAzp,nG)                                                                 
c =======================================================================                           
c This subroutine initializes the first approximation for temperature.                              
c It uses approximations given by eqs. B5 and B7 from IE97.                                         
c T(y) is found as 4(T/Te)^4*y^2*qP(T) = Int{qa_l*Utot_l dl}.  [ZI'96; MN'00]                       
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iL, iY, iG, nG, istop, iW, it                                                         
      DOUBLE PRECISION ETAzp(npP,npY), xP, Planck, resaux, aux(npY),                                
     &       faux(npL), fstar(npY), Qfstar(npY), fstarQ(npY), QP(npY),                              
     &       Sigext(npL), QF(npY), RHS(npY), oldRHS(npY),                                           
     &       EtaQF, ETA, delta                                                                      
c -----------------------------------------------------------------------                           
c     Lambda integral of fs=f_e*exp(-TAU) -> fstar                                                  
      DO iY = 1, nY                                                                                 
c       generate auxiliary function for lambda integration:                                         
        DO iL = 1, nL                                                                               
          faux(iL) = fs(iL,iY) / lambda (iL)                                                        
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,faux,resaux)                                                   
        fstar(iY) = resaux                                                                          
      END DO                                                                                        
      DO iG = 1, nG                                                                                 
        DO iY = 1, nY                                                                               
c         first approximation for temperature                                                       
          IF(iY.eq.1 .AND. typEntry(1).eq.1) THEN                                                   
c           in this case Td(1,1)=Tsub(1) is given in input                                          
c           initialize the first value of the Td-array                                              
            Td(1,1) = Tsub(1)                                                                       
c           find corresponding Tei                                                                  
            Tei = Tsub(1)*4.0D+00**0.25D+00                                                                  
c         end if for iY=1                                                                           
          END IF                                                                                    
c         initial Td-profile                                                                        
          IF(Left.eq.1.AND.Right.eq.1) THEN                                                         
            Td(iG,iY) =((0.25D+00*Tei**4.0D+00+Teo**4.0D+00)**0.25D+00)                                            
     &                  / dsqrt(Y(iY))                                                              
          ELSE IF(Left.eq.1.AND.Right.eq.0) THEN                                                    
             Td(iG,iY) = Tei / (4.0D+00**0.25D+00) / dsqrt(Y(iY))                                           
          ELSE IF(Left.eq.0.AND.Right.eq.1) THEN                                                    
c             Td(iG,iY) =  Teo / dsqrt(Y(iY))                                                       
             Td(iG,iY) =  Teo * (Y(nY)/Y(iY))**0.5D+00                                                  
          END IF                                                                                    
          RHS(iY) = 1.0D+00                                                                             
c       end do over iY                                                                              
        END DO                                                                                      
c       The approximation for initial Td-profile below is not applicable                            
c       in case of external illumination:                                                           
        IF (Right.gt.0) GOTO 999                                                                   
c       generate the extinction cross-section Sigext                                                
        DO iL = 1, nL                                                                               
          Sigext(iL) = SigmaA(iG,iL)+SigmaS(iG,iL)                                                  
        END DO                                                                                      
c       Lambda integral of Sigext*fs -> Qfstar in IE97                                              
        DO iY = 1, nY                                                                               
c         generate auxiliary function for lambda integration:                                       
          DO iL = 1, nL                                                                             
            faux(iL) = Sigext(iL) * fs(iL,iY) / lambda (iL)                                         
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,faux,resaux)                                                 
          Qfstar(iY) = resaux                                                                       
        END DO                                                                                      
c       iterate until Td and Psi converge (i.e. until alpha does)                                   
        istop = 0                                                                                   
        it = 0                                                                                      
        DO WHILE (istop.NE.1)                                                                       
          istop = 1                                                                                 
          it = it +1                                                                                
c         find Planck average of Sigext and calculate QF (eq. B5)                                   
          DO iY = 1, nY                                                                             
c           generate auxiliary function for lambda integration:                                     
            DO iL = 1, nL                                                                           
              xP = 14400.0D+00 / Td(iG,iY) / lambda(iL)                                                 
              faux(iL) = Sigext(iL) * Planck(xP) / lambda (iL)                                      
            END DO                                                                                  
            CALL Simpson(npL,1,nL,lambda,faux,resaux)                                               
c           Planck average of Sigext                                                                
            QP(iY) = resaux                                                                         
c           calculate intetgral next to 1/y2 in eq. B7 -> fstarQ                                    
            DO iL = 1, nL                                                                           
              faux(iL)=fs(iL,iY)*
     &                   (1.0D+00-SigmaA(iG,iL)/QP(iY))/lambda(iL)                             
            END DO                                                                                  
            CALL Simpson(npL,1,nL,lambda,faux,resaux)                                               
            fstarQ(iY) = resaux                                                                     
c           calculate QF (eq. B5)                                                                   
            QF(iY) = Qfstar(iY) + QP(iY) * (1.0D+00-fstar(iY))                                          
c           store current value (this used to be alpha -MN,Apr'00)                                  
            oldRHS(iY) = RHS(iY)                                                                    
          END DO                                                                                    
c         for each y calculate new alpha from eq. B7                                                
c         two y loops are needed because of integral QF*ETA                                         
          DO iY = 1, nY                                                                             
c           first evaluate integral of QF with ETA...                                               
            DO iW = iY, nY                                                                          
              aux(iW) = QF(iW) * ETA(Y(iW)) / Y(iW)**2.0D+00                                            
            END DO                                                                                  
            CALL Simpson(npY,iY,nY,Y,aux,EtaQF)                                                     
c           ... then the whole expression                                                           
            RHS(iY) = 3.0D+00*TAUfid*EtaQF + (1.0D+00-fstarQ(iY))                                              
c           calculate temperature                                                                   
            Td(iG,iY) = Tei * (RHS(iY)/4.0D+00)**0.25D+00                                                    
            Td(iG,iY) = Td(iG,iY) / dsqrt(Y(iY))                                                    
            delta = DABS((RHS(iY)-oldRHS(iY))/RHS(iY))                                              
            IF (delta.GT.accConv) istop = 0                                                         
          END DO                                                                                    
          IF(it.GE.500) THEN                                                                        
            IF(iX.GT.0) THEN                                                                        
             write(18,*) ' Could not converge on initial T-profile  '                               
             write(18,*) ' in 500 iter. Check if the solution is OK.'                               
            END IF                                                                                  
             istop = 1                                                                              
          END IF                                                                                    
c       end of iterations                                                                           
        END DO                                                                                      
        IF(iInn.GT.0.AND.iX.GT.0)                                                                   
     &        write(18,'(i4,a19)')it,' it. for initial Td'                                          
c     end of loop over grains (iG)                                                                  
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE INSERT(pstar,iP,iPstar)                                                            
c =======================================================================                           
c This subroutine inserts two rays if the stellar disk is finite. The                               
c first ray, corresponding to the disk edge, has index iPstar, and the                              
c following ray with 1.0001 greater impact parameter has index iPstar+1.                            
c The only exception is if pstar>0.9999 when only a single ray is                                   
c inserted.                                            [Z.I., Feb. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iP, iPstar                                                                            
      DOUBLE PRECISION pstar                                                                        
c -----------------------------------------------------------------------                           
      IF (pstar.GE.0.999999D+00) THEN                                                                   
        pstar = 0.999999D+00                                                                            
        iP = nPcav + 1                                                                              
        iPstar = nPcav + 1                                                                          
        P(iP) = pstar                                                                               
        ELSE                                                                                        
        IF (pstar.GE.P(nPcav)) THEN                                                                 
          IF (pstar.EQ.P(nPcav)) pstar = 1.00001D+00*P(nPcav)                                           
          P(nPcav+1) = pstar                                                                        
          iPstar = nPcav + 1                                                                        
          P(nPcav+2) = 1.00001D+00*pstar                                                                
          iP = nPcav + 2                                                                            
        ELSE                                                                                        
          iPstar = 0                                                                                
          iP = 0                                                                                    
          DO WHILE (iPstar.EQ.0)                                                                    
            iP = iP + 1                                                                             
            IF (P(iP).GT.pstar.AND.iPstar.EQ.0) iPstar = iP                                         
          END DO                                                                                    
          DO iP = 1, nPcav-iPstar+1                                                                 
            P(nPcav+3-iP) = P(nPcav+1-iP)                                                           
          END DO                                                                                    
          IF (pstar.EQ.P(iPstar-1)) pstar = 1.00001D+00*P(iPstar-1)                                     
          P(iPstar) = pstar                                                                         
          P(iPstar+1) = 1.00001D+00*pstar                                                               
          iP = nPcav + 1                                                                            
        END IF                                                                                      
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE IntegExtOLD(ETAzp,nZ,m0,m1,m1p,m1m)                                                   
c =======================================================================                           
c  This subroutine finds the diffuse external radiation.                                            
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iP, iL, nZ(npP), iZ, iY, iPstar, error                                                
      DOUBLE PRECISION ETAzp(npP,npY), TAUaux(npL,npP,npY), m0(npL,npY),                            
     &       m1(npL,npY), Tplus(npP,npY), Tminus(npP,npY), yN1(npP),                                
     &       yN2(npP), yN2p(npP), yN2m(npP), m1p(npL,npY), m1m(npL,npY),                            
     &       mu(npP), pstar, result1, result2, pp, zz, tau, tauT, Ztot                              
c -----------------------------------------------------------------------                           
      pstar = 0.0D+00                                                                                   
      iPstar = 1                                                                                    
      error = 0                                                                                     
      DO iP = 1, nP                                                                                 
c       upper limit for the counter of z position                                                   
        nZ(iP) = nY + 1 - iYfirst(iP)                                                               
      END DO                                                                                        
                                                                                                    
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
        DO iP = 1, nP                                                                               
          DO iZ = 1, nZ(iP)                                                                         
            TAUaux(iL,iP,iZ) = ETAzp(iP,iZ)*TAUtot(iL)                                              
          END DO                                                                                    
        END DO                                                                                      
c       loop over radius                                                                            
       DO iY = 1, nY                                                                                
        iZ = iY                                                                                     
c       at ea. radius find the optical depth along rays at given mu                                 
        DO iP = 1, Plast(iY)                                                                        
          mu(iP) = dsqrt(1.0D+00 - (P(iP)/Y(iY))**2.0D+00)                                                    
c         pp = Y(iY)*sqrt(1.0D+00-mu(iP)**2.0D+00) or, equivalently                                           
          pp = P(iP)                                                                                
          zz = Y(iY)*mu(iP)                                                                         
          Ztot = sqrt(Y(nY)*Y(nY) - pp*pp)                                                          
c         this is tau along a ray from midpoint to Ztot                                             
          tauT = TAUaux(iL,iP,nZ(iP))                                                               
c         TAUaux(iL,iP,iY) is tau along a ray from midpoint to point zz                             
          IF(pp.LE.1.0D+00) THEN                                                                         
c           for rays crossing the cavity                                                            
            tau = TAUaux(iL,iP,iY)                                                                  
          ELSE                                                                                      
c           for rays outside cavity find the proper position index                                  
            iZ = iY - (nZ(1)-nZ(iP))                                                                
            tau = TAUaux(iL,iP,iZ)                                                                  
          END IF                                                                                    
c         to avoid exp over/underflow:                                                              
          IF((tauT-tau).LT.1.0D-10) THEN                                                            
            Tminus(iP,iY) = 1.0D+00                                                                      
          ELSE                                                                                      
            Tminus(iP,iY) = dexp(-tauT+tau)                                                         
          END IF                                                                                    
          IF((tauT+tau).GT.50.0D+00) THEN                                                                
            Tplus(iP,iY) = 0.0D+00                                                                       
          ELSE                                                                                      
            Tplus(iP,iY) = dexp(-tauT-tau)                                                          
          END IF                                                                                    
          yN1(iP) = Tplus(iP,iY)+Tminus(iP,iY)                                                      
          yN2(iP) = Tplus(iP,iY)-Tminus(iP,iY)                                                      
          yN2p(iP) = Tplus(iP,iY)                                                                   
          yN2m(iP) = Tminus(iP,iY)                                                                  
                                                                                                    
c       end do over iP (i.e. over mu)                                                               
        END DO                                                                                      
c       find the 0-th moment                                                                        
        CALL NORDLUND(1,mu,yN1,1,Plast(iY),0,result1,error)                                         
c       find the 1-st moment                                                                        
        CALL NORDLUND(1,mu,yN2,1,Plast(iY),1,result2,error)                                         
        m0(iL,iY) = 0.5D+00*result1                                                                     
        m1(iL,iY) = 0.5D+00*result2                                                                     
c       find the p and m components of the external flux	                                           
        CALL NORDLUND(1,mu,yN2p,1,Plast(iY),1,result2,error)                                        
        m1p(iL,iY) = 0.5D+00*result2                                                                    
        CALL NORDLUND(1,mu,yN2m,1,Plast(iY),1,result2,error)                                        
        m1m(iL,iY) = 0.5D+00*result2                                                                    
c      end do over y                                                                                
       END DO                                                                                       
c     =============================                                                                 
c     end of loop over wavelengths                                                                  
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION IntETA(p,iW1,w1,w)                                                  
c =======================================================================                           
c This function calculates the integral over the normalized dens. prof.                             
c along the line of sight with impact parameter p and between the points                            
c corresponding to y=w1 and y=w. The method used is spline approximation                            
c for normalized density distribution ETA and subsequent integration                                
c performed analytically by MAPLE (these results are given through                                  
c soubroutine Maple3).                         [ZI,Feb'96,MN,Aug'97]                                
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER iW1, iC                                                                               
      DOUBLE PRECISION  p, w1, w, aux(4), z, z1, aux1(4)                                            
c -----------------------------------------------------------------------                           
      z = dsqrt(w*w-p*p)                                                                            
      z1 = dsqrt(w1*w1-p*p)                                                                         
c     integrals calculated by MAPLE                                                                 
      CALL Maple3(w,z,p,aux)                                                                        
      CALL Maple3(w1,z1,p,aux1)                                                                     
      DO iC = 1, 4                                                                                  
        aux(iC) = aux(iC) - aux1(iC)                                                                
      END DO                                                                                        
      IntETA = 0.0D+00                                                                                  
      DO iC = 1, 4                                                                                  
        IntETA = IntETA + ETAcoef(iW1,iC) * aux(iC)                                                 
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE INVERT(nY,nL,mat,Us,Em,omega,Utot,Uold,error)                                      
c =======================================================================                           
c This subroutine solves the linear system                                                          
c [Utot] = [Us+Em] + [mat0]*[omega*Utot] by calling LINSYS subroutine.                              
c                                                      [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER nY, iL,nL,iY, iYaux, Kronecker, error                                                 
      DOUBLE PRECISION mat(npL,npY,npY), Us(npL,npY), Em(npL,npY),                                  
     &       Utot(npL,npY), Uold(npL,npY),B(npY), A(npY,npY), X(npY),                               
     &       omega(npL,npY)                                                                         
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
c     first copy Utot to Uold                                                                       
      DO iL = 1, nL                                                                                 
        DO iY = 1, nY                                                                               
          Uold(iL,iY) = Utot(iL,iY)                                                                 
        END DO                                                                                      
      END DO                                                                                        
c     calculate new energy density                                                                  
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       generate the vector of free coefficients, B, and matrix A                                   
        DO iY = 1, nY                                                                               
          B(iY) = Us(iL,iY)                                                                         
          DO iYaux = 1, nY                                                                          
            Kronecker = 0                                                                           
            IF (iY.EQ.iYaux) Kronecker = 1                                                          
            B(iY) = B(iY) +                                                                         
     &           (1.0D+00-omega(iL,iYaux))*Em(iL,iYaux)*mat(iL,iY,iYaux)                            
            A(iY,iYaux) = Kronecker - omega(iL,iYaux) * mat(iL,iY,iYaux)                            
          END DO                                                                                    
        END DO                                                                                      
                                                                                                    
c       solve the system                                                                            
        CALL LINSYS(nY,A,B,X,error)                                                                 
        IF(error.NE.0) THEN                                                                         
         CALL MSG(20)                                                                               
         iERROR = iERROR + 1                                                                        
         RETURN                                                                                     
        END IF                                                                                      
c       store the result                                                                            
        DO iY = 1, nY                                                                               
          IF (X(iY).GE.dynrange*dynrange) THEN                                                      
            Utot(iL,iY) = X(iY)                                                                     
          ELSE                                                                                      
            Utot(iL,iY) = 0.0D+00                                                                       
          END IF                                                                                    
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Kint4(TAUaux,iP,iL,nZ,K1p,K2p,K3p,K4p,K1m,K2m,K3m,K4m)                             
c =======================================================================                           
c For given wavelength (iL) and impact parameter (iP), this subroutine                              
c calculates integrals Knp and Knm defined as:                                                      
c               Knp(iZ)=INT[PHIn(tz)*exp(tz)*dtz]                                                   
c from tz1=TAUaux(iL,iP,iZ) to tz2=TAUaux(iL,iP,iZ+1) and analogously for                           
c Km with exp(tz) replaced by exp(-tz). Function PHIn is defined as                                 
c x**(n-1)/Yloc^2, where Yloc is the local radius corresponding to tz,                              
c and x measures relative radial tau: x = (rt - tL)/(tR-tL). Here rt is                             
c the radial optical depth corresponding to tz and tL and tR are radial                             
c optical depths at the boundaries of the integration interval:                                     
c tL = TAUaux(iL,1,iZ) = rt(iZ) and tR = TAUaux(iL,1,iZ+1) = rt(iZ+1).                              
c Integration is performed in z space by Romberg integration implemented                            
c in subroutine ROMBERG2 (slightly changed version of 'qromb' from Num.                             
c Recipes).                                     [ZI,Feb'96;MN,Sep'97]                               
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER iP, iL, nZ, iZ, iW1, iLaux, iC                                                        
      DOUBLE PRECISION TAUaux(npL,npP,npY), K1p(npY),K2p(npY),K3p(npY),                             
     &    K4p(npY), K1m(npY), K2m(npY), K3m(npY), K4m(npY), Rresult(8),                             
     &    Kaux(8), deltrton(4),tRL,paux, w1,w2,wL, delTAUzp, z1, z2                                 
      COMMON /phi2/ paux, w1, wL, delTAUzp, iLaux, iW1                                              
c -----------------------------------------------------------------------                           
      paux = P(iP)                                                                                  
      iLaux = iL                                                                                    
c     iLaux is needed to avoid compiler errors since it is in COMMON                                
c     /phi2/ (here and in 'TWOfun'), while iL is transferred as a                                   
c     argument loop over positions on the line of sight                                             
      DO iZ = 1, nZ-1                                                                               
c       index for the local radial position (left boundary)                                         
        iW1 = iYfirst(iP) + iZ - 1                                                                  
c       radii at the boundaries                                                                     
        wL = Y(iW1)                                                                                 
        IF (iZ.EQ.1) THEN                                                                           
          if (paux.GT.1.0D+00) then                                                                     
            w1 = paux                                                                               
            else                                                                                    
            w1 = 1.0D+00                                                                                
          end if                                                                                    
          ELSE                                                                                      
          w1 = Y(iW1)                                                                               
        END IF                                                                                      
        w2 = Y(iW1+1)                                                                               
        z1 = dsqrt(DABS(w1*w1 - paux*paux))                                                         
        z2 = dsqrt(w2*w2 - paux*paux)                                                               
c       radial tau-difference at the bound., scaled to tot. opt. depth                              
        tRL = TAUaux(iL,1,iW1+1)-TAUaux(iL,1,iW1)                                                   
c       auxiliary quantity aux/tRL**(n-1)                                                           
        deltrton(1) = TAUtot(iL)                                                                    
        DO iC = 1, 3                                                                                
          deltrton(iC+1) = deltrton(iC)/tRL                                                         
        END DO                                                                                      
c       delTAUzp is needed in PHIn fun's                                                            
        delTAUzp = TAUaux(iL,iP,iZ+1)-TAUaux(iL,iP,iZ)                                              
c       integrate this step for all 8 cases                                                         
        CALL ROMBERG2(z1,z2,Rresult)                                                                
c       generate output values                                                                      
        DO iC = 1, 4                                                                                
           Kaux(iC) = Rresult(iC) * deltrton(iC)                                                    
           Kaux(iC+4) = Rresult(iC+4) * deltrton(iC)                                                
        END DO                                                                                      
        K1m(iZ) = Kaux(1)                                                                           
        K2m(iZ) = Kaux(2)                                                                           
        K3m(iZ) = Kaux(3)                                                                           
        K4m(iZ) = Kaux(4)                                                                           
        K1p(iZ+1) = Kaux(5)                                                                         
        K2p(iZ+1) = Kaux(6)                                                                         
        K3p(iZ+1) = Kaux(7)                                                                         
        K4p(iZ+1) = Kaux(8)                                                                         
      END DO                                                                                        
c     set undefined elements to 0                                                                   
      K1m(nZ) = 0.0D+00                                                                                 
      K2m(nZ) = 0.0D+00                                                                                 
      K3m(nZ) = 0.0D+00                                                                                 
      K4m(nZ) = 0.0D+00                                                                                 
      K1p(1) = 0.0D+00                                                                                  
      K2p(1) = 0.0D+00                                                                                  
      K3p(1) = 0.0D+00                                                                                  
      K4p(1) = 0.0D+00                                                                                  
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE matrix(ETAzp,pstar,iPstar,m0,m1,mifront,miback)                                    
c =======================================================================                           
c This subroutine evaluates radiative transfer matrix for spherically                               
c symmetric envelope. Here m is the order of moment (0 for energy dens.,                            
c 1 for flux, 2 for pressure etc.), ETAzp is array of optical depths                                
c along the line of sight and mat is radiative transfer matrix.                                     
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER m                                                                                     
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iP, iL, nZ(npP), iZ, iW,  iY, flag, im, iPstar, jZ, error                             
      DOUBLE PRECISION ETAzp(npP,npY),TAUaux(npL,npP,npY), haux(npP),H,                             
     &       m0(npL,npY,npY), m1(npL,npY,npY), pstar, addplus,addminus,                             
     &       Tplus(npP,npY,npY),Tminus(npP,npY,npY), xN(npP), yN(npP),                              
     &       result1,result2,resaux,TAUr(npY), wm(npY),wmT(npY),wp(npY),                            
     &       alpha(npY,npY),beta(npY,npY),gamma(npY,npY),delta(npY,npY),                            
     &       wgmatp(npY,npY), wgmatm(npY,npY), mifront(npL,npP,npY),                                
     &       miback(npL,npP,npY), fact, faux                                                        
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
c     generate auxiliary arrays haux & nZ                                                           
      DO iP = 1, nP                                                                                 
c       parameter alowing for a line of sight terminating on the star                               
c       H(x1,x2) is the step function.                                                              
        haux(iP) = H(P(iP),pstar)                                                                   
c       upper limit for the counter of z position                                                   
        nZ(iP) = nY + 1 - iYfirst(iP)                                                               
      END DO                                                                                        
c     Using the local array TAUaux to avoid multiple calculations of the                            
c     product                                                                                       
      DO iL = 1, nL                                                                                 
       DO iP = 1, nP                                                                                
        DO iY = 1, nY                                                                               
           TAUaux(iL,iP,iY) = ETAzp(iP,iY)*TAUtot(iL)                                               
        END DO                                                                                      
       END DO                                                                                       
      END DO                                                                                        
c     -- evaluate matrix elements --                                                                
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       radial optical depths                                                                       
        DO iY = 1, nY                                                                               
          TAUr(iY) = ETAzp(1,iY)*TAUtot(iL)                                                         
        END DO                                                                                      
c       auxiliary arrays for given TAUr                                                             
        CALL MYSPLINE(TAUr,nY,alpha,beta,gamma,delta)                                               
c       loop over impact parameters                                                                 
        DO iP = 1, nP-1                                                                             
c         set T-s to 0                                                                              
          DO iY = 1, nY                                                                             
            DO iW = 1, nY                                                                           
              Tplus(iP,iY,iW) = 0.0D+00                                                                 
              Tminus(iP,iY,iW) = 0.0D+00                                                                
            END DO                                                                                  
          END DO                                                                                    
c         generate weights matrices                                                                 
          CALL WEIGHTS(TAUaux,iP,iL,nZ(iP),nY,alpha,beta,gamma,delta,                               
     &                 wgmatp,wgmatm)                                                               
c         first position on the line of sight                                                       
          IF (YPequal(iP).EQ.1) THEN                                                                
            iY = iYfirst(iP)                                                                        
            DO iW = 1, nY                                                                           
c             cummulative weights for parts II & III                                                
              wmT(iW) = 0.0D+00                                                                         
              DO jZ = 1, nZ(iP)-1                                                                   
                fact = dexp(-TAUaux(iL,iP,jZ))                                                      
                wmT(iW) = wmT(iW) + fact * wgmatm(jZ,iW)                                            
              END DO                                                                                
              Tplus(iP,iY,iW) = Tplus(iP,iY,iW) + haux(iP)*wmT(iW)                                  
              Tminus(iP,iY,iW) = Tminus(iP,iY,iW) + wmT(iW)                                         
            END DO                                                                                  
          END IF                                                                                    
c         loop over positions on the line of sight                                                  
          DO iZ = 2, nZ(iP)                                                                         
c           increase index for radial position                                                      
            iY = iYfirst(iP) + iZ - 1                                                               
c           generate weights for this position                                                      
            DO iW = 1, nY                                                                           
              wp(iW) = 0.0D+00                                                                          
              wm(iW) = 0.0D+00                                                                          
              wmT(iW) = 0.0D+00                                                                         
c             part I                                                                                
              DO jZ = 2, iZ                                                                         
                fact = dexp(TAUaux(iL,iP,jZ)-TAUaux(iL,iP,iZ))                                      
                wp(iW) = wp(iW) + fact * wgmatp(jZ,iW)                                              
              END DO                                                                                
c             part II & III                                                                         
              DO jZ = 1, nZ(iP)-1                                                                   
                fact = dexp(-(TAUaux(iL,iP,iZ)+TAUaux(iL,iP,jZ)))                                   
                wmT(iW) = wmT(iW) + fact * wgmatm(jZ,iW)                                            
              END DO                                                                                
c             part IV                                                                               
              IF (iZ.LT.nZ(iP)) THEN                                                                
                DO jZ = iZ, nZ(iP)-1                                                                
                  fact = dexp(-(TAUaux(iL,iP,jZ)-TAUaux(iL,iP,iZ)))                                 
                  wm(iW) = wm(iW) + fact * wgmatm(jZ,iW)                                            
                END DO                                                                              
              ELSE                                                                                  
                wm(iW) = 0.0D+00                                                                        
              END IF                                                                                
c             add contribution from this step                                                       
              addplus = wp(iW) + haux(iP)*wmT(iW)                                                   
              Tplus(iP,iY,iW) = Tplus(iP,iY,iW) + addplus                                           
              addminus = wm(iW)                                                                     
              Tminus(iP,iY,iW) = Tminus(iP,iY,iW) + addminus                                        
            END DO                                                                                  
c         end of loop over iZ                                                                       
          END DO                                                                                    
c       end of the impact parameter loop, iP                                                        
        END DO                                                                                      
c       add points on the edge                                                                      
        DO iW = 1, nY                                                                               
          Tplus(nP,nY,iW) = 0.0D+00                                                                     
          Tminus(nP,nY,iW) = 0.0D+00
        END DO                                                                                      
c     ============================                                                                  
c       find mat(iL,iY,iW) -> angular (mu) integration                                              
c       loop over moments (without calculation of rad.pressure)                                     
        DO im = 1, 2                                                                                
          m = im - 1                                                                                
c         loop over radial positions                                                                
          DO iY = 1, nY                                                                             
c           generate mu arrray                                                                      
            DO iP = 1, Plast(iY)                                                                    
              xN(iP) = sqrt(1.0D+00-(P(iP)/Y(iY)*P(iP)/Y(iY)))                                          
            END DO                                                                                  
c           loop over local (radial) positions                                                      
            DO iW = 1, nY                                                                           
c             generate intensity array for NORDLUND                                                 
              DO iP = 1, Plast(iY)                                                                  
c               'faux' is a representation of (-1)**m                                               
                 faux = 1.0D+00 - 2.0D+00*MOD(m,2)                                                          
                 yN(iP) = Tplus(iP,iY,iW) + faux*Tminus(iP,iY,iW)                                   
c               store matrix elements to evaluate intensity (*1/4Pi)                                
                IF (im.EQ.1.AND.iY.EQ.nY) THEN                                                      
                  mifront(iL,iP,iW) = 0.0795775D+00 * Tplus(iP,iY,iW)                                   
                  miback(iL,iP,iW) = 0.0795775D+00 * Tminus(iP,iY,iW)                                   
                END IF                                                                              
              END DO                                                                                
c             angular integration inside cavity                                                     
              IF (pstar.GT.0.0D+00) THEN                                                                
                CALL NORDLUND(0,xN,yN,1,iPstar,m,resaux,error)                                      
                IF (error.NE.0) GOTO 999                                                            
                IF (nPcav.GT.iPstar)                                                                
     &          CALL NORDLUND(0,xN,yN,iPstar+1,nPcav+1,m,result1,error)                             
                IF (error.NE.0) GOTO 999                                                            
                result1 = result1 + resaux                                                          
              ELSE                                                                                  
                CALL NORDLUND(0,xN,yN,1,nPcav+1,m,result1,error)                                    
                IF (error.NE.0) GOTO 999                                                            
              END IF                                                                                
c             flag for analytic integration outside cavity                                          
              IF (iY.GT.6) THEN                                                                     
                flag = 1                                                                            
              ELSE                                                                                  
                flag = 0                                                                            
              ENDIF                                                                                 
c             angular integration outside cavity                                                    
              IF (iY.GT.1) THEN                                                                     
                CALL NORDLUND(flag,xN,yN,nPcav+1,Plast(iY),                                         
     &                                      m,result2,error)                                        
                IF (error.NE.0) GOTO 999                                                            
              ELSE                                                                                  
                result2 = 0.0D+00                                                                       
              END IF                                                                                
c             store current matrix element                                                          
              IF (m.EQ.0)                                                                           
     &        m0(iL,iY,iW) = 0.5D+00*Y(iY)*Y(iY)*(result1 + result2)                                    
              IF (m.EQ.1) THEN                                                                      
              m1(iL,iY,iW) = 0.5D+00*Y(iY)*Y(iY)*(result1 + result2)                                    
              END IF                                                                                
            END DO                                                                                  
          END DO                                                                                    
        END DO                                                                                      
c     =============================                                                                 
c     end of loop over wavelengths                                                                  
      END DO                                                                                        
c     save Y and P grids to Yok and Pok, they are needed for analysis                               
c     in cases when requirement for finer grids cannot be satisfied and                             
c     previous solution is used for output                                                          
      nYok = nY                                                                                     
      DO iY = 1, nY                                                                                 
        Yok(iY) = Y(iY)                                                                             
      END DO                                                                                        
      nPok = nP                                                                                     
      DO iP = 1, nP                                                                                 
        Pok(iP) = P(iP)                                                                             
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE matrixD(ETAzp,pstar,iPstar,m0,m1,mD,mifront,miback)                                
c =======================================================================                           
c This subroutine evaluates the radiative transfer matrix m# for spherically                        
c symmetric envelope. Here # is the order of moment (0 for energy dens.,                            
c 1 for flux; 3 for the matrix mD when added disk), ETAzp is array of                               
c optical depths along the line of sight.                                                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER m                                                                                     
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                                     
       COMMON /constants/ Pi, sigma, Gconst, r_gd                                                              
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iP, iL, nZ(npP), iZ, iW,  iY, flag, im, iPstar, jZ, error                             
      DOUBLE PRECISION ETAzp(npP,npY),TAUaux(npL,npP,npY), haux(npP),H,                             
     &       m0(npL,npY,npY), m1(npL,npY,npY), pstar, addplus,addminus,                             
     &       Tplus(npP,npY,npY),Tminus(npP,npY,npY), xN(npP),yN(npP),                               
     &       result1,result2,resaux,TAUr(npY), wm(npY),wmT(npY),wp(npY),                            
     &       alpha(npY,npY),beta(npY,npY),gamma(npY,npY),delta(npY,npY),                            
     &       wgmatp(npY,npY), wgmatm(npY,npY), mifront(npL,npP,npY),                                
     &       miback(npL,npP,npY), mD(npL,npY,npY), fact, faux                                       
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
c     generate auxiliary arrays haux & nZ                                                           
      DO iP = 1, nP                                                                                 
c       parameter alowing for a line of sight terminating on the star                               
c       H(x1,x2) is the step function.                                                              
        haux(iP) = H(P(iP),pstar)                                                                   
c       upper limit for the counter of z position                                                   
        nZ(iP) = nY + 1 - iYfirst(iP)                                                               
      END DO                                                                                        
c     Using the local array TAUaux to avoid multiple calculations of the                            
c     product                                                                                       
      DO iL = 1, nL                                                                                 
       DO iP = 1, nP                                                                                
        DO iY = 1, nY                                                                               
           TAUaux(iL,iP,iY) = ETAzp(iP,iY)*TAUtot(iL)                                               
        END DO                                                                                      
       END DO                                                                                       
      END DO                                                                                        
c     -- evaluate matrix elements --                                                                
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       radial optical depths                                                                       
        DO iY = 1, nY                                                                               
          TAUr(iY) = ETAzp(1,iY)*TAUtot(iL)                                                         
        END DO                                                                                      
c       auxiliary arrays for given TAUr                                                             
        CALL MYSPLINE(TAUr,nY,alpha,beta,gamma,delta)                                               
c       loop over impact parameters                                                                 
        DO iP = 1, nP-1                                                                             
c         set T-s to 0                                                                              
          DO iY = 1, nY                                                                             
            DO iW = 1, nY                                                                           
              Tplus(iP,iY,iW) = 0.0D+00                                                                 
              Tminus(iP,iY,iW) = 0.0D+00                                                                
            END DO                                                                                  
          END DO                                                                                    
c         generate weights matrices                                                                 
          CALL WEIGHTS(TAUaux,iP,iL,nZ(iP),nY,alpha,beta,gamma,delta,                               
     &                 wgmatp,wgmatm)                                                               
c         first position on the line of sight                                                       
          IF (YPequal(iP).EQ.1) THEN                                                                
            iY = iYfirst(iP)                                                                        
            DO iW = 1, nY                                                                           
c             cummulative weights for parts II & III                                                
              wmT(iW) = 0.0D+00                                                                         
              DO jZ = 1, nZ(iP)-1                                                                   
                fact = dexp(-TAUaux(iL,iP,jZ))                                                      
                wmT(iW) = wmT(iW) + fact * wgmatm(jZ,iW)                                            
              END DO                                                                                
              Tplus(iP,iY,iW) = Tplus(iP,iY,iW) + haux(iP)*wmT(iW)                                  
              Tminus(iP,iY,iW) = Tminus(iP,iY,iW) + wmT(iW)                                         
            END DO                                                                                  
          END IF                                                                                    
c         loop over positions on the line of sight                                                  
          DO iZ = 2, nZ(iP)                                                                         
c           increase index for radial position                                                      
            iY = iYfirst(iP) + iZ - 1                                                               
c           generate weights for this position                                                      
            DO iW = 1, nY                                                                           
              wp(iW) = 0.0D+00                                                                          
              wm(iW) = 0.0D+00                                                                          
              wmT(iW) = 0.0D+00                                                                         
c             part I                                                                                
              DO jZ = 2, iZ                                                                         
                fact = dexp(TAUaux(iL,iP,jZ)-TAUaux(iL,iP,iZ))                                      
                wp(iW) = wp(iW) + fact * wgmatp(jZ,iW)                                              
              END DO                                                                                
c             part II & III                                                                         
              DO jZ = 1, nZ(iP)-1                                                                   
                fact = dexp(-(TAUaux(iL,iP,iZ)+TAUaux(iL,iP,jZ)))                                   
                wmT(iW) = wmT(iW) + fact * wgmatm(jZ,iW)                                            
              END DO                                                                                
c             part IV                                                                               
              IF (iZ.LT.nZ(iP)) THEN                                                                
                DO jZ = iZ, nZ(iP)-1                                                                
                  fact = dexp(-(TAUaux(iL,iP,jZ)-TAUaux(iL,iP,iZ)))                                 
                  wm(iW) = wm(iW) + fact * wgmatm(jZ,iW)                                            
                END DO                                                                              
              ELSE                                                                                  
                wm(iW) = 0.0D+00                                                                        
              END IF                                                                                
c             add contribution from this step                                                       
              addplus = wp(iW) + haux(iP)*wmT(iW)                                                   
              Tplus(iP,iY,iW) = Tplus(iP,iY,iW) + addplus                                           
              addminus = wm(iW)                                                                     
              Tminus(iP,iY,iW) = Tminus(iP,iY,iW) + addminus                                        
            END DO                                                                                  
c         end of loop over iZ                                                                       
          END DO                                                                                    
c       end of the impact parameter loop, iP                                                        
        END DO                                                                                      
c       add points on the edge                                                                      
        DO iW = 1, nY                                                                               
          Tplus(nP,nY,iW) = 0.0D+00                                                                     
          Tminus(nP,nY,iW) = 0.0D+00                                                                    
        END DO                                                                                      
c     ============================                                                                  
c       find mat(iL,iY,iW) -> angular (mu) integration                                              
c       loop over moments (without calculation of rad.pressure)                                     
        DO im = 1, 3                                                                                
          m = im - 1                                                                                
c         loop over radial positions                                                                
          DO iY = 1, nY                                                                             
c           generate mu arrray                                                                      
            DO iP = 1, Plast(iY)                                                                    
              xN(iP) = dsqrt(1.0D+00-(P(iP)/Y(iY)*P(iP)/Y(iY)))                                         
            END DO                                                                                  
c           loop over local (radial) positions                                                      
            DO iW = 1, nY                                                                           
c             generate intensity array for NORDLUND                                                 
              DO iP = 1, Plast(iY)                                                                  
c               'faux' is a representation of (-1)**m                                               
                faux = 1.0D+00 - 2.0D+00*MOD(m,2)                                                           
                yN(iP) = Tplus(iP,iY,iW) + faux*Tminus(iP,iY,iW)                                    
c               store matrix elements to evaluate intensity at y = 1                                
c               (at y = 1 they should be equal)                                                     
                IF (im.EQ.1.AND.iY.EQ.1) THEN                                                       
                  mifront(iL,iP,iW) = Tplus(iP,iY,iW)                                               
                  miback(iL,iP,iW) = Tminus(iP,iY,iW)                                               
                END IF                                                                              
c               special case for im=3: disk calculation                                             
c               instead of 2*Pi * int_{-1}^{1} I(mu) * mu^m * dmu                                   
c               we need 2 * int_{-1}^{1} I(mu) * sqrt(1-mu^2) * dmu                                 
c               thus we need to redefine yN for im = 3, and set m=0                                 
c               so that NORDLUND will not change anything                                           
                IF (im.EQ.3) THEN                                                                   
                   yN(iP) = yN(iP) * sqrt(1-xN(iP)*xN(iP)) / Pi
                   m = 0                                                                            
                END IF                                                                              
              END DO                                                                                
c             angular integration inside cavity                                                     
              IF (pstar.GT.0.0D+00.OR.im.EQ.3) THEN                                                     
                CALL NORDLUND(0,xN,yN,1,iPstar,m,resaux,error)                                      
                IF (nPcav.GT.iPstar)                                                                
     &          CALL NORDLUND(0,xN,yN,iPstar+1,nPcav+1,m,result1,error)                             
                result1 = result1 + resaux                                                          
                ELSE                                                                                
                CALL NORDLUND(0,xN,yN,1,nPcav+1,m,result1,error)                                    
              END IF                                                                                
c             flag for analytic integration outside cavity                                          
              IF (iY.GT.6) THEN                                                                     
                flag = 1                                                                            
              ELSE                                                                                  
                flag = 0                                                                            
              ENDIF                                                                                 
c             angular integration outside cavity                                                    
              IF (iY.GT.1) THEN                                                                     
                CALL NORDLUND(flag,xN,yN,nPcav+1,Plast(iY),                                         
     &                                           m,result2,error)                                   
              ELSE                                                                                  
                result2 = 0.0D+00                                                                       
              END IF                                                                                
c             store current matrix element                                                          
              IF (im.EQ.1)                                                                          
     &        m0(iL,iY,iW) = 0.5D+00*Y(iY)*Y(iY)*(result1 + result2)                                    
              IF (im.EQ.2)                                                                          
     &        m1(iL,iY,iW) = 0.5D+00*Y(iY)*Y(iY)*(result1 + result2)                                    
              IF (im.EQ.3)                                                                          
     &        mD(iL,iY,iW) = 0.5D+00*Y(iY)*Y(iY)*(result1 + result2)                                    
            END DO                                                                                  
          END DO                                                                                    
        END DO                                                                                      
c     =============================                                                                 
c     end of loop over wavelengths                                                                  
      END DO                                                                                        
c     save Y and P grids to Yok and Pok, they are needed for analysis                               
c     in cases when requirement for finer grids cannot be satisfied and                             
c     previous solution is used for output                                                          
      nYok = nY                                                                                     
      DO iY = 1, nY                                                                                 
        Yok(iY) = Y(iY)                                                                             
      END DO                                                                                        
      nPok = nP                                                                                     
      DO iP = 1, nP                                                                                 
        Pok(iP) = P(iP)                                                                             
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE NORDLUND(flag,x,y,N1,N2,m,intydx,error)                                            
c =======================================================================                           
c This subroutine calculates integral I(x**m*y(x)*dx). Both y and x are                             
c 1D arrays, y(i), x(i) with i=1,npP (npP comes from 'paramet.inc'). Lower                          
c and upper integration limits are x(N1) and x(N2), respectively. The                               
c method used is approximation of y(x) by a piecewise cubic spline (see                             
c Nordlund: Spherical Transfer with SinglD-Ray Approximation, in                                    
c 'Methods in radiative transfer', ed. W. Kalkofen, Cambridge University                            
c Press, 1984). The resulting integral is sum of y(i)*w(i), i=N1,N2.                                
c Weights w(i) are determined from the array x(i). Here w(i) = wSimp(i)                             
c + wCorr(i). To improve accuracy of angular integration in radiative                               
c transfer, if flag=1 the contribution of the last Nanal (specified                                 
c below) points is calculated in subroutine ANALINT which fits a                                    
c function of the form: y = P(x) + d/sqrt(1-x*x), where P(x) is the                                 
c polynomial of order Nanal-1, to these points and evaluates integral                               
c analytically.                                        [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER i, flag, N1, N2, N2n, Nanal, m, first, error                                          
      DOUBLE PRECISION x(npP), y(npP), wSimp(npP), wCorr(npP), wC1, wC2,                            
     &        am, intydx, xaux(4), yaux(4), aux                                                     
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
c parameter 'first' selects choice for derivatives at boundary points.                              
c For first.EQ.0 derivatives are 0 and first*(y2-y1)/(x2-x1) otherwise.                             
c first=1 works much better for functions encountered here.                                         
      first = 1                                                                                     
c number of points for analytic integration                                                         
      Nanal = 4                                                                                     
c do not include points for analytic integration                                                    
      IF (flag.EQ.1.AND.N2.GT.N1+Nanal) THEN                                                        
        N2n = N2 - Nanal + 1                                                                        
      ELSE                                                                                          
        N2n = N2                                                                                    
      END IF                                                                                        
c set integral to 0 and accumulate result in the loop                                               
      intydx = 0.0                                                                                  
c generate weighting factors, w(i), and integrate in the same loop                                  
      DO i = N1, N2n                                                                                
c first usual Simpson factors (Nordlund, eq. III-14, first term)...                                 
        IF (i.NE.N1.AND.i.NE.N2n) THEN                                                              
          wSimp(i) = 0.5D+00 * (x(i+1)-x(i-1))                                                          
        ELSE                                                                                        
          IF (i.eq.N1) wSimp(i) = 0.5D+00 * (x(N1+1)-x(N1))                                             
          IF (i.eq.N2n) wSimp(i) = 0.5D+00 * (x(N2n)-x(N2n-1))                                          
        END IF                                                                                      
c ... and then correction term for cubic spline (Nordlund, eq. III-14,                              
c second term and eq. III-16) (wC1 and wC2 are auxiliary quantities)                                
        IF (i.GT.N1+1) THEN                                                                         
          wC1 = x(i) - 2.0D+00*x(i-1) + x(i-2)                                                          
        ELSE                                                                                        
          IF (i.EQ.N1) wC1 =  first * (x(N1+1) - x(N1))                                             
          IF (i.EQ.N1+1) wC1 = first * (x(N1) - x(N1+1))                                            
        ENDIF                                                                                       
        IF (i.LE.(N2n-2)) THEN                                                                      
          wC2 = x(i+2) - 2.0D+00*x(i+1) + x(i)                                                          
        ELSE                                                                                        
          IF (i.EQ.(N2n-1)) wC2 = first * (x(N2n-1) - x(N2n))                                       
          IF (i.EQ.N2n) wC2 = first * (x(N2n) - x(N2n-1))                                           
        ENDIF                                                                                       
        wCorr(i) = (wC1 - wC2) / 12.0D+00                                                                
c       add contribution to the integral                                                            
        IF (m.EQ.0) THEN                                                                            
          intydx = intydx + y(i) * (wSimp(i) + wCorr(i))                                            
         ELSE IF(m.EQ.1) THEN                                                                       
            intydx = intydx + x(i)*y(i)*(wSimp(i) + wCorr(i))                                       
         ELSE IF(m.EQ.2) THEN                                                                       
            intydx = intydx + x(i)*x(i)*y(i)*(wSimp(i) + wCorr(i))                                  
        END IF                                                                                      
      END DO                                                                                        
c     change the sign (x [i.e. mu] array is in descending order!!!)                                 
      intydx = -intydx                                                                              
c     if flag=1 use analytic approximation for the last Nanal points                                
      IF (flag.EQ.1.AND.N2n.GT.N1+Nanal) THEN                                                       
c       generate auxiliary arrays for ANALINT                                                       
        DO i=1,Nanal                                                                                
          xaux(i) = x(N2n+Nanal-i)                                                                  
          yaux(i) = y(N2n+Nanal-i)                                                                  
        END DO                                                                                      
c     calculate the contribution of the last Nanal points                                           
c       produce REAL copy of m                                                                      
        am = 1.0D+00*(m)                                                                                
        CALL ANALINT(Nanal,xaux,yaux,am,aux,error)                                                  
        IF(error.NE.0) THEN                                                                         
          RETURN                                                                                    
        END IF                                                                                      
c       add the contribution of the last Nanal points                                               
        intydx = intydx + aux                                                                       
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE OccltMSG                                                                           
c =======================================================================                           
c     Prints a message informing the user about the min Teff required to                            
c     neglect occultation by the central source.                                                    
c =======================================================================                           
      IMPLICIT NONE                                                                                 
      CHARACTER*10 Tstrg                                                                            
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iL                                                                                    
      DOUBLE PRECISION qaux(npL), qaux2(npL), res1, res2, Te_min,                                   
     &        mx, Psitn, Planck, xP                                                                 
c -----------------------------------------------------------------------                           
c     Estimate min Teff required to neglect occultation (eq.(5) in Manual):                         
      DO iL = 1, nL                                                                                 
        qaux(iL) = SigmaA(1,iL) * Us(iL,1) / lambda(iL)                                             
        xP = 14400.0D+00 / Tsub(1) / lambda(iL)                                                         
        qaux2(iL) = SigmaA(1,iL) * Planck(xP) / lambda (iL)                                         
      END DO                                                                                        
      CALL Simpson(npL,1,nL,lambda,qaux,res1)                                                       
      CALL Simpson(npL,1,nL,lambda,qaux2,res2)                                                      
c     Approximate Psi for opt.thin case:                                                            
      Psitn = res1/res2                                                                             
      mx = Tsub(1)*sqrt(sqrt(4.0D+00/Psitn))                                                             
      IF(Tsub(1).LT.mx) THEN                                                                        
       Te_min = 2.0D+00 * mx                                                                             
      ELSE                                                                                          
       Te_min = 2.0D+00 * Tsub(1)                                                                        
      END IF                                                                                        
      CALL GetFS(Te_min,0,1,Tstrg)                                                                  
      write(12,*)                                                                                   
     & ' ====================================================  '                                    
      write(12,*)                                                                                   
     & ' For compliance with the point-source assumption, the'                                      
      write(12,*)                                                                                   
     & ' following results should only be applied to sources '                                      
      write(12,'(a37,a5,a3)')                                                                       
     & '  whose effective temperature exceeds ',Tstrg, ' K.'                                        
      write(12,*)                                                                                   
     & ' ===================================================='                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Pgrid(pstar,iPstar,error)                                                          
c =======================================================================                           
c     After having the Y grid, generate the P grid (impact parameters)                              
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER i, iP, j, error, Naux, iPstar, NinsLoc                                                
      DOUBLE PRECISION pstar, delP                                                                  
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
      P(1) = 0.0D+00                                                                                    
      Naux = 1                                                                                      
      iYfirst(Naux) = 1                                                                             
      YPequal(Naux) = 1                                                                             
c     grid within the cavity (points concentrated towards p=1, SQRT!)                               
      nPcav = Ncav + Naux                                                                           
      DO iP = Naux+1, nPcav                                                                         
        P(iP) = P(Naux)+(1.0D+00-P(Naux))*sqrt((iP-Naux)/(Ncav+1.0D+00))                                  
        iYfirst(iP) = 1                                                                             
        YPequal(iP) = 1                                                                             
      END DO                                                                                        
c     insert two rays if the stellar disk size is finite                                            
      IF (pstar.GT.0.0D+00) THEN                                                                        
        CALL INSERT(pstar,iP,iPstar)                                                                
        DO i = nPcav+1, iP                                                                          
          iYfirst(i) = 1                                                                            
          YPequal(i) = 1                                                                            
        END DO                                                                                      
        nPcav = iP                                                                                  
        ELSE                                                                                        
        iP = nPcav                                                                                  
        iPstar = 0                                                                                  
      ENDIF                                                                                         
c     impact parameters for the envelope (tangential to the radial grid)                            
      DO i =1, nY-1                                                                                 
        Plast(i) = iP + 1                                                                           
c       points close to the inner cavity should have more impact param.                             
        NinsLoc = Nins                                                                              
c       if tau is large add a few more points to the impact param. grid                             
        IF (TAUmax.GT.10.0D+00) THEN                                                                      
          IF (i.LE.5) NinsLoc = Nins + 1                                                            
        END IF                                                                                      
        IF (TAUmax.GT.100.0D+00) THEN                                                                     
          IF (i.LE.10) NinsLoc = Nins + 1                                                           
          IF (i.LE.5) NinsLoc = Nins + 2                                                            
        END IF                                                                                      
c       increment in P                                                                              
        delP = (Y(i+1) - Y(i)) / (NinsLoc+1.0D+00)                                                      
        DO j = 1, NinsLoc+1                                                                         
          iP = iP + 1                                                                               
          iYfirst(iP) = i                                                                           
          IF (j.eq.1) THEN                                                                          
            YPequal(iP) = 1                                                                         
            ELSE                                                                                    
            YPequal(iP) = 0                                                                         
          END IF                                                                                    
          P(iP) = Y(i) + (j-1)*delP                                                                 
        END DO                                                                                      
      END DO                                                                                        
c     number of points for the P grid                                                               
      nP = iP + 1                                                                                   
      P(nP) = Y(nY)                                                                                 
      iYfirst(nP) = nY                                                                              
      YPequal(nP) = 1                                                                               
      Plast(nY) = nP                                                                                
c     check that the P grid is not too large                                                        
      IF (nP.GT.npP) THEN                                                                           
        error = 2                                                                                   
        CALL LINE(0,2,12)                                                                           
        write(12,'(a)')' This model terminated because needed accuracy'                             
        write(12,'(a,i6)')' results in too many points in P grid:',                                 
     &                    nP                                                                        
        write(12,'(a,i4,a)')'          (See PARAMET.inc, npP =',npP,')'                             
        CALL LINE(0,2,12)                                                                           
        iERROR = iERROR + 1                                                                         
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION Planck(x)                                                           
c =======================================================================                           
c This function evaluates the Planck function multiplied by wavelength                              
c and normalized by sigma*T^4/Pi.                      [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x                                                                            
c -----------------------------------------------------------------------                           
      IF (x.GT.100.0D+00) THEN                                                                            
        Planck = 0.0D+00                                                                                
        ELSE                                                                                        
        IF (x.LT.0.00001D+00) THEN                                                                      
          Planck = 0.154D+00 * x**3.0D+00                                                                   
          ELSE                                                                                      
          Planck = 0.154D+00 * x**4.0D+00 / (dexp(x) - 1.0D+00)                                                   
        END IF                                                                                      
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE RADTRANSF(pstar,iPstar,TAUlim,nG,ETAzp,FbolOK,deviat,                              
     &                     error,iterFbol,model)                                                    
c =======================================================================                           
c This subroutine solves the continuum radiative transfer problem for a                             
c spherically symmetric envelope.                      [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER error, iPstar, nG, Conv, iter, FbolOK, iterFbol, iaux, iY,                            
     &        Fconv, Uconv, BolConv, model, itnum, itlim                                            
      DOUBLE PRECISION pstar, ETAzp(npP,npY),mat0(npL,npY,npY), maxFerr,                            
     &       mat1(npL,npY,npY), Em(npL,npY), Uold(npL,npY), deviat,                                 
     &       fbolold(npY), mifront(npL,npP,npY), miback(npL,npP,npY),                               
     &       fsbol(npY), fdbol(npY), Usbol(npY), Udbol(npY), 
     &       TAUlim, dmaxF, dmaxU                                           
c     this is for the disk calculation:                                                             
c      DOUBLE PRECISION matD(npL,npY,npY), HemisL(npL,npY), Hemis(npY),                             
c     &       Hscat(npY), I1S(npP), I1E(npP), rsr1, T1, HscatL(npL,npY),                            
c     &       TauEnv0(npP,npL), corr, Udebol(npY), Udsbol(npY)                                      
c -----------------------------------------------------------------------                           
c     generate, or improve, or do not touch the Y and P grids                                       
      IF (iterETA.EQ.1.OR.iterFbol.GT.1) THEN                                                       
        IF (iterFbol.EQ.1) THEN                                                                     
c         first time generate grids                                                                 
          CALL SetGrids(pstar,iPstar,error,TAUlim)                                                  
          IF (error.NE.0) goto 999                                                                  
          IF (iVerb.EQ.2) write(*,*) 'Done with SetGrids'                                           
        ELSE                                                                                        
c         or improve the grid from previous iteration                                               
          CALL ChkFlux(fBol,accuracy,iaux,error,ETAzp)                                              
c         added in ver.2.06                                                                         
          IF (maxFerr.GT.0.5D+00) CALL DblYgrid(error)                                                  
          IF (error.NE.0) goto 999                                                                  
c         generate new impact parameter grid                                                        
c         increase the number of rays through the cavity                                            
          IF (Ncav.LT.80) THEN                                                                      
            Ncav = 2 * Ncav                                                                         
            IF (iX.NE.0) write(18,'(a20,i3)')' Ncav increased to:',Ncav                             
          END IF                                                                                    
c         increase the number of rays per y-grid interval                                           
          IF (iterFbol.EQ.3.AND.Nins.EQ.2) THEN                                                     
            Nins = Nins + 1                                                                         
            IF (iX.NE.0) write(18,'(a20,i3)')' Nins increased to:',Nins                             
          END IF                                                                                    
          CALL Pgrid(pstar,iPstar,error)                                                            
c         if P grid is not OK end this model                                                        
          IF (error.NE.0) goto 999                                                                  
          IF (iX.NE.0) THEN                                                                         
            write(18,'(a23,i3)')' Y grid improved, nY =',nY                                         
            write(18,'(a23,i3)')'                  nP =',nP                                         
            write(18,'(a23,i3)')'                Nins =',Nins                                       
            write(18,'(a23,i3)')'                Ncav =',Ncav                                       
          END IF                                                                                    
        END IF                                                                                      
      ELSE                                                                                          
        IF (iX.NE.0) write(18,*)' Using same Y and P grids'                                         
      END IF                                                                                        
c     generate spline coefficients for ETA                                                          
      CALL setupETA                                                                                 
c     evaluate ETAzp                                                                                
      CALL getETAzp(ETAzp)                                                                          
c     generate albedo through the envelope                                                          
      CALL getOmega(nG)                                                                             
c     generate stellar moments                                                                      
      CALL Star(pstar,ETAzp,error)                                                                  
      IF (iVerb.EQ.2) write(*,*) 'Done with Star'                                                   
c     issue a message in fname.out about the condition for neglecting                               
c     occultation only if T1 is given in input:                                                     
      IF(typEntry(1).eq.1.AND.model.eq.1) THEN                                                      
       IF(iterFbol.eq.1.AND.iterEta.eq.1.AND.Right.eq.0) CALL OccltMSG                              
      END IF                                                                                        
c     generate the first approximation for Td                                                       
      CALL InitTemp(ETAzp,nG)                                                                       
      IF (iVerb.EQ.2) write(*,*) 'Done with InitTemp'                                               
c     find radiative transfer matrices                                                              
      IF (iX.NE.0) write(18,*)' Calculating weight matrices'                                        
      IF (iVerb.EQ.2) write(*,*) 'Calculating weight matrices'                                      
      IF (iD.GE.1) THEN                                                                             
       IF (iVerb.GE.1) write(*,*) 'No disk option in this version'                                  
c      if disk included:                                                                            
c       CALL MatrixD(ETAzp,pstar,iPstar,mat0,mat1,matD,mifront,miback)                              
      ELSE                                                                                          
       CALL Matrix(ETAzp,pstar,iPstar,mat0,mat1,mifront,miback)                                     
      END IF                                                                                        
                                                                                                    
      Conv = 0                                                                                      
      iter = 0                                                                                      
c     itlim is an upper limit on number iterations                                                  
      itlim = 50000                                                                                 
      IF (iX.NE.0) write(18,*)' Weight matrices OK, calculating Tdust'                              
      IF (iVerb.EQ.2) write(*,*)' Weight matrices OK, calculating Tdust'                            
      IF (iInn.eq.1) THEN                                                                           
        write(38,'(a8,i5)') '    nY= ',nY                                                           
      write(38,*)                                                                                   
     & '    iter   maxFerr     dmaxU       dmaxF        T1         Fe1'                             
      END IF                                                                                        
                                                                                                    
c     === Iterations over dust temperature =========                                                
      DO WHILE (Conv.EQ.0.AND.iter.LE.itlim)                                                        
        iter = iter + 1                                                                             
c       find emission term                                                                          
c       because there is no alpha now, y^2 appears explicitly in                                    
c       Emission and we need the flag for geometry (1-for sphere).                                  
        CALL Emission(1,0,nG,Td,abund,Us,Em)                                                        
c       solve for Utot                                                                              
        CALL Invert(nY,nL,mat0,Us,Em,omega,Utot,Uold,error)                                         
        IF(error.NE.0) goto 999                                                                     
c       find new Td                                                                                 
        CALL FindTemp(1,Utot,nG,Td)                                                                 
c       --------------------------------------                                                      
c       every itnum-th iteration check convergence:                                                 
          IF (iter.GT.80) THEN                                                                      
             itnum = 10                                                                             
            ELSE                                                                                    
             itnum = 6                                                                              
          END IF                                                                                    
c       first find 'old' flux (i.e. in the previous iteration)                                      
        IF (MOD(iter+1,itnum).EQ.0) THEN                                                            
          CALL Multiply(1,npY,nY,npL,nL,mat1,Utot,omega,0,fs,fds)                                   
          CALL Multiply(0,npY,nY,npL,nL,mat1,Em,omega,0,fs,fde)                                     
          CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                   
c         find bolometric flux                                                                      
          CALL Bolom(ftot,fbolold)                                                                  
        END IF                                                                                      
        IF (MOD(iter,itnum).EQ.0) THEN                                                              
c         first calculate total flux                                                                
          CALL Multiply(1,npY,nY,npL,nL,mat1,Utot,omega,0,fs,fds)                                   
          CALL Multiply(0,npY,nY,npL,nL,mat1,Em,omega,0,fs,fde)                                     
          CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                   
c         find bolometric flux                                                                      
          CALL Bolom(ftot,fbol)                                                                     
c         check convergence of bolometric flux                                                      
          CALL Converg1(nY,accFbol,dynrange,fbolold,fbol,Fconv,dmaxF)                               
c         check convergence of energy density                                                       
          CALL Converg2(nY,nL,accConv,dynrange,Uold,Utot,Uconv,dmaxU)                               
c         find maximal fbol error                                                                   
          CALL FindErr(fbol,maxFerr,nY)                                                             
c ------  printout of errors and convergence with iter.(inner flag): -------                        
          IF(iInn.EQ.1) THEN                                                                        
            write(38,'(i7,1p,5e12.4)') iter,maxFerr,dmaxU,dmaxF,                                    
     &                                      Td(1,1),sigma*Tei**4.0D+00                                   
          END IF                                                                                    
c --------------------------------------------------------------                                    
          IF (maxFerr.LE.accuracy) THEN                                                             
            BolConv = 1                                                                             
          ELSE                                                                                      
            BolConv = 0                                                                             
          END IF                                                                                    
c         total criterion for convergence: Utot must converge, and ftot                             
c         must either converge or have the required accuracy                                        
          IF (Uconv*(Fconv+BolConv).GT.0) Conv = 1                                                  
        END IF                                                                                      
c       --------------------------------------                                                      
      END DO                                                                                        
c     === The End of Iterations over Td ===                                                         
      IF (iX.NE.0) THEN                                                                             
        IF (iter.LT.itlim) write(18,*)                                                              
     &     ' Convergence achieved, number of'                                                       
        write(18,'(a34,i4)')                                                                        
     &     ' iterations over energy density: ',iter                                                 
        write(18,'(a30,1p,e8.1)')                                                                   
     &     ' Flux conservation OK within:',maxFerr                                                  
        IF (iter.GE.itlim) THEN                                                                     
          CALL MSG(2)                                                                               
          iWARNING = iWARNING + 1                                                                   
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
c     calculate the emission term for the converged Td                                              
      CALL Emission(1,0,nG,Td,abund,Us,Em)                                                          
c     calculate flux                                                                                
      CALL Multiply(1,npY,nY,npL,nL,mat1,Utot,omega,0,fs,fds)                                       
      CALL Multiply(0,npY,nY,npL,nL,mat1,Em,omega,0,fs,fde)                                         
      CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                       
      CALL Bolom(ftot,fbol)                                                                         
c     check whether, and how well, is bolometric flux conserved                                     
      CALL ChkBolom(fbol,accuracy,deviat,FbolOK)                                                    
      CALL FindErr(fbol,maxFerr,nY)                                                                 
c     added in ver.2.06                                                                             
      IF (maxFerr.GT.0.5) FbolOK = 0                                                                
c ***********************************                                                               
c     calculate additional output quantities                                                        
c     1) energy densities                                                                           
      CALL Multiply(1,npY,nY,npL,nL,mat0,Utot,omega,0,Us,Uds)                                       
      CALL Multiply(0,npY,nY,npL,nL,mat0,Em,omega,0,Us,Ude)                                         
      CALL Add(npY,nY,npL,nL,Us,Uds,Ude,Uchck)                                                      
      CALL Bolom(Utot,Ubol)                                                                         
      CALL Bolom(Uchck,UbolChck)                                                                    
                                                                                                    
c     2) scaled radial optical depth, tr                                                            
      DO iY = 1, nY                                                                                 
        tr(iY) = ETAzp(1,iY) / ETAzp(1,nY)                                                          
      END DO                                                                                        
c     3) calculate intensity (at the outer edge) if required                                        
      IF(iC.NE.0) THEN                                                                              
       IF (iX.NE.0) write(18,*) 'Calculating intensities'                                           
       CALL FindInt(nG,ETAzp)                                                                       
       IF (iVerb.EQ.2) write(*,*) 'Done with FindInt'                                               
      END IF                                                                                        
c     if needed convolve intensity with the PSF                                                     
      IF (iPSF.NE.0) THEN                                                                           
        CALL Convolve(IntOut)                                                                       
        IF (iVerb.EQ.2) write(*,*) 'Done with Convolve'                                             
      END IF                                                                                        
c     if needed find the visibility function                                                        
      IF (iV.NE.0) THEN                                                                             
        CALL Visibili(IntOut)                                                                       
        IF (iVerb.EQ.2) write(*,*) 'Done with Visibili'                                             
      END IF                                                                                        
c ============ if the inner flag iInn=1:  =========                                                 
      IF(iX.GE.1 .AND. iInn.EQ.1) THEN                                                              
c      if additional output needed in message files when iInn = 1
        CALL Bolom(fs,fsbol)                                                                        
        CALL Bolom(fs,fsbol)                                                                        
        CALL ADD2(fds,fde,fdbol,nY)                                                                 
        write(18,'(a11,1p,E11.3)')'   TAUfid =',TAUfid                                              
        write(18,'(a11,1p,E11.3)')'  MaxFerr =',maxFerr                                             
        write(18,*)                                                                                 
     &'     tr      fbol       fsbol      fdbol       Ubol  '                                       
c     &'     tr      fbol       fsbol      fdbol     Usbol      Udbol'
      CALL Bolom(Us,Usbol)
c      DO iY = 1, nY
c        Udbol(iY) = Ubol(iY)-Usbol(iY)
c      END DO

       DO iY = 1, nY                                                                                
        write(18,'(1p,6E11.3)') tr(iY), fbol(iY), fsbol(iY),                                        
     &                          fdbol(iY), Ubol(iY)                                                 
c !!!! 
c      write(18,'(1p,6E11.3)') tr(iY), fsbol(iY)+fdbol(iY), fsbol(iY),                                        
c     &                          fdbol(iY), Usbol(iY), Udbol(iY)                                                 
       END DO                                                                                       
      END IF                                                                                        
c =====================                                                                             
c     if needed solve for disk quantities                                                           
c      corr = 0.0                                                                                   
      IF (iD.GE.1) THEN                                                                             
       IF (iVerb.GE.1) write(*,*) 'No disk option in this version'                                  
c       IF (iVerb.GE.1) write(*,*) 'Solving for disk quantities'                                    
cc         first calculate wavelength dependent disk heating (at every y)                           
c          CALL Multiply(1,npY,nY,npL,nL,matD,Utot,omega,0,fs,HscatL)                               
c          CALL Multiply(0,npY,nY,npL,nL,matD,Em,omega,0,fs,HemisL)                                 
cc         get bolometric quantities                                                                
c          CALL Bolom(HscatL,Hscat)                                                                 
c          CALL Bolom(HemisL,Hemis)                                                                 
c          CALL Bolom(fs,fsbol)                                                                     
cc  %%%%%% TEMPORARY   %%%%%%%%%%%%%                                                                
c              open(88,file='ratios.temp',status='unknown')                                         
c              write(88,*)'      y         Rscat       Remis   '                                    
c              CALL Bolom(Uds,Udsbol)                                                               
c              CALL Bolom(Ude,Udebol)                                                               
c              DO iY = 1, nY                                                                        
c                  write(88,'(1p,3e12.4)')Y(iY),Hscat(iY)/Udsbol(iY),                               
c     &            Hemis(iY)/Udebol(iY)                                                             
c              END DO                                                                               
c              close(88)                                                                            
cc  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                                
c         find I(mu,y=1) (bolometric: I1(npP))                                                      
c          CALL Imuaux(Y,nY,P,nP,lambda,nL,mifront,miback,Utot,Em,                                  
c     &              omega,I1S,I1E)                                                                 
c          CALL Imu1(Y,nY,P,nP,lambda,nL,mifront,miback,Utot,Em,omega,                              
c     &              I1S,I1E)                                                                       
c         find rsr1 = rstar/r1                                                                      
c          T1 = Tsub(1)                                                                             
c          CALL  GETpstar(npL,nL,lambda,T1,Tstar(1),npG,SigmaA,npY,Utot,                            
c     &                   rsr1)                                                                     
c         *** call the main disk subroutine ***                                                     
c          CALL SOLVEDISK(Y,nY,P,nP,lambda,TauTot,ETAzp,nL,Hscat,Hemis,                             
c     &                   I1S,I1E,rsr1,fsbol,corr,iD)                                               
      END IF                                                                                        
                                                                                                    
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SetGrids(pstar,iPstar,error,TAU)                                                   
c =======================================================================                           
c Sets the Y and P grids based on GrayBody flux conservation.                                       
c                                                     [MN & ZI, July'96]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER error, iPstar, consfl                                                                 
      DOUBLE PRECISION pstar, Ugb(npY), fgb(npY), ETAzp(npP,npY),albedo,                            
     &       aux, faccs, TAU, accur, delTAUin                                                       
c -----------------------------------------------------------------------                           
c     store the default value for delTAUsc and facc                                                 
      faccs = facc                                                                                  
      delTAUin = delTAUsc                                                                           
c     change the delTAUsc seed for the initial Y grid if TAU is large                               
      IF (TAU.LT.1.0D+00) delTAUsc = delTAUin * 2.0D+00                                                     
      IF (TAU.GE.1.0D+00.and.TAU.LT.5.0D+00)delTAUsc = delTAUin*1.5D+00                                      
      IF (TAU.EQ.5.0D+00) delTAUsc = delTAUin                                                           
      IF (TAU.GT.5.0D+0.and.TAU.LT.10.0D+0) delTAUsc = delTAUin/1.2D+00                                     
      IF (TAU.GE.10.0D+0.and.TAU.LT.20.0D+0)delTAUsc = delTAUin/1.3D+00                                    
c      The grid is set with TAU=min{TAUlim,TAUmax}, so the lines below are obsol                    
c      IF (TAU.GE.20.0.and.TAU.LT.30.0) delTAUsc = delTAUin / 1.4                                   
c      IF (TAU.GE.30.0.and.TAU.LT.50.0) delTAUsc = delTAUin / 1.5                                   
c      IF (TAU.GE.50.0) delTAUsc = delTAUin / 2.0                                                   
c     for steep density distributions (RDW, including analyt.approximation):                        
      IF (RDWA.OR.RDW) delTAUsc = delTAUin / 1.2D+00                                                    
c     change the facc seed for the initial Y grid if Yout is very small                             
      IF (Yout.LT.1000.0D+00) facc = dsqrt(faccs)                                                       
      IF (Yout.LT.100.0D+00) facc = dsqrt(facc)                                                         
      IF (Yout.LT.10.0D+00) facc = dsqrt(facc)                                                          
      IF (Yout.LT.2.0D+00) facc = dsqrt(facc)                                                           
      IF (Yout.LT.1.2D+00) facc = dsqrt(facc)                                                           
      IF (Yout.LT.1.05D+00) facc = dsqrt(facc)                                                          
                                                                                                    
      albedo = 1.0D+00                                                                                  
      aux = 1.0D+00                                                                                     
c     generate initial grids                                                                        
      CALL Ygrid(pstar,iPstar,error)                                                                
c     increase the grid if large tau and external illumination only                                 
      IF(Left.eq.0.AND.taumax.ge.99.0D+00) CALL DblYgrid(error)                                          
      IF (error.NE.0) goto 101                                                                      
      CALL Pgrid(pstar,iPstar,error)                                                                
      IF (error.NE.0) goto 101                                                                      
      IF (iX.GE.1) THEN                                                                             
         write(18,'(a24,i3)')' Y grid generated, nY =',nY                                           
         write(18,'(a24,i3)')'                   nP =',nP                                           
         write(18,'(a24,i3)')'                 Nins =',Nins                                         
         write(18,'(a24,i3)')'                 Ncav =',Ncav                                         
      END IF                                                                                        
c     solve for gray body (i.e. pure scattering)                                                    
      CALL GrayBody(albedo,TAU,Ugb,fgb,ETAzp)                                                       
      IF (iVerb.EQ.2) write(*,*) 'Done with GrayBody'                                               
c     find the max deviation of fgb (FindRMS called with flag 1)                                    
c     (for grid generation purpose aux is set to 1.)                                                
      CALL FindRMS(1,fgb,aux,accur,nY)                                                              
      IF (iX.GE.1) THEN                                                                             
        IF (accur.GT.accuracy) THEN                                                                 
          write(18,'(a25)')' Grids need improvement:'                                               
          write(18,'(a29,1p,e10.3)')                                                                
     &                          '                   fTot(nY):',fgb(nY)                              
          write(18,'(a29,1p,e10.3)')'      Single wavelength TAU:',TAU                              
          write(18,'(a29,1p,e10.3)')                                                                
     &                         '          Required accuracy:',accuracy                              
        END IF                                                                                      
        write(18,'(a29,1p,e10.3)')' Single wavelength accuracy:',accur                              
      END IF                                                                                        
      IF(accur.GT.accuracy) THEN                                                                    
c       ChkFlux checks the bolometric flux conservation for the given                               
c       grid and decreases the step if conservation is not satisfactory                             
        consfl = 5                                                                                  
        CALL ChkFlux(fgb,accuracy,consfl,error,ETAzp)                                               
        IF (error.NE.0) goto 101                                                                    
c       consfl=5 means everything was fine in ChkFlux                                               
        IF (consfl.EQ.5) THEN                                                                       
          IF (iX.GE.1) write(18,'(a23,i3)')' Y grid improved, nY =',nY                              
c         generate new impact parameter grid                                                        
          CALL Pgrid(pstar,iPstar,error)                                                            
c         if P grid is not OK end this model                                                        
          IF (error.NE.0) goto 101                                                                  
        ELSE                                                                                        
          IF (iX.GE.1) THEN                                                                         
            write(18,'(a59,i3)')                                                                    
     &      ' Although single wavelength accuracy was not satisfactory,'                            
            write(18,'(a56,i3)')                                                                    
     &      ' Y grid could not be improved because npY is too small.'                               
            write(18,'(a58,i3)')                                                                    
     &      ' Continuing calculation with a hope that it will be fine.'                             
          END IF                                                                                    
        END IF                                                                                      
      END IF                                                                                        
c     return the default value for facc                                                             
101    facc = faccs                                                                                 
       delTAUsc = delTAUin                                                                          
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE solve(model,nG,error,ETAzp)                                                        
c =======================================================================                           
c This subroutine solves the continuum radiative transfer problem for a                             
c spherically symmetric envelope.                      [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER model,error, iPstar, iterFbol, nG, FbolOK, EtaOK, iY                                  
      DOUBLE PRECISION pstar, ETAzp(npP,npY), TAUlim, deviat                                        
c -----------------------------------------------------------------------                           
      IF(iInn.eq.1) THEN                                                                            
        write(38,*)'============================================='                                  
        write(38,'(a7,i5)') ' model= ',model                                                        
        write(38,*)'============================================='                                  
      END IF                                                                                        
      IF (iX.NE.0) THEN                                                                             
       CALL LINE(0,2,18)                                                                            
       write(18,'(a7,i3,a20)') ' model ',model,'  RUN-TIME MESSAGES '                               
       CALL LINE(0,1,18)                                                                            
       write(18,*)'===========  STARTING SOLVE  ==========='                                        
      END IF                                                                                        
      error = 0                                                                                     
      IF(denstyp.NE.0) THEN                                                                         
c     Solve for spherical envelope:                                                                 
c      temporarily the star is approximated by a point source                                       
       pstar = 0.0                                                                                  
       iPstar = 1                                                                                   
c      select optical depth for the grid calculation                                                
c      based on dynamical range                                                                     
       TAUlim = 0.5D+00*dlog(1.0D+00/dynrange)                                                               
c      if actual maximal tau is smaller use that value                                              
       IF (TAUmax.LT.TAUlim) TAUlim = TAUmax                                                        
c      counter over ETA (for radiatively driven winds only)                                         
       iterETA = 0                                                                                  
       EtaOK = 0                                                                                    
c      iterations over ETA                                                                          
       DO WHILE (EtaOK.EQ.0)                                                                        
         iterETA = iterETA + 1                                                                      
         IF (iX.NE.0.AND.RDW) THEN                                                                  
           write(18,*)'----------------------------------------'                                    
           write(18,*)' ',iterETA,'. iteration over ETA'                                            
         END IF                                                                                     
         IF (iVerb.EQ.2.AND.RDW)                                                                    
     &          write(*,*) ' ',iterETA,'. iteration over ETA'                                       
c        counter for iterations over bolometric flux conservation                                   
         iterFbol = 0                                                                               
         FbolOK = 0                                                                                 
         DO WHILE (FbolOK.EQ.0)                                                                     
           iterFbol = iterFbol + 1                                                                  
           IF (iX.NE.0) THEN                                                                        
            write(18,*)'  ',iterFbol,'. iteration over Fbol'                                        
           END IF                                                                                   
           IF (iVerb.EQ.2) write(*,*) iterFbol,'. iteration over Fbol'                              
c          solve the radiative transfer problem                                                     
           CALL RADTRANSF(pstar,iPstar,TAUlim,nG,ETAzp,FbolOK,deviat,                               
     &                   error,iterFbol,model)                                                      
           IF (iVerb.EQ.2) write(*,*) 'Done with RadTransf'                                         
c          error.EQ.3 : file with stellar spectrum not available                                    
           IF (error.EQ.3) goto 999                                                                 
c          error.EQ.5 : Singular matrix                                                             
           IF (error.EQ.5) goto 999                                                                 
c          error.EQ.6 : Eta exceeds limitations                                                     
           IF (error.EQ.6) goto 999                                                                 
c          error.EQ.2 : P grid was not produced                                                     
           IF (error.EQ.2.AND.iterFbol.EQ.1.AND.iterETA.EQ.1) THEN                                  
c           if this is the first calculation end this model                                         
            iERROR = iERROR + 1                                                                     
            goto 999                                                                                
           ELSE                                                                                     
c           if this is a higher iteration use previous solution                                     
            IF (error.EQ.2) THEN                                                                    
              IF (iX.NE.0.AND.iterFbol.GT.1) THEN                                                   
              write(18,*)' ======= IMPORTANT WARNING ======== '                                     
              write(18,*)' In trying to conserve Fbol reached'                                      
              write(18,*)' the limit for grid sizes. Flux is '                                      
              write(18,'(a,1p,e9.3)')'  conserved to within ', deviat                               
              write(18,*)' Treat all results with caution!'                                         
              END IF                                                                                
              IF (iX.NE.0.AND.iterFbol.EQ.1) THEN                                                   
              write(18,*)' ======== IMPORTANT  WARNING ======== '                                   
              write(18,*)' In trying to converge on ETA reached'                                    
              write(18,*)' the limit for grid sizes. Flux is '                                      
              write(18,'(a,1p,e9.3)')'  conserved to within ', deviat                               
              write(18,*)' Treat all results with caution!'                                         
              END IF                                                                                
              error = 0                                                                             
              FbolOK = 2                                                                            
              iWARNING = iWARNING + 1                                                               
            END IF                                                                                  
           END IF                                                                                   
c          just in case...                                                                          
           IF (error.EQ.1) THEN                                                                     
            IF (iX.NE.0) THEN                                                                       
              write(18,*)' *********  FATAL ERROR  *********'                                       
              write(18,*)' * Something was seriously wrong *'                                       
              write(18,*)' * Contact Z. Ivezic, M. Elitzur *'                                       
              write(18,*)' *********************************'                                       
            END IF                                                                                  
            iERROR = iERROR + 1                                                                     
            goto 999                                                                                
           END IF                                                                                   
c          if Fbol not conserved try again with a finer grid                                        
           IF (FbolOK.EQ.0.AND.iterFbol.LT.10.AND.iX.NE.0) THEN                                     
            write(18,*)'  ******** MESSAGE from SOLVE ********'                                     
            write(18,*)'  Full solution does not conserve Fbol'                                     
            write(18,*)'       Y       TAU/TAUtot        fbol'                                      
            DO iY =1, nY                                                                            
              write(18,'(1p,3e13.4)')Y(iY),                                                         
     &                  ETAzp(1,iY)/ETAzp(1,nY),fbol(iY)                                            
            END DO                                                                                  
            write(18,*)'  Trying again with finer grids'                                            
           END IF                                                                                   
c          if could not conserve Fbol in 10 trials give it up                                       
           IF (FbolOK.EQ.0.AND.iterFbol.GE.10) THEN                                                 
            IF (RDW) THEN                                                                           
            IF (iX.NE.0) THEN                                                                       
            write(18,*)' **********  WARNING from SOLVE  **********'                                
            write(18,*)' Could not obtain required accuracy in Fbol'                                
            write(18,'(a26,1p,e10.3)')'  The achieved accuracy is:',                                
     &                                 deviat                                                       
            write(18,*)' Will try to converge on the dynamics, but '                                
            write(18,*)' treat all results with caution !!         '                                
            write(18,*)' If accuracy<=0.01, or TAUmax>1000, this   '                                
            write(18,*)' code probably cannot do it. Otherwise,    '                                
            write(18,*)' please contact Z. Ivezic or M. Elitzur    '                                
            write(18,*)' ******************************************'                                
            END IF                                                                                  
            iWARNING = iWARNING + 1                                                                 
            FbolOK = 1                                                                              
            ELSE                                                                                    
            IF (iX.NE.0) THEN                                                                       
            write(18,*)' **********  WARNING from SOLVE  **********'                                
            write(18,*)' Could not obtain required accuracy in Fbol'                                
            write(18,'(a26,1p,e10.3)')'  The achieved accuracy is:',                                
     &                                 deviat                                                       
            write(18,*)' !!!!  Treat all results with caution  !!!!'                                
            write(18,*)' If accuracy<=0.01, or TAUmax>1000, this   '                                
            write(18,*)' code probably cannot do it. Otherwise,    '                                
            write(18,*)' please contact Z. Ivezic or M. Elitzur    '                                
            write(18,*)' ******************************************'                                
            END IF                                                                                  
            iWARNING = iWARNING + 1                                                                 
            FbolOK = 2                                                                              
            END IF                                                                                  
           END IF                                                                                   
c        end of loop over flux conservation                                                         
         END DO                                                                                     
c        for winds check if ETA has converged...                                                    
         IF ((RDW).AND.FbolOK.NE.2) THEN                                                            
c         ptr(2) is specified in INPUT and controls converg. crit.                                  
          IF (ptr(2).LT.1.0D-6.AND.iterETA.GT.2)THEN                                                
            EtaOK = 1                                                                               
          ELSE                                                                                      
            CALL WINDS(nG,EtaOK,ftot)                                                               
          END IF                                                                                    
          IF (iterETA.GT.10.AND.EtaOK.EQ.0) THEN                                                    
            EtaOK = 2                                                                               
            iWARNING = iWARNING + 1                                                                 
            IF (iX.NE.0) THEN                                                                       
              write(18,*)' *********  WARNING  *********'                                           
              write(18,*)' Could not converge on ETA in '                                           
              write(18,*)' 10 iterations.'                                                          
              write(18,*)' *********************************'                                       
            END IF                                                                                  
          END IF                                                                                    
c         ...or otherwise finish right away                                                         
         ELSE                                                                                       
          EtaOK = 1                                                                                 
         END IF                                                                                     
c      end of loop over ETA                                                                         
       END DO                                                                                       
      ELSE                                                                                          
c      solve for slab case                                                                          
       CALL SLBsolve(model,nG,error)                                                                
c      error=4 means npY not large enough for oblique illumination grid                             
       IF (error.eq.4) THEN                                                                         
        CALL MSG(15)                                                                                
        iWARNING = iWARNING + 1                                                                     
        goto 999                                                                                    
       END IF                                                                                       
      END IF                                                                                        
c     analyze the solution and calculate some auxiliary quantities                                  
      CALL Analysis(model,ETAzp,error)                                                              
      IF (iVerb.EQ.2) write(*,*) 'Done with Analysis'                                               
      IF (iX.NE.0) THEN                                                                             
        write(18,*)' ==== SOLVE successfully completed ====='                                       
        write(18,*)' ======================================='                                       
      END IF                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE STAR(pstar,ETAzp,error)                                                            
c =======================================================================                           
c This subroutine generates the stellar spectral profiles [ZI,Nov'95; MN,'99,'00                    
c The spectral of the corresponding source is called Bb(is), where is=1 for                         
c the central source (resp.left source for slab), is=2 for external rad. (right                     
c source for slab).                                                                                 
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER nZ(npP), iY, iL, error                                                                
      DOUBLE PRECISION pstar, ETAzp(npP,npY), ShpL(npL), ShpR(npL),                                 
     &       m0(npL,npY), m1(npL,npY), UsL(npL,npY), Usbol(npY),                                    
     &       fsbolL(npY), UsbolL(npY), UsbolR(npY), zeta,                                           
     &       m1p(npL,npY), m1m(npL,npY), fsbolR(npY), dyn2, expow,                                  
     &       fsRpbol(npY), fsRmbol(npY), integext  
c -----------------------------------------------------------------------                           
      dyn2 = dynrange*dynrange                                                                      
c     is=1 for the enclosed source, is=2 for the external shell illumination                        
      IF(Left.GT.0) THEN                                                                            
         CALL GetSPShape(ShpL,1)                                                                    
      ELSE                                                                                          
        DO iL = 1, nL                                                                               
          ShpL(iL) = 0.0D+00                                                                             
        END DO                                                                                      
      END IF                                                                                        
                                                                                                    
      IF(Right.GT.0) THEN                                                                           
         CALL GetSPShape(ShpR,2)                                                                    
      ELSE                                                                                          
        DO iL = 1, nL                                                                               
          ShpR(iL) = 0.0D+00                                                                             
        END DO                                                                                      
      END IF                                                                                        
                                                                                                    
c   ----------  done with stellar spectrum ---------------                                          
c     stellar part of en.density and flux                                                           
      IF (Left.GT.0) THEN                                                                           
        DO iL = 1, nL                                                                               
          DO iY = 1, nY                                                                             
c           effect of the star's finite size                                                        
            IF (pstar.GT.0.0D+00) THEN                                                                  
             zeta = 2.0D+00*
     &(1.0D+00-sqrt(1.0D+00-(pstar/Y(iY))**2.0D+00))*
     &(Y(iY)/pstar)**2.0D+00                            
            ELSE                                                                                    
             zeta = 1.0D+00                                                                             
            END IF                                                                                  
c           for the central (left) source                                                           
            expow = ETAzp(1,iY)*TAUtot(iL)                                                          
            IF(expow.LT.50.0D+00) THEN                                                                   
              UsL(iL,iY) = ShpL(iL) * zeta * dexp(-expow)                                           
c             flux                                                                                  
              fsL(iL,iY) = ShpL(iL) * dexp(-expow)                                                  
            ELSE                                                                                    
              UsL(iL,iY) = 0.0D+00                                                                       
              fsL(iL,iY) = 0.0D+00                                                                       
            END IF                                                                                  
          END DO                                                                                    
        END DO                                                                                      
      ELSE                                                                                          
        DO iL = 1, nL                                                                               
          DO iY = 1, nY                                                                             
             UsL(iL,iY) = 0.0D+00                                                                        
             fsL(iL,iY) = 0.0D+00                                                                        
          END DO                                                                                    
        END DO                                                                                      
      END IF                                                                                        
	                                                                                                   
c     find the stellar bolometric flux                                                              
      CALL Bolom(fsL,fsbolL)                                                                        
      CALL Bolom(UsL,UsbolL)                                                                        
       DO iL = 1, nL                                                                                
         DO iY = 1, nY                                                                              
           UsL(iL,iY) = UsL(iL,iY)/UsbolL(1)                                                        
           fsL(iL,iY) = fsL(iL,iY)/UsbolL(1)                                                        
         END DO                                                                                     
       END DO                                                                                       
c     angular integration of the external radiation                                                 
      IF(Right.GT.0) THEN                                                                           
C***** obsolete subroutine -- function integext can now do this integration
c        CALL IntegExtOLD(ETAzp,nZ,m0,m1,m1p,m1m)                                                   
c*****
cc!     changes added June'07                                                                                                      
c       find the en.density of the ext.radiation                                                    
        DO iL = 1, nL                                                                               
          DO iY = 1, nY                                                                             
c            UsR(iL,iY) = ShpR(iL)*m0(iL,iY)                                                         
c     U = f_ext (lambda) * integral (exp(-tau(mu))) d(mu)
c     if flag = 0  then glam(lam,y,flag) = integral(exp(-tau(mu))) d(mu) 
c            print*, 'going to integext with y=', Y(iY)
            UsR(iL,iY) = ShpR(iL)*(0.5D+00*integext(iL,Y(iY),0))
          END DO                                                                                    
        END DO                                                                                      

c       now the external flux (it is 0 at y=1)                                                      
        DO iL = 1, nL                                                                               
          DO iY = 1, nY                                                                             
c            fsR(iL,iY) = ShpR(iL)*m1(iL,iY)                                                         
c     if flag = 1  then glam(lam,y,flag) = integral(mu*exp(-tau(mu))) d(mu) 
            fsR(iL,iY) = ShpR(iL)*(0.5D+00*integext(iL,Y(iY),1))
c            fsRp(iL,iY) = ShpR(iL)*m1p(iL,iY)                                                       
c            fsRm(iL,iY) = ShpR(iL)*m1m(iL,iY)                                                       
          END DO                                                                                    
        END DO                                                                                      

        CALL Bolom(UsR,UsbolR)                                                                      
        DO iL = 1, nL                                                                               
          DO iY = 1, nY                                                                             
            UsR(iL,iY) = UsR(iL,iY)/UsbolR(nY)                                                      
            fsR(iL,iY) = fsR(iL,iY)/UsbolR(nY)                                                      
c            fsRp(iL,iY) = fsRp(iL,iY)/UsbolR(nY)                                                    
c            fsRm(iL,iY) = fsRm(iL,iY)/UsbolR(nY)                                                    
          END DO                                                                                    
        END DO                                                                                      
        CALL Bolom(UsR,UsbolR)                                                                      
        CALL Bolom(fsR,fsbolR)                                                                      
      END IF                                                                                        
c     for reference: chi = Jo/(Ji + Jo)                                                             
c     determined in Subroutine Input                                                                
      DO iL = 1, nL                                                                                 
       DO iY = 1, nY                                                                                
          IF(Left.gt.0) THEN                                                                        
            UsL(iL,iY) = (1.0D+00-chi)*UsL(iL,iY)                                                        
            fsL(iL,iY) = (1.0D+00-chi)*fsL(iL,iY)                                                        
          ELSE                                                                                      
            UsL(iL,iY) = 0.0D+00                                                                         
            fsL(iL,iY) = 0.0D+00                                                                         
          END IF                                                                                    
c         for the external rad.                                                                     
          IF(Right.gt.0) THEN                                                                       
             UsR(iL,iY) = chi*UsR(iL,iY)*Y(iY)**2.0D+00                                                  
             fsR(iL,iY) = chi*fsR(iL,iY)*Y(iY)**2.0D+00                                                  
c             fsRp(iL,iY) = chi*fsRp(iL,iY)*Y(iY)**2.0D+00                                                
c             fsRm(iL,iY) = chi*fsRm(iL,iY)*Y(iY)**2.0D+00                                                
c            For external only - separate scaling                                                   
             IF(Left.eq.0) THEN                                                                     
               UsR(iL,iY) = UsR(iL,iY)/(Y(nY))**2.0D+00                                                  
               fsR(iL,iY) = fsR(iL,iY)/(Y(nY))**2.0D+00                                                  
c               fsRp(iL,iY) = fsRp(iL,iY)/(Y(nY))**2.0D+00                                                
c               fsRm(iL,iY) = fsRm(iL,iY)/(Y(nY))**2.0D+00                                                
             END IF                                                                                 
          ELSE                                                                                      
             UsR(iL,iY) = 0.0D+00                                                                        
             fsR(iL,iY) = 0.0D+00                                                                        
             fsRp(iL,iY) = 0.0D+00                                                                       
             fsRm(iL,iY) = 0.0D+00                                                                       
          END IF                                                                                    
       END DO                                                                                       
      END DO                                                                                        
                                                                                                    
      DO iY = 1, nY                                                                                 
        DO iL = 1, nL                                                                               
          Us(iL,iY) = UsL(iL,iY) + UsR(iL,iY)                                                       
          fs(iL,iY) = fsL(iL,iY) + fsR(iL,iY)                                                       
          IF (Us(iL,iY).LT.dyn2) Us(iL,iY) = 0.0D+00                                                    
c         when external is present                                                                  
c         IF (dabs(fs(iL,iY)).LT.dyn2) fs(iL,iY) = 0.0                                              
        END DO                                                                                      
      END DO                                                                                        
c =========================                                                                         
                                                                                                    
      CALL Bolom(Us,Usbol)                                                                          
      CALL Bolom(fs,fsbol)                                                                          
      CALL Bolom(UsL,UsbolL)                                                                        
      CALL Bolom(fsL,fsbolL)                                                                        
      CALL Bolom(UsR,UsbolR)                                                                        
      CALL Bolom(fsR,fsbolR)                                                                        
                                                                                                    
c      CALL Bolom(fsRp,fsRpbol)                                                                      
c      CALL Bolom(fsRm,fsRmbol)                                                                      
c =========================                                                                         
cc!   Added June 2007 [MN]
c     Fdiff scale output has to be found here if external heating is present [MN,'07]               
c     In case of central source and T1 input, the scale is found in Subroutine PrOut,               
c     since Fi is found from the solution in this case.                                             
c     Fout, Fdiff are stored in common /solution/                                                   
      IF (Right.EQ.1) THEN                                                                          
        CALL FdiffScale(m1p,ShpL,ShpR,pow,Fout,Fdiff)                                               
      ELSE                                                                                          
c       set the variables to 0 here, the values are found in PrOut                                  
        Fout = 0.0D+00                                                                                   
        Fdiff = 0.0D+00                                                                                  
      END IF                                                                                                                                                                                           
c =========================                                                                         
      error = 0                                                                                     
      goto 999                                                                                      
998   write(12,*)' *** FATAL ERROR IN DUSTY! *************************'                             
      write(12,*)' File with the spectral shape of external radiation:'                             
      write(12,'(a2,a70)')'  ',nameStar(1)                                                          
      write(12,*)' is missing or not properly formatted?!'                                          
      write(12,*)' ***************************************************'                             
      error = 3                                                                                     
                
      STOP                                                                                      
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c ***********************************************************************                           
      DOUBLE PRECISION function glam(iL)
c -----------------------------------------------------------------------                           
c  function glam
c     glam function from Moshe's notes
c     uses romberg integration of intg1 
c -----------------------------------------------------------------------                           
      implicit none
      INTEGER npY, npP, npX, npL, npG, npR                                                               
      include "userpar.inc"
      PARAMETER (npG=1)                                                                             

      INTEGER denstyp, Ntr, iterETA, nYEtaf                                                         
      CHARACTER*235 nameETA                                                                         
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                          
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),                                 
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                                                 
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                                      
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,                               
     &                  yEtaf                                                                       
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                                            

c ----
      REAL*8 tlam,mu_min,mu_max
      REAL*8 mu,Ymax,res1,res2
      integer iL,gilam,flg
      common /glamblock/mu,Ymax,gilam,flg
      external intg1
c      external intg2
c =======================================================================                           
c      write(6,*) ' function glam(il)'
      Ymax = Yout

      gilam = iL
      mu_min = 0.0D+00
      mu_max = 1.0D+00
c        glamintg1 = mu * exp(-tlam(mu))
         flg = 1
         call romby(intg1,mu_min,mu_max,res1)
         glam = res1
      return
      end
c ***********************************************************************                           

c ***********************************************************************                           
      DOUBLE PRECISION function integext(iL,yy,flag)
c ----------------------------------------------------------------------- 
c function integext
c    integration function for the external radition integrals 
c    mu*exp(-tau(mu)) d(mu) and exp(-tau(mu)) d(mu)   [MS Jun'07]                          
c ----------------------------------------------------------------------- 
      implicit none
      INTEGER npY, npP, npX, npL, npG, npR                                                               
      include "userpar.inc"
      PARAMETER (npG=1)                                                                             

      INTEGER denstyp, Ntr, iterETA, nYEtaf                                                         
      CHARACTER*235 nameETA                                                                         
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                          
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),                                 
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                                                 
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                                      
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,                               
     &                  yEtaf                                                                       
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                                            

c ----
      integer flag
      REAL*8 tlam,mu_min,mu_max,yy
      REAL*8 mu,Ymax,res1,res2
      integer iL,gilam,flg
      common /glamblock/mu,Ymax,gilam,flg
      external intg1
      external intg2
c =======================================================================                           
c      write(6,*) ' function glam(il)'
      Ymax = yy

      gilam = iL
      mu_min = 0.0D+00
      mu_max = 1.0D+00
      if(flag .eq. 1)then
c        glamintg1 = mu * exp(-tlam(mu))
c  flg = 1 do integral for tau(-)(mu) integral from -L to l
         flg = 1
         call romby(intg1,mu_min,mu_max,res1)
c  flg = 2 do integral for tau(+)(mu) integral from l to +L
         flg = 2
         call romby(intg1,mu_min,mu_max,res2)
c  integext = res1 +  (-1.0)*res2 because mu integration limits from 0 to 1
         integext = res1-res2
      else if (flag .eq. 0) then
c        glamintg2 = exp(-tlam(mu))
c  flg = 1 do integral for tau(-)(mu) integral from -L to l
         flg = 1
         call romby(intg2,mu_min,mu_max,res1)
c  flg = 2 do integral for tau(+)(mu) integral from l to +L
         flg = 2
         call romby(intg2,mu_min,mu_max,res2)
c  integext = res1 + (+1.0)*res2 no need for sign change because no mu in integrand
         integext = res1+res2

      else
          Write(6,'(a)') "Error incorrect flag for function Integext."
      endif
      return
      end
c ***********************************************************************                           

c ***********************************************************************                           
      DOUBLE PRECISION function intg1(mu)
c  function intg1
c     simple function form for romberg integration for the function
c       mu * exp(-tau(mu)) d(mu)
      implicit none
      real*8 mu,tlam

      intg1 = mu * dexp(-1.0d+0*tlam(mu))
      return
      end
c ***********************************************************************                           

c ***********************************************************************                           
      DOUBLE PRECISION function intg2(mu)
c  function intg2
c     simple function form for romberg integration for the function
c       exp(-tau(mu)) d(mu)
      implicit none
      real*8 mu,tlam

      intg2 = dexp(-1.0d+0*tlam(mu))
    
      return
      end
c ***********************************************************************                           
      
c ***********************************************************************                           
      Double precision function etatlam(l)
c  function etalam
c     simple function form for romberg integration for the function
c       tau(mu) 
      implicit none
      real*8 mu,Ymax
      integer gilam,flg
      common /glamblock/mu,Ymax,gilam,flg

      real*8 eta,r,l , arg  
c ------------------------------------------------------
c      r = dsqrt((1-mu**2.)*Ymax**2. + l**2.)
      arg = (1.0D+00-mu*mu)*Ymax*Ymax + l*l
      r = dsqrt(arg)
      etatlam=eta(r)
      return
      end
c ***********************************************************************                           
      

c ***********************************************************************                           
      DOUBLE PRECISION function tlam(muaux)
c Function tlam
c   sub function for the integration of exp(-tau(mu)) and mu exp(-tau(mu))
c   must be used in conjuction with the glam function or the common block
c   glamblock

c -----------------------------------------------------------------------                           
      implicit none
      INTEGER npY, npP, npX, npL, npG, npR                                                               
      include "userpar.inc"
      PARAMETER (npG=1)                                                                             

      INTEGER denstyp, Ntr, iterETA, nYEtaf                                                         
      CHARACTER*235 nameETA                                                                         
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                          
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),                                 
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                                                 
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                                      
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,                               
     &                  yEtaf                                                                       
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                                            

      INTEGER iLfid, szds, top, Nfiles                                                              
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),                               
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                                       
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                                       
     &     a1, a2, aveV, aveA                                                                       
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,                                  
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,                                
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles      

      REAL*8 Ymax,mu
      INTEGER gilam,flg
      common /glamblock/mu,Ymax,gilam,flg
c----------
      REAL*8 lmin,lmax,p,muaux,etatlam , arg
      REAL*8 res
      integer iL
      external etatlam
c =======================================================================                           
      mu = muaux
c      Ymax = Yout
      arg = 1.0D+00 - mu*mu
      IF(arg.LT.0.) THEN
        write(*,*)  'in tlam: Ymax,      mu,    1.-mu*mu'
        write(*,'(a6,1p,3e10.2)')'      ', Ymax, mu, arg
      END IF
      p = dsqrt(arg)*Ymax
c      write(6,*) '    mu,      Yout,      p,      mu*Yout'
c      write(6,'(1p,4e10.2)') mu, Yout, p, mu*Yout
      if(flg.eq.1)then
         arg = Yout*Yout-p*p
         lmin = -1.0d+0*dsqrt(arg)
         lmax = Ymax*mu
c        write(6,*)lmin,lmax,etatlam(lmin),etatlam(lmax)
c        write(6,*)'calling romby from tlam'
         call romby(etatlam,lmin,lmax,res)      
      else
         arg = Yout*Yout-p*p
         lmax = dsqrt(arg)
         lmin = Ymax*mu
c        write(6,*)lmin,lmax,etatlam(lmin),etatlam(lmax)
c        write(6,*)'calling romby from tlam'
         call romby(etatlam,lmin,lmax,res) 
      endif
c      if (mu .eq. 1.0) 
c      write(6,*)res,tautot(gilam),
c     c exp(-2*res*tautot(gilam))
      tlam = res*tautot(gilam)

      return
      end
c ***********************************************************************                           
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE FdiffScale(m1p,ShpL,ShpR,pow,Fout,Fdiff)                                           
c -----------------------------------------------------------------------                           
c     Calculate the scale of the shell's emission in case of external heating.                      
c     This subroutine has to be called from STAR. [MN'Apr'07]                                       
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd
       COMMON /constants/ Pi, sigma, Gconst, r_gd
      INTEGER npY, npP, npX, npL, npG, npR                                                               
      INCLUDE 'userpar.inc'                                                                         
      PARAMETER (npG=1)                                                                             
      INTEGER nY, nYprev, nP, nL, nPcav                                                             
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                                     
     &       bOut(npP+2)                                                                            
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                                     
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                                     
      INTEGER iLfid, szds, top, Nfiles                                                              
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),                               
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                                       
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                                       
     &     a1, a2, aveV, aveA                                                                       
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,                                  
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,                                
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                                      
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right                               
      CHARACTER nameStar(2)*235                                                                     
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),                              
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,                              
     &         dilutn, UsR(npL,npY)                                                                 
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,                               
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,                               
     &       nBB, typEntry, Left, Right, nameStar                                                   
      INTEGER iL                                                                                    
      DOUBLE PRECISION m1p(npL,npY), ShpL(npL), ShpR(npL),
     &        Faux(npL), Faux1(npL), Fi, Fout, Ftran, Fdiff, Ftran1,                                
     &        Fdiff1, Jo, pow, tau, t, trm, res, res1 , gl, glam                                          
c -----------------------------------------------------------------------                           
      Fi     = 0.0d+0
      Fout   = 0.0d+0
      Ftran  = 0.0d+0
      Ftran1 = 0.0d+0
      Fdiff  = 0.0d+0
      Fdiff1 = 0.0d+0

c     Find Fdiff for the external source first                                                      
        DO iL = 1, nL                                                                               

c -----------------------------------------------------------------------                           
C$$c         tau is tauV*qlam = TAUtot(iL)                                                             
C$$ccc          tau = TAUtot(iL)                                                                          
C$$c         gint is analytical integration for flat density profile                                   
C$$c          IF (pow.eq.0.0) THEN                                                                     
C$$c            For flat density profile use integration by parts:                                     
C$$ccc             t = 2.0*tau                                                                            
C$$ccc             trm = 1./t/t                                                                           
C$$c             glam(iL) = trm - (trm + 1./t)*dexp(-t)                                                
C$$c          ELSE                                                                                     
C$$c            For other density profiles take the value of m1p at the outer edge                     
C$$ccc             glam(iL) = m1p(iL,nY)                                                                  
C$$c          END IF                                                                                   
c -----------------------------------------------------------------------                           
                                                                                                    
c         function for lambda integration:                                                          
           gl = glam(iL)
           Faux(iL) = ShpR(iL)*gl / lambda(iL)                
        END DO                 
c        write(6,*)lambda(18),glam(18),tlam(1.0d+0)
        CALL Simpson(npL,1,nL,lambda,Faux,res)                                                      
c       Sub Bolom is for 2D arrays, Simpson is good for lambda integration                          
c       but note that all spectra are in lambda*f_lambda units                                      
c        write(6,*)res                                                                                            
c       Jo has to be found again, since only Teo is in common                                       
        Jo = sigma/Pi*Teo**4.0D+00                                                                       
c       this is transmitted flux - eq.(4) in notes                                                  
        Ftran = Pi*Jo * 2.0D+00*res                                                                     
c       this is diffuse shell emission - eq. (5)                                                    
        Fdiff = Pi*Jo * (1.0D+00 - 2.0D+00*res)                                                             
        Fout = Ftran + Fdiff                                                                        
                                                                                                    
c     If additional central source (in this case T1 can not be entered in input,                    
c     this is taken care of with typEntry(1).GE.2)                                                  
      IF (Left.eq.1 .AND. typEntry(1).GE.2) THEN                                                    
        DO iL = 1, nL                                                                               
           Faux1(iL) = ShpL(iL)*exp(-TAUtot(iL))/lambda(iL)                                         
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,Faux1,res1)                                                    
        Fi = sigma*Tei**4.0D+00                                                                          
c       add contribution of central source to shell at the outer boundary                           
        Fout =  Fdiff + Fi/Y(nY)/Y(nY)                                                              
        Ftran1 = Fi/Y(nY)/Y(nY)*res1                                                                
c       the central source contribution to diffuse flux                                             
        Fdiff1 = Fi/Y(nY)/Y(nY)*(1.0D+00 - res1)                                                         
c       the overall Fdiff has contributions from both external and central                          
        Fdiff = Fdiff + Fdiff1                                                                      
      END IF                                                                                        
                                                                                                    
      write(18,'(a6,F7.1)')  ' tauV=',TAUfid                                                        
      write(18,'(a16,1p,e10.3)')  'Fext,tran[W/m2]=',Ftran                                          
      write(18,'(a16,1p,e10.3)')  'Fc,tran[W/m2]  =',Ftran1                                         
      write(18,'(a16,1p,e10.3)')  'Fdiff[W/m2]    =',Fdiff                                          
      write(18,*) '----'                                                                            
      write(18,'(a15,1p,e10.3)')  ' Fout[W/m2]   =',Ftran+Ftran1+Fdiff                              
      write(18,'(a15,1p,e10.3)')  ' Fext,in[W/m2]=',Pi*Jo                                           
      write(18,'(a15,1p,e10.3)')  ' Fc,in[W/m2]  =',Fi                                              
      write(18,*) '---------------------------'                                                     
                                                                                                    
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE trapzd2(a,b,s,n)                                                                   
c =======================================================================                           
c This function integrates prescribed 8 functions from z=a to z=b with n                            
c divisions and stores the results to s(1..8). It is a heavily modified                             
c version of subroutine 'trapzd' (Num.Rec.'92).        [MN & ZI, Aug'96]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER it,iC,i,n,j                                                                           
      DOUBLE PRECISION s(8),a,b,funcx(8),funca(8),funcb(8),del,summ(8),                             
     &       tnm, x, ff, gp, gm                                                                     
c -----------------------------------------------------------------------                           
      IF (n.eq.1) then                                                                              
c       calculate auxiliary functions at a and at b                                                 
        CALL TWOFUN(a,ff,gp,gm)                                                                     
        funca(1) =  gm                                                                              
        funca(5) =  gp                                                                              
        DO iC = 2, 4                                                                                
            funca(iC) = funca(iC-1) * ff                                                            
            funca(4+iC) = funca(3+iC) * ff                                                          
        END DO                                                                                      
        CALL TWOFUN(b,ff,gp,gm)                                                                     
        funcb(1) =  gm                                                                              
        funcb(5) =  gp                                                                              
        DO iC = 2, 4                                                                                
          funcb(iC) = funcb(iC-1) * ff                                                              
          funcb(4+iC) = funcb(3+iC) * ff                                                            
        END DO                                                                                      
c       calculate integrals for all 8 functions                                                     
        DO i = 1, 8                                                                                 
          s(i) = 0.5D+00*(b-a)*(funca(i)+funcb(i))                                                      
        END DO                                                                                      
      ELSE                                                                                          
        it=2**(n-2)                                                                                 
        tnm=1.0D+00*(it)                                                                                
        del=(b-a)/tnm                                                                               
        x=a+0.5D+00*del                                                                                 
        DO i=1,8                                                                                    
          summ(i)=0.0D+00                                                                               
        END DO                                                                                      
c       calculate contributions of all 'it' divisions                                               
        DO j = 1, it                                                                                
c         auxiliary functions at x                                                                  
          CALL TWOFUN(x,ff,gp,gm)                                                                   
c         generate (8) integrated functions at x                                                    
          funcx(1) = gm                                                                             
          funcx(5) = gp                                                                             
          DO iC = 2, 4                                                                              
            funcx(iC) = funcx(iC-1) * ff                                                            
            funcx(4+iC) = funcx(3+iC) * ff                                                          
          END DO                                                                                    
          DO i=1,8                                                                                  
            summ(i)=summ(i)+funcx(i)                                                                
          END DO                                                                                    
c         next x                                                                                    
          x=x+del                                                                                   
        END DO                                                                                      
c       evaluate new value of the integral for all 8 cases                                          
        DO i=1,8                                                                                    
          s(i)=0.5D+00*(s(i)+(b-a)*summ(i)/tnm)                                                         
        END DO                                                                                      
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE TWOFUN(z,ff,gp,gm)                                                                 
c =======================================================================                           
c This function evaluates auxiliary functions needed in trapzd2.                                    
c                                           [MN & ZI,Aug'96; MN,Sep'97]                             
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER iLaux, iW1, iC                                                                        
      DOUBLE PRECISION paux, w1,wL,etaloc, w, IntETA, pp, delTAUzp, z,                              
     &        auxw, ff, gp, gm, gp1,gm1                                                             
      COMMON /phi2/ paux, w1, wL, delTAUzp, iLaux, iW1                                              
c -----------------------------------------------------------------------                           
c     local radius                                                                                  
      w = dsqrt(paux*paux + z*z)                                                                    
      IF (w.LT.w1) w = w1                                                                           
c     find local value for ETA function                                                             
      etaloc = 0.0D+00                                                                                  
      auxw = 1.                                                                                     
      DO iC = 1, 4                                                                                  
        etaloc = etaloc + ETAcoef(iW1,iC)*auxw                                                      
        auxw = auxw/w                                                                               
      END DO                                                                                        
c     ff, i.e. radial optical depth:                                                                
      pp = 0.0D+00                                                                                      
      ff = IntETA(pp,iW1,wL,w)*TAUtot(iLaux)                                                        
c     g functions:                                                                                  
      gp1 = dexp(IntETA(paux,iW1,w1,w)*TAUtot(iLaux)-delTAUzp)                                      
      gm1 = dexp(-IntETA(paux,iW1,w1,w)*TAUtot(iLaux))                                              
      gp = etaloc/w/w * gp1                                                                         
      gm = etaloc/w/w * gm1                                                                         
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE WEIGHTS(TAUaux,iP,iL,nZ,nY,alpha,beta,gamma,delta,                                 
     &                   wgp,wgm)                                                                   
c =======================================================================                           
c This subroutine calculates weights wgp(iZ,iY) and wgm(iZ,iY) for                                  
c integrations:                                                                                     
c INT(S(w)*exp(sign*ETAzp(iP,iZ')/w^2)dETAzp(iP,iZ')]                                               
c from ETAzp(iP,iZ) to ETAzp(iP,iZ+1), where w is local radius                                      
c corresponding to TAU(iP,iZ'), and sign=1 for wgp and -1 for wgm.                                  
c Integrals are evaluated as:                                                                       
c INT = wg(iZ,1)*S(1) + wg(iZ,2)*S(2) + ... + wg(iZ,nY)*S(nY) with                                  
c iZ=1..nZ-1. The method is based on approximation of S by cubic spline                             
c in radial optical depth given through matrices alpha, beta, gamma and                             
c delta (see MYSPLINE).                         [ZI,Dec'95;MN,Sep'97]                               
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iP, iL, nZ, nY, iW, iZ, j                                                             
      DOUBLE PRECISION alpha(npY,npY), beta(npY,npY), gamma(npY,npY),                               
     &        delta(npY,npY), TAUaux(npL,npP,npY), K1p(npY),K2p(npY),                               
     &        K3p(npY),K4p(npY), K1m(npY),K2m(npY),K3m(npY),K4m(npY),                               
     &        wgp(npY,npY), wgm(npY,npY), waux                                                      
c -----------------------------------------------------------------------                           
c     generate integrals of 'TAUr**n'                                                               
      CALL Kint4(TAUaux,iP,iL,nZ,K1p,K2p,K3p,K4p,K1m,K2m,K3m,K4m)                                   
c     loop over position on the line of sight                                                       
      DO iZ = 1, nZ                                                                                 
        iW = iYfirst(iP) + iZ - 1                                                                   
c       loop over radial position                                                                   
        DO j = 1, nY                                                                                
         IF (iZ.GT.1) THEN                                                                          
          waux = alpha(iW-1,j)*K1p(iZ) + beta(iW-1,j)*K2p(iZ)                                       
          wgp(iZ,j)=waux + gamma(iW-1,j)*K3p(iZ)+delta(iW-1,j)*K4p(iZ)                              
         ELSE                                                                                       
          wgp(1,j) = 0.0D+00                                                                            
         END IF                                                                                     
         IF (iZ.LT.nZ) THEN                                                                         
          wgm(iZ,j) = alpha(iW,j)*K1m(iZ) + beta(iW,j)*K2m(iZ)                                      
          wgm(iZ,j) = wgm(iZ,j)+gamma(iW,j)*K3m(iZ)+delta(iW,j)*K4m(iZ)                             
         ELSE                                                                                       
          wgm(nZ,j) = 0.0D+00                                                                           
         END IF                                                                                     
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Ygrid(pstar,iPstar,error)                                                          
c =======================================================================                           
c This subroutine generates the radial (Y) grid.                                                    
c Ncav is desired number of rays through the inner cavity (<=20), denstype                          
c is type of density law (see input file). Yout is the relative thickness,                          
c Yout=rout/r1. delTausc is maximum increase of the scaled optical depth                            
c tau/tauTot between two successive radial grid points and facc is the                              
c maximum ratio of their y coordinates. EtaRat is initialized in SUB Input                          
c and limits the ratio of two successive Eta(iY), in order to prevent                               
c nonphysical results in case of steep density distribution (pow>2). pstar is                       
c the impact parameter for star (0<=p<=1). First few points are prescribed                          
c arbitrarily. error is set to 1 if desired delTausc and facc result in too                         
c many points (> npY from userpar.inc). This subroutine calls function ETA                          
c which evaluates the normalized density profile.    [ZI, Nov'95; MN,Sep'99]                        
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER i, istop,error,iPstar, iter, iYdummy, iY, itr, j, ir, jY,                             
     &        irmax                                                                                 
      DOUBLE PRECISION pstar, dyR, dyT, ETA, aux, tausc, EtaTemp(npY),                              
     &       ee, Yloc, nh, fac, dyF, yold, ynew, y1, delY1, Ymid,                                   
     &       TAUloc, rat, dY, Etamin, Etamax                                                        
c -----------------------------------------------------------------------                           
c     max number iter. over improving ratio of two Eta's                                            
      irmax = 20                                                                                    
c     save old grid and values of Eta (important for denstyp = 5 or 6)                              
      IF (nY.GT.0.AND.(RDW)) THEN                                                                   
        DO iY = 1, nY                                                                               
          Yprev(iY) = Y(iY)                                                                         
          EtaTemp(iY) = ETAdiscr(iY)                                                                
        END DO                                                                                      
        nYprev = nY                                                                                 
      END IF                                                                                        
      pstar = pstar                                                                                 
      iPstar = iPstar                                                                               
      y1 = 1.0D+00                                                                                      
      iter = 0                                                                                      
101   error = 0                                                                                     
      iter = iter + 1                                                                               
c     resolve inner boundary in tau space                                                           
c     from requiring TAU(2) = TAUmax*ETA(1)*(Y(2)-1) =~ 1                                           
      Y(1) = y1                                                                                     
      IF (TAUmax*ETA(y1).GT.2000.0D+00) THEN                                                            
        delY1 = 2.0D+00 / TAUmax / ETA(y1)                                                              
      ELSE                                                                                          
        delY1 = 1.0D+00 / TAUmax / ETA(y1)                                                              
      END IF                                                                                        
c     if very thin generate at least about 10-15 pts.                                               
      IF (delY1.GT.0.01D+00/ETA(y1)) delY1 = 0.01D+00/ETA(y1)                                               
c     do not push it over the limit of spline stability                                             
      IF (delY1.LT.0.00005D+00) delY1 = 0.00005D+00                                                         
      i = 1                                                                                         
      istop = 0                                                                                     
      DO WHILE (istop.NE.1)                                                                         
        i = i + 1                                                                                   
        Y(i) = Y(i-1) + delY1                                                                       
        IF (Y(i).GT.facc*Y(i-1)) THEN                                                               
          Y(i) = facc * Y(i-1)                                                                      
        ELSE                                                                                        
          delY1 = 2.0D+00 * delY1                                                                        
        END IF                                                                                      
        Ymid = dsqrt(Y(i)*Y(i-1))                                                                   
        TAUloc = TAUmax * (Y(i)-1.0D+00) * ETA(Ymid)                                                    
        IF (Y(i).GE.1.01D+00.OR.TAUloc.GT.10.0D+00) istop = 1                                               
c       in case of shell thinner than 1.01 comment the above line and                               
c       uncomment the next line, unless it is a case of RDW at high TauV.                           
c       These require more points near the origin and 1.01 is a better limit.                       
c       IF (Y(i).GE.1.0001.OR.TAUloc.GT.10.0) istop = 1                                             
      END DO                                                                                        
      Ynew = Y(i)                                                                                   
c     some rule of thumb estimates for factor nh                                                    
      IF (TAUmax.GT.10000.0D+00) THEN                                                                   
c       extreme taus                                                                                
        nh = 15.0D+00                                                                                   
        Ncav = 80                                                                                   
      ELSE IF (TAUmax.GT.2000.0D+00) THEN                                                               
c         huge taus                                                                                 
          nh = 10.0D+00                                                                                 
          Ncav = 40                                                                                 
      ELSE IF (TAUmax.GT.400.0D+00) THEN                                                                
c         large taus                                                                                
          nh = 8.0D+00                                                                                  
          Ncav = 20                                                                                 
      ELSE                                                                                          
c         normal' taus                                                                              
          nh = 5.0D+00                                                                                  
          Ncav = 10                                                                                 
      END IF                                                                                        
c     very small taus                                                                               
      IF (TAUmax.LT.10.0D+00) nh = nh / 2.0D+00                                                             
      IF (TAUmax.LT.1.0D+00) nh = nh / 2.0D+00                                                              
c     empirically: ~1/r needs more points for small y:                                              
      IF ((pow-1.4D+00)*(pow-0.6D+00).LE.0.0D+00) nh = nh * 1.5D+00                                                 
c     same for for steep density distributions:                                                     
      IF (RDWA.OR.RDW) nh = nh * 1.5D+00                                                                
      tausc = ETA(Y(i))+ETA(Y(i-1))                                                                 
      tausc = (Y(i)-Y(i-1)) * 0.5D+00 * tausc                                                           
      fac = dexp(-dlog(tausc) / nh)                                                                 
      istop = 0                                                                                     
c     for broken power-laws                                                                         
      IF (Ntr.GE.1) THEN                                                                            
        itr = 1                                                                                     
        DO j = 1, i                                                                                 
          IF (Y(j).GE.Ytr(itr)) itr = itr + 1                                                       
        END DO                                                                                      
      END IF                                                                                        
c     generate the rest of Y grid points                                                            
      DO WHILE (istop.NE.1)                                                                         
        i = i + 1                                                                                   
        Yold = Ynew                                                                                 
c       find maximal increase in Y allowed by the ratio facc                                        
        dyR = Yold * (facc-1.0D+00)                                                                      
c       find maximal increase in Y allowed by delTausc                                              
        dyT = delTausc / ETA(Yold)                                                                  
c       find maximal increase in Y allowed by the ratio of tausc                                    
        dyF = tausc*(fac-1.0D+00) / ETA(Yold)                                                            
c       find new Y                                                                                  
c        Ynew = Yold + MIN(dyR,dyT,dyF)                                                             
        dY = MIN(dyR,dyT,dyF)                                                                       
c       Check if the max ratio btw. two Eta values is less than EtaRat                              
c       and insert additional y-pts. where necessary. This prevents sharp                           
c       drops in Utot(npL,npY) in case of steep Eta's [MN'99].                                      
        DO ir = 1 , irmax                                                                           
          Ynew = Yold + dY                                                                          
          rat = ETA(Yold)/ETA(Ynew)                                                                 
          IF(rat.GE.1./EtaRat .AND. rat.LE.EtaRat) goto 10                                          
          dY = 0.5D+00*dY                                                                               
        END DO                                                                                      
        CALL MSG(16)                                                                                
10      continue                                                                                    
        Y(i) = Ynew                                                                                 
c       make sure that all transition points are included in the grid                               
        IF (Ntr.GE.1) THEN                                                                          
         IF (Y(i).GE.Ytr(itr)) THEN                                                                 
           Y(i) = Ytr(itr)                                                                          
           Ynew = Y(i)                                                                              
           itr = itr + 1                                                                            
         END IF                                                                                     
        END IF                                                                                      
        aux = ETA(Ynew)+ETA(Yold)                                                                   
        aux = (Ynew-Yold) * 0.5D+00 * aux                                                               
        tausc = tausc + aux                                                                         
c       finish when Yout is reached                                                                 
        IF (Ynew.GE.Yout) istop = 1                                                                 
      END DO                                                                                        
      Y(i) = Yout                                                                                   
      nY = i                                                                                        
c     insert additional penultimate point to avoid spline oscillations                              
      Y(nY+1) = Yout                                                                                
      Y(nY) = dsqrt(Y(nY)*Y(nY-1))                                                                  
      nY = nY + 1                                                                                   
c     check that outer edge is well resolved in tau space                                           
c     (important for flat ETAs)                                                                     
      istop = 0                                                                                     
      DO WHILE (istop.NE.1)                                                                         
        IF ((Yout-Y(nY-1))*TAUmax*ETA(Yout).GT.1.0) THEN                                            
          Y(nY+1) = Yout                                                                            
          Y(nY) = dsqrt(Y(nY)*Y(nY-1))                                                              
          nY = nY + 1                                                                               
        ELSE                                                                                        
          istop = 1                                                                                 
        END IF                                                                                      
      END DO                                                                                        
c     check dynamical range of Eta to avoid nonphysical results or code errors [                    
      Etamax = 0.0D+00                                                                                   
      Etamin = 1.0D+20                                                                               
      DO iY = 1, nY                                                                                 
       IF(ETA(Y(iY)).lt.Etamin) Etamin = ETA(Y(iY))                                                 
       IF(ETA(Y(iY)).gt.Etamax) Etamax = ETA(Y(iY))                                                 
       IF (ETA(Y(iY)).LT.1.D-12) THEN                                                               
        IF (iX.GT.0) THEN                                                                           
         write(18,*)'      Y          ETA  '                                                        
         DO jY = 1, nY                                                                              
           write(18,'(1p,2e12.3)') Y(jY),ETA(Y(jY))                                                 
         END DO                                                                                     
        END IF                                                                                      
        CALL MSG(17)                                                                                
        error = 6                                                                                   
        iERROR = iERROR + 1                                                                         
        goto 102                                                                                    
       END IF                                                                                       
      END DO                                                                                        
      IF ((Etamin/Etamax).LT.1.0D-12) THEN                                                           
       CALL MSG(18)                                                                                 
       error = 6                                                                                    
       iERROR = iERROR + 1                                                                          
       goto 102                                                                                     
      END IF                                                                                        
c !!!!!!!!! this is to take the radial grid as in user supplied density file                        
cc!    IF (FILD) THEN                                                                                
cc!       take the radial grid as in density profile file [MN,Apr'02]                                 
cc!       nY = nYEtaf                                                                                
cc!       DO iY = 1, nY                                                                              
cc!           Y(iY) = yEtaf(iY)                                                                      
cc!       END DO                                                                                    
cc!     END IF                                                                                       
c !!!!!!!!!                                                                                         
c     check that the Y grid is not too large                                                        
      IF (nY.GT.npY) THEN                                                                           
        delTAUsc = delTAUsc * 1.5D+00                                                                   
        iWARNING = iWARNING + 1                                                                     
        IF (iX.NE.0) THEN                                                                           
        IF (iter.EQ.1) call line(0,2,18)                                                            
        write(18,'(a)')                                                                             
     &  ' ****************   WARNING   *******************'                                         
        write(18,'(a46,i3)')                                                                        
     &             ' Initial delTAUsc resulted in too many points:',nY                              
        write(18,'(a,i3,a)')' You need to increase npY in userpar.inc'                              
        write(18,*)'Multiplying delTAUsc by 1.5 and trying again'                                   
        write(18,'(a14,1p,e10.3)')' New delTAUsc:',delTAUsc                                         
        END IF                                                                                      
        IF (iter.LT.5) THEN                                                                         
          goto 101                                                                                  
        ELSE                                                                                        
          IF (iX.NE.0) THEN                                                                         
            write(18,'(a)')                                                                         
     &            ' ****************  GIVING UP  *******************'                               
            call line(0,2,18)                                                                       
          END IF                                                                                    
          error = 2                                                                                 
          goto 102                                                                                  
        END IF                                                                                      
      END IF                                                                                        
c     intepolate ETAdiscr to new Y grid (for RDW (denstyp=5 or 6))                                  
c      write(18,*)' ***** From Ygrid *****'                                                         
c      write(18,*)'      Y      ETAdiscr      '                                                     
      DO iY = 1, nY                                                                                 
        Yloc = Y(iY)                                                                                
        IF (iterETA.GT.1) THEN                                                                      
          CALL LinInter(npY,nYprev,Yprev,EtaTemp,Yloc,iYdummy,ee)                                   
          ETAdiscr(iY) = ee                                                                         
        ELSE                                                                                        
          ETAdiscr(iY) = ETA(Yloc)                                                                  
        END IF                                                                                      
c        write(18,'(1p,2e12.4)')Y(iY), ETAdiscr(iY)                                                 
      END DO                                                                                        
c      write(18,*)' *************************'                                                      
c -----------------------------------------------------------------------                           
102   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c =========================================================================                         
c     These are the subroutines analyzing the solution         [MN, Mar'99]                         
c =========================================================================                         
C     Table of Contents                                                                             
C                                                                                                   
C     ANALYSIS                                                                                      
C     ASSPROP                                                                                       
C     BOLOM                                                                                         
C     CHKBOLOM                                                                                      
C     CHKCONV                                                                                       
C     CHKFLUX                                                                                       
C     CONVERG1                                                                                      
C     CONVERG2                                                                                      
C     CONVOLVE                                                                                      
C     CONV2D                                                                                        
C     ETA                                                                                           
C     ETAFUN                                                                                        
C     FINDINT                                                                                       
C     GETBOUT                                                                                       
C     GETOMEGA                                                                                      
C     GETOPTPR                                                                                      
C     GETPROP                                                                                       
C     GETSIZES                                                                                      
C     GETTAU                                                                                        
C     GETETAZP                                                                                      
C     IMAGFN                                                                                        
C     MIE                                                                                           
C     PSFN                                                                                          
C     SETUPETA                                                                                      
C     SIZEDIST                                                                                      
C     SPECTRAL                                                                                      
C     SPFEATUR                                                                                      
C     PHILAM                                                                                        
C     VISIBILI                                                                                      
C     VISI2D                                                                                        
c =======================================================================                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ANALYSIS(model,ETAzp,error)                                                        
c =======================================================================                           
c This subroutine analyzes the solution. It finds the flux conservation                             
c accuracy and evaluates many output quantites (e.g. QF(y), TAUF(y),Psi, F1                         
c the rad.pressure force, dynamical quantities etc.)                                                
c This is with new additions acc. to IE'00           [ZI,Mar'96;MN,Mar'99]                          
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER ver                                                               
      DOUBLE PRECISION ugas(npY), qF(npY), vrat(npG,npY), Gamma(npY),           
     &       I1, I2, I3, CMdot, Cve, CM, Cr1, G1, Ginf, Prdw, delta,            
     &       winf, Phi, PIrdw, QV, q_star, zeta1, tauFdyn(npY)                  
      COMMON /dyn/ ugas, qF, vrat, Gamma, I1, I2, I3, CMdot, Cve, CM,           
     &       Cr1, G1, Ginf, Prdw, delta, winf, Phi, PIrdw, QV, q_star,          
     &       zeta1, tauFdyn, ver                                                
                                                                                
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iL, iY, model, iP, error                                                              
      DOUBLE PRECISION ETAzp(npP,npY), QpTd(npG,npY), QpStar(npY), Psi,                             
     &        qaux(npL), qaux2(npL), resaux, xP, Planck, QUtot1,                                    
     &        Eps1, aux, C1, C2, C3, theta1, ugas_out, s4, mx,                                      
     &        tauV, Gie2000, K1(npY), K2(npY)                                                       
c -----------------------------------------------------------------------                           
c     make sure that grids correspond to accepted solution                                          
      nY = nYok                                                                                     
      DO iY = 1, nY                                                                                 
        Y(iY) = Yok(iY)                                                                             
      END DO                                                                                        
      nP = nPok                                                                                     
      DO iP = 1, nP                                                                                 
        P(iP) = Pok(iP)                                                                             
      END DO                                                                                        
c -------------                                                                                     
c     spectrum (flux at the outer edge as a function of wavelength)                                 
      DO iL = 1, nL                                                                                 
        Spectrum(iL) = dabs(ftot(iL,nY))                                                            
c       added in version dusty16.for - to prevent taking log from zero                              
c       in Spectral [MN]:                                                                           
        IF (Spectrum(iL).LE.1.0D-20) Spectrum(iL) = 1.0D-20                                         
      END DO                                                                                        
c -------------                                                                                     
c     analyze bolometric flux error (1/2 of the max spread of fbol)                                 
      CALL FindErr(fbol,maxFerr,nY)                                                                 
                                                                                                    
c     find the flux averaged optical depth, tauF(y)                                                 
      IF (denstyp.NE.0) THEN                                                                        
c       for spherical shell                                                                         
        tauF(1) = 0.0D+00                                                                               
        DO iY = 2, nY                                                                               
c         generate auxiliary function for integration:                                              
c         loop over iL (wavelength)                                                                 
c         N.B. the definition: ETAzp(1,y) = taur(y)/tauT so that                                    
c         tau(iL,iY) = TAUtot(iL)*ETAzp(1,iY)                                                       
          DO iL = 1, nL                                                                             
            qaux(iL)=TAUtot(iL)*ETAzp(1,iY)*dabs(ftot(iL,iY))/lambda(iL)                            
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                 
c         tauF(iY) = <tau(iL,iY)*ftot(iL,iY)>                                                       
          tauF(iY) = resaux                                                                         
        END DO                                                                                      
c       for full RDW calculation redo tauF to be consistent with CalcEta                            
        IF (RDW) THEN                                                                               
c          generate ETA and its integral (normalization constant)                                   
           DO iY = 1, nY                                                                            
              K1(iY) = vrat(1,iY)/ugas(iY)/Y(iY)/Y(iY)                                              
           END DO                                                                                   
           CALL SIMPSON(npY,1,nY,Y,K1,resaux)                                                       
c          find tauF                                                                                
           DO iY = 1, nY                                                                            
              K2(iY) = qF(iY)*K1(iY)/resaux                                                         
              CALL SIMPSON(npY,1,iY,Y,K2,aux)                                                       
              tauF(iY) = TAUfid*aux                                                                 
           END DO                                                                                   
        END IF                                                                                      
      ELSE                                                                                          
c       for slab                                                                                    
        tauF(1) = 0.0D+00                                                                               
        DO iY = 1, nY                                                                               
c         generate auxiliary function for integration:                                              
c         loop over iL (wavelength)                                                                 
          DO iL = 1, nL                                                                             
            qaux(iL)=TAUslb(iL,iY)*dabs(fTot(iL,iY))/lambda(iL)                                     
            CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                               
            tauF(iY) = resaux                                                                       
          END DO                                                                                    
        END DO                                                                                      
      END IF                                                                                        
c -------------                                                                                     
c     ratio of gravitational to radiation pressure force (isotropic                                 
c     scattering) per unit volume                                                                   
c     s4 = (L4sol/Msol)/(4*Pi*G*c*rho_s)/1D-6;                                                      
c     rho_s=3000 kg.m-3, grain radius 'a' is in microns, aveV=4/3*Pi*<a^3>                          
      IF(denstyp.NE.0) THEN                                                                         
      s4 = 1.925D+00 / (4.0D+00*Pi*Gconst*3.0D+008*3000.0D+00*1.0D-06)                                            
c      in case of sigma's from a file aveV=1 (initialized in GetOptPr)                              
       DO iY = 1, nY                                                                                
        DO iL = 1, nL                                                                               
          qaux(iL)=(SigmaA(1,iL)+SigmaS(1,iL))/aveV *                                               
     &                             dabs(ftot(iL,iY))/lambda(iL)                                     
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                   
        rg(1,iY) = s4 * resaux / r_gd                                                               
c       If dust drift (dynamics case):                                                              
        IF (RDW) rg(1,iY) = rg(1,iY)*vrat(1,iY)                                                     
        IF (iY.EQ.1) THEN                                                                           
            Phi = resaux                                                                            
        END IF                                                                                      
       END DO                                                                                       
c      the terminal value of the reddening profile, normalized to y=1                               
        Phi = resaux / Phi                                                                          
      END IF                                                                                        
c -------------                                                                                     
c     find the Planck averaged absorption efficiencies                                              
      DO iY = 1, nY                                                                                 
c     generate auxiliary function for integration over wavelengths:                                 
       DO iL = 1, nL                                                                                
         qaux(iL) = SigmaA(1,iL) * Us(iL,iY) / lambda(iL)                                           
         xP = 14400.0D+00 / Td(1,iY) / lambda(iL)                                                       
         qaux2(iL) = SigmaA(1,iL) * Planck(xP) / lambda (iL)                                        
       END DO                                                                                       
       CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                    
       QpStar(iY) = resaux                                                                          
       CALL Simpson(npL,1,nL,lambda,qaux2,resaux)                                                   
       QpTd(1,iY) = resaux                                                                          
      END DO                                                                                        
c ----------                                                                                        
c     find parameter Psi (see Ivezic & Elitzur, 1996)                                               
c     generate auxiliary function for integration:                                                  
c     loop over iL (wavelength)                                                                     
      DO iL = 1, nL                                                                                 
        qaux(iL) = SigmaA(1,iL) * Utot(iL,1) / lambda (iL)                                          
      END DO                                                                                        
      CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                     
      QUtot1 = resaux                                                                               
      Psi = QUtot1 / QpTd(1,1)                                                                      
c     for slab Psi is defined by the flux at normal ill.                                            
      IF (SLB) Psi = dabs(mu1)*QUtot1 / QpTd(1,1)                                                   
c -------------                                                                                     
      IF(denstyp.NE.0) THEN                                                                         
c      ratio r1/r* (see Ivezic & Elitzur, 1996, eq. 27)                                             
       r1rs = 0.5D+00 * dsqrt(Psi) * (Tstar(1) / Td(1,1))**2.0D+00                                          
       IF(Left.eq.0) r1rs = 1.0D+00                                                                     
      END IF                                                                                        
c -------------                                                                                     
c     Find epsilon - the relative contribution of the diffuse radiation                             
      DO iY = 1, nY                                                                                 
       aux = QpStar(iY)/QpTd(1,iY)/Psi*(Td(1,1)/Td(1,iY))**4.0D+00                                       
       IF (SLB) THEN                                                                                
         aux = aux*dabs(mu1)                                                                        
       ELSE                                                                                         
         aux = aux/ Y(iY)/Y(iY)                                                                     
       END IF                                                                                       
       Eps(iY) = 1.0D+00 - aux                                                                           
      END DO                                                                                        
      Eps1 = 1.0D+00 - QpStar(1) / QUtot1                                                               
c     store these parameters in the storage array                                                   
      SmC(1,model) = Psi                                                                            
      SmC(2,model) = Eps1                                                                           
      SmC(3,model) = QpStar(1)                                                                      
      SmC(4,model) = QpTd(1,1)                                                                      
      SmC(5,model) = maxFerr                                                                        
c -------------                                                                                     
c     additional output quantities                                                                  
c     bolometric flux at r1 (in W/m2)                                                               
      IF (typEntry(1).EQ.1) THEN                                                                    
c       The constant is 4*Sigma*1000^4 (2.27E5 = 4*5.67D-08*1000**4)                                
        Fi = 2.27D+5 / Psi * (Tsub(1)/1000.0D+00)**4.0D+00                                                    
      ELSE                                                                                          
        IF(Left.eq.0) THEN                                                                          
           Fi = Ubol(1)*4.0D+00*sigma*(Y(nY)*Teo**2.0D+00)**2.0D+00                                                
        ELSE                                                                                        
           Fi = sigma*Tei**4.0D+00                                                                       
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
c     inner radius (in cm) in case it is not an input                                               
c     5.53E16 = sqrt(10^4*Lo/4/Pi)                                                                  
      IF (typEntry(1).NE.3) THEN                                                                    
        IF(SLB) THEN                                                                                
c         r1 is found from Fi = L/(4*pi*r1^2). Since in sub Input                                   
c         Fi=Fi*mu1, here the mu1 dependence has to be removed                                      
          Cr1 =  5.53D+16 / dsqrt(Fi/abs(mu1))                                                       
        ELSE                                                                                        
          Cr1 = 5.53D+16 / dsqrt(Fi)                                                                 
        END IF                                                                                      
      END IF                                                                                        
                                                                                                    
      IF (denstyp.NE.0) THEN                                                                        
c      angular diameter of inner cavity if Fbol=1D-6 W/m2                                           
       theta1 = 412.6D+00 / dsqrt(Fi)                                                                   
c      check if the pt.source assumption is still obeyed                                            
c      (only for BB-type spectrum including EM-function)                                            
       IF(startyp(1).eq.1.OR.startyp(1).eq.2) THEN                                                  
         mx = sqrt(sqrt(Fi/sigma))                                                                  
         Te_min = 2.0D+00 * DMAX1(Td(1,1), mx)                                                           
       END IF                                                                                       
      END IF                                                                                        
      IF (SLB) THEN                                                                                 
c       Teff for the left illuminating source in slab geometry                                      
c       Teff = (Fi/sigma)^0.25D+00                                                                      
        SmC(7,model) = Tei                                                                          
        IF (ksi.GT.0.) THEN                                                                         
c       Teff for the right illuminating source in slab geometry                                     
           SmC(8,model) = SmC(7,model)*sqrt(sqrt(ksi))                                              
        ELSE                                                                                        
           SmC(8,model) = 0.0D+00                                                                        
        END IF                                                                                      
      END IF                                                                                        
c     calculate conversion constants for dynamics                                                   
      IF (RDWA.OR.RDW) THEN                                                                         
c       for analytical approximation                                                                
c       (otherwise I1,2,3 are found in Gammafun)	                                                   
        IF (RDWA) THEN                                                                              
          I1 = 2.0D+00 * (1.0D+00-pow)/(1.0D+00+pow)/tauF(nY)                                                      
          I2 = I1                                                                                   
          I3 = I1 * tauF(nY) / TAUfid                                                               
          Gamma(nY) = 0.5D+00                                                                           
        END IF                                                                                      
c       terminal expansion velocity, full formula:                                                  
        ugas_out = tauF(nY) * (1.0D+00-Gamma(nY)) / (1.0D+00-pow)                                             
c       The coefficients come from the units conversion                                             
        C1 = 0.2845D+00*TAUfid*sqrt(Psi)/I2/(SigExfid/aveV)*                                            
     &                                      1.0D+006/Td(1,1)/Td(1,1)                                  
        C2 = 2.040D+00*ugas_out                                                                         
        C3 = 6.628D+00*I3*SigExfid/aveV*Gamma(nY)/I1                                                    
c       from version 2.0 stellar mass is defined as the maximal stellar                             
c       mass which does not quench the wind; the calculation is done                                
c       with half that mass since any smaller mass will have no effect                              
c       on the radial velocity and density profile (see IE2000)                                     
c       n.b. erroneous Gamma(nY) is removed                                                         
        CM = 6.628D+00*I3*SigExfid/aveV/I1                                                              
c       new definitions for output                                                                  
c       mass-loss rate in Msol/yr                                                                   
        CMdot = 1.0D-05 * sqrt(C1)                                                                  
c       terminal expansion velocity in km/s                                                         
        Cve = 10.0D+00* C2 / sqrt(C1)                                                                    
c       *** this is conversion to the nomenclature as in IE2001                                     
        IF (denstyp.EQ.6) THEN                                                                      
c        IF (RDW) THEN                                                                              
c          size averaged extinction efficiency                                                      
           QV = SigExfid / aveA                                                                     
           tauV = TAUfid                                                                            
           q_star = qF(1)                                                                           
           zeta1 = vrat(1,1)                                                                        
           G1 = Gamma(1)                                                                            
           Ginf = Gamma(nY)                                                                         
           IF (G1.GT.0.0D+00) THEN                                                                        
              Gie2000 = 1.0D+00 / zeta1 / G1                                                              
              delta = 1.0D+00 / (Gie2000 - 1.0D+00)                                                             
           ELSE                                                                                     
              delta = 0.0D+00                                                                           
           END IF                                                                                   
           PIrdw = tauV / QV                                                                        
           Prdw = dsqrt(2.D+00*PIrdw/I2/QV/q_star)                                                        
           winf = ugas_out / QV / q_star                                                            
        END IF                                                                                      
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE AssProp(NN,nin,kin,nout,kout)                                                      
c =======================================================================                           
c This subroutine copies arrays nin and kin to nout and kout,                                       
c respectively.                                        [Z.I., Nov. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NN, i                                                                                 
      DOUBLE PRECISION nin(NN), kin(NN), nout(NN), kout(NN)                                         
c -----------------------------------------------------------------------                           
      DO i = 1, NN                                                                                  
        nout(i) = nin(i)                                                                            
        kout(i) = kin(i)                                                                            
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE BOLOM(q,qBol)                                                                      
c =======================================================================                           
c This subroutine integrates given radiation field, q (function of                                  
c wavelength and radial coordinate), over wavelength. q is a matrix                                 
c of physical size (npL,npY) [coming from paramet.inc] and real size                                
c (nL,nY) [coming from grids.inc], and qBol is an array of physical size                            
c (npY) and real size nY.                              [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iL, iY                                                                                
      DOUBLE PRECISION q(npL,npY), qaux(npL), qBol(npY), resaux                                     
c -----------------------------------------------------------------------                           
c    loop over iY (radial coordinate)                                                               
      DO iY = 1, nY                                                                                 
c       generate auxiliary function for integration                                                 
c       loop over iL (wavelength)                                                                   
        DO iL = 1, nL                                                                               
          qaux(iL) = q(iL,iY) / lambda (iL)                                                         
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                   
        qBol(iY) = resaux
c        write(6,'(E12.3)')resaux
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ChkBolom(qbol,accur,dev,FbolOK)                                                    
c =======================================================================                           
c This subroutine checks if any element of qbol(i), i=1,nY differs for                              
c more than accuracy from the median value fmed. If so FbolOK = 0,                                  
c otherwise FbolOK = 1. dev is maximal deviation from fmed. [ZI,'96;MN'00]                          
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iY, FbolOK                                                                            
      DOUBLE PRECISION qBol(npY), accur, dev, fmax,fmed,AveDev,RMS                                  
c -----------------------------------------------------------------------                           
      FbolOK = 1                                                                                    
      dev = 0.0D+00                                                                                     
c     loop over iY (radial coordinate)                                                              
      CALL SLBmisc(qBol,fmax,fmed,AveDev,RMS,nY)                                                    
                                                                                                    
      DO iY = 1, nY                                                                                 
        IF (abs(fmed-qBol(iY)).GT.accur) FbolOK = 0                                                 
        IF (abs(fmed-qBol(iY)).GT.dev) dev = abs(fmed-qBol(iY))                                     
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ChkConv(nY,accuracy,Aold,Anew,Aconv)                                               
c =======================================================================                           
c This subroutine checks convergence of an array A(nY) between values                               
c given in Aold and Anew. If the relative difference for EVERY element                              
c is smaller than accuracy, Aconv is assigned 1, otherwise 0.                                       
c                                                      [Z.I., Jul. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, iY, Aconv                                                                         
      DOUBLE PRECISION accuracy, Aold(npY), Anew(npY), delta                                        
c -----------------------------------------------------------------------                           
      Aconv = 1                                                                                     
c     loop over radial positions                                                                    
      DO iY = 1, nY                                                                                 
c       find relative difference                                                                    
        delta = dabs(Anew(iY)-Aold(iY))                                                             
        IF (delta.GT.dabs(Anew(iY))*accuracy) Aconv = 0                                             
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ChkFlux(flux,tolern,consfl,error,ETAzp)                                            
c =======================================================================                           
c Checks the bolometric flux conservation at any point of a given Ygrid.                            
c In case of nonconservation increases the number of points at certain                              
c places. The current criterion is increasing the flux difference from                              
c tolern to its maximum value.                         [MN & ZI,July'96]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER iYins(npY), k, kins, iY, consfl, flag, error, istop, iDm                              
      DOUBLE PRECISION Yins(npY),flux(npY), tolern, ff, Yloc,                                       
     &       delTAUMax, devfac, devmax, ffold, EtaTemp(npY),ee,                                     
     &       ETA, ETAzp(npP,npY), fmax, fmed, AveDev, RMS                                           
c -----------------------------------------------------------------------                           
c     save old grid and values of Eta (important for denstyp = 5 or 6)                              
      IF (RDW) THEN                                                                                 
        DO iY = 1, nY                                                                               
          Yprev(iY) = Y(iY)                                                                         
          EtaTemp(iY) = ETAdiscr(iY)                                                                
        END DO                                                                                      
        nYprev = nY                                                                                 
      END IF                                                                                        
      IF(Right.gt.0) THEN                                                                           
c      Find fmed - the median value of the bol.flux                                                 
c      (if there is an external source fbol < 1)                                                    
       CALL SLBmisc(flux,fmax,fmed,AveDev,RMS,nY)                                                   
      ELSE                                                                                          
        fmed = 1.0D+00                                                                                  
      END IF                                                                                        
      error = 0                                                                                     
      kins = 0                                                                                      
      devmax = 0.0D+00                                                                                  
c     maximal delTAU is no more than 2 times the average value                                      
      delTAUmax = 2.0D+00*TAUtot(1)*ETAzp(1,nY)/nY                                                      
c     maximal deviation from fmed                                                                   
      DO iY = 2, nY                                                                                 
        IF (dabs(flux(iY)-fmed).GT.devmax) devmax = dabs(flux(iY)-fmed)                             
      END DO                                                                                        
      ff = 0.0D+00                                                                                      
      istop = 0                                                                                     
      devfac = 0.1D+00                                                                                  
c     search for places to improve the grid                                                         
      DO WHILE (istop.NE.1)                                                                         
        DO iY = 2, nY                                                                               
          ffold = ff                                                                                
          ff = dabs(flux(iY) - fmed)                                                                
          flag = 0                                                                                  
c         if any of these criteria is satisfied insert a point:                                     
c         1) if error is increasing too fast                                                        
          IF (abs(ff-ffold).GT.devfac*devmax) flag = 1                                              
c         2) if delTAU is too large                                                                 
          IF (TAUtot(1)*(ETAzp(1,iY)-ETAzp(1,iY-1)).GT.                                             
     &                             delTAUmax) flag = 1                                              
          IF(flag.EQ.1.AND.devmax.GE.tolern) THEN                                                   
            kins = kins + 1                                                                         
            Yins(kins) = Y(iY-1)+0.5D+00*(Y(iY)-Y(iY-1))                                                
            iYins(kins) = iY-1                                                                      
          END IF                                                                                    
        END DO                                                                                      
        IF (devmax.LT.tolern.OR.devfac.LT.0.01D+00) THEN                                                
          istop = 1                                                                                 
          ELSE                                                                                      
          IF (kins.GT.0) istop = 1                                                                  
        END IF                                                                                      
        devfac = devfac / 2.0D+00                                                                       
      END DO                                                                                        
      IF (kins.EQ.0) THEN                                                                           
        IF (consfl.NE.5) consfl = 1                                                                 
      ELSE                                                                                          
c       Add all new points to Y(nY). This gives the new Y(nY+kins).                                 
c       However, check if npY is large enough to insert all points:                                 
        IF ((nY+kins).GT.npY) THEN                                                                  
c        consfl.EQ.5 is a signal that Chkflux was called from SetGrids,                             
c        in this case continue without inserting new points. If this is                             
c        full problem then give it up.                                                              
         IF (consfl.NE.5) THEN                                                                      
           consfl = 1                                                                               
           ELSE                                                                                     
           consfl = 7                                                                               
           goto 777                                                                                 
         END IF                                                                                     
         IF (iX.GE.1) THEN                                                                          
         write(18,*)' ****************     WARNING   ******************'                            
         write(18,*)'  The new Y grid can not accomodate more points!'                              
         write(18,'(a,i3)')'   Specified accuracy would require',nY+kins                            
         write(18,'(a,i3,a)')'   points, while npY =',npY,'.'                                       
         write(18,*)'  For the required accuracy npY must be increased,'                            
         write(18,*)'  (see the manual S3.5 Numerical Accuracy).'                                   
         write(18,*)' *************************************************'                            
         END IF                                                                                     
         kins = npY - nY                                                                            
         iWARNING = iWARNING + 1                                                                    
         error = 2                                                                                  
        END IF                                                                                      
        DO k = 1, kins                                                                              
          CALL SHIFT(Y,npY,nY+k-1,Yins(k),iYins(k)+k-1)                                             
        END DO                                                                                      
      END IF                                                                                        
c     new size of the Y grid                                                                        
      nY = nY + kins                                                                                
c     intepolate ETAdiscr to new Y grid for denstyp = 5 or 6                                        
      DO iY = 1, nY                                                                                 
        Yloc = Y(iY)                                                                                
        IF (iterETA.GT.1) THEN                                                                      
          CALL LinInter(npY,nYprev,Yprev,EtaTemp,Yloc,iDm,ee)                                       
          ETAdiscr(iY) = ee                                                                         
          ELSE                                                                                      
          ETAdiscr(iY) = ETA(Yloc)                                                                  
        END IF                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
777   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Converg1(nY,accuracy,dynrange,Aold,Anew,Aconv,dmax)                                
c =======================================================================                           
c This subroutine checks convergence of an array A(nL,nY) between values                            
c given in Aold and Anew, when the values are larger than dynrange. If                              
c the maximum relative difference is smaller than the required accuracy,                            
c Aconv is assigned 1, otherwise 0.              [Z.I.Jul 96;M.N.Apr.97]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, iY, Aconv                                                                         
      DOUBLE PRECISION accuracy, dynrange, Aold(npY), Anew(npY), delta,                             
     &       dmax                                                                                   
c -----------------------------------------------------------------------                           
      Aconv = 1                                                                                     
      dmax = 0.0D+00                                                                                    
c     loop over radial positions                                                                    
      DO iY = 1, nY                                                                                 
c       do it only for elements larger than dynrange                                                
        IF (Anew(iY).GE.dynrange) THEN                                                              
c           find relative difference                                                                
            delta = dabs((Anew(iY)-Aold(iY))/Anew(iY))                                              
            IF (delta.GT.dmax) dmax = delta                                                         
        END IF                                                                                      
      END DO                                                                                        
      IF (dmax.GT.accuracy) Aconv = 0                                                               
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Converg2(nY,nL,accuracy,dynrange,Aold,Anew,Aconv,dmax)                             
c =======================================================================                           
c This subroutine checks convergence of an array A(nL,nY) between values                            
c given in Aold and Anew, when the values are larger than dynrange. If                              
c the maximum relative difference is smaller than required accuracy,                                
c Aconv is assigned 1, otherwise 0.             [Z.I.Jul 96; M.N.Apr.97]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nL, iY, iL, Aconv                                                                 
      DOUBLE PRECISION accuracy, dynrange, Aold(npL,npY), Anew(npL,npY),                            
     &       delta, dmax                                                                            
c -----------------------------------------------------------------------                           
      Aconv = 1                                                                                     
      dmax = 0.0D+00                                                                                    
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       loop over radial positions                                                                  
        DO iY = 1, nY                                                                               
c         do it only for elements larger than dynrange                                              
          IF (Anew(iL,iY).GE.dynrange) THEN                                                         
c           find relative difference                                                                
            delta = dabs((Anew(iL,iY)-Aold(iL,iY))/Anew(iL,iY))                                     
            IF (delta.GT.dmax) dmax = delta                                                         
          END IF                                                                                    
        END DO                                                                                      
      END DO                                                                                        
      IF (dmax.GT.accuracy) Aconv = 0                                                               
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Convolve(IntOut)                                                                   
c =======================================================================                           
c This subroutine convolves intensity IntOut with the point spread                                  
c function to produce convolved images ConvInt. The work horse is                                   
c subroutine Conv2D, and this subroutine is used to prepare everything.                             
c                                                      [Z.I., Jan. 1997]                            
c Changed normalization of convolved images: instead of profiles normalized                         
c at the center, now the convolved intensities are normalized by the area                           
c A = 2*pi*Int{psf(x)*x}dx                             [MN, 2005]                                   
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
      INTEGER i, j                                                                                  
      DOUBLE PRECISION IntOut(20,npP+2), yang(npP+2), Youtang, deltaOff,                            
     &       Int1D(npP+2), ConvS, Conv(npP+2), FWHM1max, FWHM2max, PSFN,                            
     &       PSFN1, psf_Y(1000), psf_X(1000), res                                                   
c -----------------------------------------------------------------------                           
c     find the largest FWHMs                                                                        
      FWHM1max = FWHM1(1)                                                                           
      FWHM2max = FWHM2(1)                                                                           
      IF (psftype.LT.3) THEN                                                                        
        DO i = 1, NlambdaOut                                                                        
          IF (FWHM1(i).GT.FWHM1max) FWHM1max = FWHM1(i)                                             
          IF (FWHM2(i).GT.FWHM2max) FWHM2max = FWHM2(i)                                             
        END DO                                                                                      
      END IF                                                                                        
c     scale angular coordinate to theta1                                                            
      DO i = 1, nP+2                                                                                
        yang(i) = bOut(i) * Theta1 / 2.0D+00                                                             
      END DO                                                                                        
c     generate off-set grid                                                                         
      Youtang = Y(nY) * Theta1                                                                      
      IF (Youtang.GT.FWHM1max.AND.Youtang.GT.FWHM2max) THEN                                         
c       the envelope is well resolved, take impact parameter grid                                   
        Nconv = nP + 2                                                                              
        DO i = 1, Nconv                                                                             
          Offset(i) = yang(i)                                                                       
        END DO                                                                                      
      ELSE                                                                                          
c       the envelope is not well resolved, take equidistant grid                                    
c       to 2FWHM1max, i.e. image will be more or less the PSF itself                                
        Nconv = 30                                                                                  
        deltaOff = 2.0D+00 * FWHM1max / (Nconv-1)                                                       
        IF (FWHM2max.GT.FWHM1max) THEN                                                              
          deltaOff = 2.0D+00 *FWHM2max / (Nconv-1)                                                      
        END IF                                                                                      
        DO i = 1, Nconv                                                                             
          Offset(i) = deltaOff * 1.0D+00*(i-1)                                                          
        END DO                                                                                      
      END IF                                                                                        
                                                                                                   
c !!!!!!!!!!!!!added normalization of psf, PSFN1(x) is the original fn                              
c     psfArea(iLambda) b/c the Gaussian option allows FWHM(iLambda)                                 
      write(12,'(a36)')'  lambdaOut(mic)   psfArea(arcsec^2)'
      DO iLambda = 1, NlambdaOut                                                                    
        DO i = 1, Nconv                                                                             
          psf_X(i) = Offset(i)                                                                          
          psf_Y(i) = PSFN(Offset(i))                                                                
          CALL CHKRANGE(dynrange,psf_Y(i))                                                          
        END DO                                                                                      
c        CALL ScaleTo1(1000,Nconv,psf_Y)                                                            
        CALL ScaletoArea(1000,Nconv,psf_X,psf_Y,res)                                                
c       now for ea. lambda psf_Y is normalized to Area                                              
        psfArea(iLambda) = res                                                                      
        write(12,'(1p,2e15.3)') lambdaOut(iLambda), psfArea(iLambda)                                   
                                                                                                    
        j = iLambda                                                                                      
c       generate 1D intensity vector for subroutine Conv2D                                          
c       take only diffuse emission, stellar contribution will                                       
c       be added below (a shortcut to avoid inaccuracies or too many                                
c       points in Conv2D)                                                                           
        DO i = 1, nP+2                                                                              
          IF (i.LE.2) THEN                                                                          
            Int1D(i) = IntOut(j,3)                                                                  
          ELSE                                                                                      
            Int1D(i) = IntOut(j,i)                                                                  
          END IF                                                                                    
          CALL CHKRANGE(dynrange,Int1D(i))                                                          
          IF (Int1D(i).LT.dynrange) Int1D(i)=0.0D+00                                                    
        END DO                                                                                      
c       convolve                                                                                    
        CALL Conv2D(npP+2,nP+2,yang,Int1D,1000,NConv,Offset,Conv)                                   
                                                                                                    
        DO i = 1, Nconv                                                                             
          CALL CHKRANGE(dynrange,Conv(i))                                                           
          ConvInt(j,i) = Conv(i)                                                                    
        END DO                                                                                      
                                                                                                    
c       add stellar contribution                                                                    
        DO i = 1, nP+2                                                                              
          ConvS=2.0D+00*ASIN(1.0D+00)*(yang(2)**2.0D+00)*
     &                          IntOut(j,1)*PSFN(Offset(i))                              
          Conv(i) = Conv(i) + ConvS                                                                 
        END DO                                                                                      
c       scale to 1 at the center                                                                    
c        CALL ScaleTo1(1000,Nconv,Conv)                                                             
c       copy 1D convolved intensity to ConvInt                                                      
c       ConvInt is normalized to area in Sub PrOut                                                  
        DO i = 1, Nconv                                                                             
          CALL CHKRANGE(dynrange,Conv(i))                                                           
          ConvInt(j,i) = Conv(i)                                                                    
        END DO                                                                                      
c      end do over iLambda - lambda for conv,images                                                 
      END DO                                                                                        
      write(12,*)' --------------------------------------------'                                                                                                               
c      STOP                                                                                         
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Conv2D(NinMax,Nin,Xin,Yin,Noutmax,Nout,Xout,Yout)                                  
c =======================================================================                           
c This subroutine convolves intensity Yin(Xin[i]), i=1,Nin with                                     
c the point spread function PSFN(x) (provided as a separate function).                              
c It is assumed that both the intensity yin and PSFN(x) are circularly                              
c symmetric functions of radial coordinate x, i.e., this subroutine                                 
c performs two-dimensional convolution. Convolved intensity, Yout, is                               
c evaluated for very position Xout[i], i=1,Nout, as:                                                
c        Yout(Xout) = Int[Yin(yloc)*PSF(xloc)*yloc*dyloc*dphi]                                      
c where xloc = sqrt(yloc **2+Xout**2-2*yloc*Xout*cos(phi), with yloc                                
c and phi being dummy integration variables. Declared size of Xin is                                
c NinMax, the one for Xout is NoutMax. The radial integration is done                               
c using subroutine ROMBY and angular integration is done by using                                   
c Simpson rule.                                        [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NinMax, Nin, NoutMax, Nout, iphi, iXin, Nphi, iXOut                                   
      DOUBLE PRECISION Xin(NinMax), Yin(NinMax), Xout(NoutMax), A, B,                               
     &       Yout(NoutMax), dphi, phi(1000), fphi(1000), int1, int2,                                
     &       imagfn                                                                                 
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
      INTEGER ftype                                                             
      DOUBLE PRECISION Ckn, Cxout, Cphi, Cqtheta                                
      COMMON /imfn1/ ftype                                                      
      COMMON /imfn2/ Ckn, Cxout, Cphi, Cqtheta                                  
      EXTERNAL imagfn                                                                               
c -----------------------------------------------------------------------                           
c     Parameters for integration:                                                                   
c     number of angular points                                                                      
      Nphi = 9                                                                                      
c     step in angle phi                                                                             
      dphi = 2.0D+00*ASIN(1.0D+00) / (Nphi-1)                                                               
c     flag for imgfn                                                                                
      ftype = 1                                                                                     
c     Start integrations                                                                            
c     loop over output positions                                                                    
      DO iXout = 1, Nout                                                                            
        Cxout = Xout(iXout)                                                                         
c       loop over angular wedges (phi integration)                                                  
        DO iphi = 1, Nphi                                                                           
          phi(iphi) = dphi*1.0D+00*(iphi-1)                                                             
          Cphi = phi(iphi)                                                                          
          fphi(iphi) = 0.0D+00                                                                          
c         loop over input radial positions (radial integration)                                     
          DO iXin = 1, Nin-1                                                                        
            Ckn = 1.0D+00                                                                               
            CALL ROMBY(imagfn,Xin(iXin),Xin(iXin+1),int1)                                           
            Ckn = 2.0D+00                                                                               
            CALL ROMBY(imagfn,Xin(iXin),Xin(iXin+1),int2)                                           
c           contribution from this annulus (lin. approx. for intensity)                             
            A = Xin(iXin+1)*Yin(iXin) - Xin(iXin)*Yin(iXin+1)                                       
            A = A / (Xin(iXin+1)-Xin(iXin))                                                         
            B = (Yin(iXin+1)-Yin(iXin)) / (Xin(iXin+1)-Xin(iXin))                                   
            fphi(iphi) = fphi(iphi) + A*int1 + B*int2                                               
          END DO                                                                                    
        END DO                                                                                      
        CALL Simpson(1000,1,Nphi,phi,fphi,Yout(iXout))                                              
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION ETA(Yy)                                                             
c =======================================================================                           
c This subroutine evaluates the normalized density profile. denstype is                             
c a type of density law: 1 and 2 - power law, 3 for exponential density law,                        
c 4 for radiatively driven winds (the gray-body approximation), 5,6 - RDW and                       
c 7 - d.d.from a file. pow is parameter describing the choosen density law:                         
c power for 1 and 2, v1/v8 for RDW (the ratio of expansion velocities at the                        
c inner and outer radii), sigma for 3 [i.e. rho = dexp(-(y/sigma)**2)].                             
c Yout is the relative thickness, Yout=rout/r1. Y is the radial position.                           
c                                                          [ZI'95; ZI'99]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER i, istop, iYdummy                                                                     
      DOUBLE PRECISION Yy, C, IntAux, powaux, Prod, eps, factEta                                    
c -----------------------------------------------------------------------                           
c     this is an adjustable value regulating the initial Eta approximation                          
c     for dynamics                                                                                  
      factEta = 0.5D+00                                                                                 
      IF (Yy.GT.Yout) Yy = Yout                                                                     
      IF (iterETA.GT.1) THEN                                                                        
c     if this is iteration over ETA (but not the first one) in the case                             
c     of dynamical calculation for radiatively driven winds calculate                               
c     ETA by linear interpolation of ETA from the previous iteration                                
      CALL LinInter(npY,nYprev,Yprev,ETAdiscr,Yy,iYdummy,ETA)                                       
c     otherwise use prescribed formulae for different cases                                         
      ELSE                                                                                          
c     smooth power-law                                                                              
      IF (denstyp.EQ.1) THEN                                                                        
c       find normalization constant                                                                 
        IF (pow.NE.1.0D+00) THEN                                                                        
          C = (1.0D+00 - Yout**(1.0D+00-pow)) / (pow - 1.0D+00)                                                 
          ELSE                                                                                      
          C = dlog(Yout)                                                                            
        ENDIF                                                                                       
        IF (Ntr.GE.1) THEN                                                                          
          DO i = 1, Ntr                                                                             
            powaux = pow - ptr(i)                                                                   
            IF (powaux.NE.1.0D+00) THEN                                                                 
              IntAux =(1.0D+00-Yout**(1.0D+00-powaux))/(powaux-1.0D+00)                                  
            ELSE                                                                                    
              IntAux = dlog(Yout)                                                                   
            END IF                                                                                  
            C = C + IntAux / Ytr(i)**ptr(i)                                                         
          END DO                                                                                    
        ENDIF                                                                                       
        C = 1.0D+00 / C                                                                                 
c       calculate density                                                                           
        IF (Yy.GE.(1.0D+00-1.0D-08)) THEN                                                                
          ETA = C / Yy**pow                                                                         
          IF (Ntr.GE.1) THEN                                                                        
            DO i = 1, Ntr                                                                           
              ETA = ETA + C * Yy**(ptr(i)-pow) / Ytr(i)**ptr(i)                                     
            END DO                                                                                  
          END IF                                                                                    
          ELSE                                                                                      
          ETA = 0.0D+00                                                                                 
        ENDIF                                                                                       
      END IF                                                                                        
c     broken power-law                                                                              
      IF (POWD) THEN                                                                                
        Ytr(Ntr+1) = Yout                                                                           
c       find normalization constants                                                                
        IF (pow.NE.1.0) THEN                                                                        
          C = (1.0D+00 - Ytr(1)**(1.0D+00-pow)) / (pow - 1.0D+00)                                               
        ELSE                                                                                        
          C = dlog(Ytr(1))                                                                          
        ENDIF                                                                                       
        IF (Ntr.GE.1) THEN                                                                          
          DO i = 1, Ntr                                                                             
            CALL DoProduct(10,Ytr,ptr,pow,i,Prod)                                                   
            IF (ptr(i).NE.1.0D+00) THEN                                                                 
              IntAux=Ytr(i)**(1.0D+00-ptr(i))-Ytr(i+1)**(1.0D+00-ptr(i))                                
              IntAux=Prod * IntAux / (ptr(i) - 1.0D+00)                                               
            ELSE                                                                                    
              IntAux = Prod * dlog(Ytr(i+1)/Ytr(i))                                                 
            END IF                                                                                  
            C = C + IntAux                                                                          
          END DO                                                                                    
        ENDIF                                                                                       
        C = 1.0D+00 / C                                                                                 
c       calculate density                                                                           
        IF (Yy.GE.1.0D+00-1.0D-8) THEN                                                                  
          IF (Yy.LE.Ytr(1)) THEN                                                                    
            ETA = C / Yy**pow                                                                       
          ELSE                                                                                      
            istop = 0                                                                               
            i = 0                                                                                   
            DO WHILE (istop.NE.1)                                                                   
              i = i + 1                                                                             
              IF (Yy.LE.Ytr(i+1)) istop = 1                                                         
            END DO                                                                                  
            CALL DoProduct(10,Ytr,ptr,pow,i,Prod)                                                   
            ETA = C * Prod / Yy**ptr(i)                                                             
          END IF                                                                                    
        ELSE                                                                                        
          ETA = 0.0D+00                                                                                 
        ENDIF                                                                                       
      END IF                                                                                        
c     exponential law                                                                               
      IF (EXPD) THEN                                                                                
        IF (Yy.GE.1.0D+00-1.0D-8) THEN                                                                  
          ETA = (Yout-1.) * (1.0D+00-dexp(-pow)) / pow                                                    
          ETA = dexp(-pow*(Yy-1.0D+00)/(Yout-1.0D+00)) / ETA                                                   
        ELSE                                                                                        
          ETA = 0.0D+00                                                                                 
        END IF                                                                                      
      END IF                                                                                        
c     radiatively driven winds (the gray-body approximation)                                        
      IF (RDWA) THEN                                                                                
        eps = pow                                                                                   
        IF (Yy.GE.1.0D+00-1.0D-8) THEN                                                                  
          ETA = (1.0D+00+eps)/2.0D+00/Yy/Yy/
     &                           sqrt(1.0D+00-(1.0D+00-eps*eps)/Yy)                                          
        ELSE                                                                                        
          ETA = 0.0D+00                                                                                 
        ENDIF                                                                                       
      END IF                                                                                        
c     radiatively driven winds (i.e. denstyp=3 or 6)                                                
       IF (RDW) THEN                                                                                
c       if this is the first iteration use analytic approximation                                   
        IF (iterETA.LT.2) THEN                                                                      
c         for 3 eps is pow, for 6 assume eps=0.1                                                    
          IF (denstyp.eq.3) THEN                                                                    
            eps = pow                                                                               
          ELSE                                                                                      
            eps = 0.1D+00                                                                               
          END IF                                                                                    
          IF (Yy.GE.(1.0D+00-1.0D-8)) THEN                                                              
            ETA = (1.0D+00+eps)/2.0D+00/Yy/Yy/
     &                       sqrt(1.0D+00-(1.0D+00-eps*eps)/Yy)                                        
c           empirical improvement for the initial approximation                                     
c           good only for large optical depths, but small ones                                      
c           are fast anyway (ZI, May99)                                                             
            IF (Yy.LE.2.0D+00) THEN                                                                       
               ETA = ETA / (1.0D+00 + factEta / Yy**10.0D+00)                                                 
            END IF                                                                                  
          ELSE                                                                                      
            ETA = 0.0D+00                                                                               
          ENDIF                                                                                     
c       or interpolate from the previous solution                                                   
        ELSE                                                                                        
          CALL LinInter(npY,nYprev,Yprev,ETAdiscr,Yy,iYdummy,ETA)                                   
        END IF                                                                                      
      END IF                                                                                        
c     user specified function for ETA                                                               
      IF (FILD) THEN                                                                                
        IF (Yy.LT.yEtaf(nYEtaf)) THEN                                                               
          CALL LinInter(npY,nYEtaf,yEtaf,Etaf,Yy,iYdummy,ETA)                                       
        ELSE                                                                                        
          ETA = Etaf(nYEtaf)                                                                        
        END IF                                                                                      
      END IF                                                                                        
c     done                                                                                          
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION ETAfun(iL,Y)                                                        
c =======================================================================                           
c This subroutine evaluates the normalized density profile as a function                            
c of position and wavelength (in multigrain case). The MAIN purpose of                              
c this function is to provide connection between the overall, prescribed                            
c density distribution, ETA, and wavelength depedent function ETAfun.                               
c It is NOT FINISHED, this is a trivial case, works only for single                                 
c grains.                                              [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER iL                                                                                    
      DOUBLE PRECISION Y, eta                                                                       
c -----------------------------------------------------------------------                           
c     this is temporary, works only for single component grains                                     
c     I need to add subroutines/functions to take care of temperature                               
c     dependent and thus variable condensation radii for different                                  
c     components                                                                                    
      ETAfun = ETA(Y)                                                                               
c     this is to avoid warning when compiling:                                                      
      iL = iL                                                                                       
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE FindInt(nG,ETAzp)                                                                  
c =======================================================================                           
c This subroutine finds the intensity distribution at outer edge and for                            
c user specified wavelengths lamOut. It also evaluates the angular size                             
c of the stellar disk and adds two impact parameters describing the star                            
c to the P grid, thus producing bOut grid. All intensities are indeed                               
c dimensionless quantities lambda*I_lambda/F1 where I_lambda is real                                
c physical quantity defined as usual and F1 is the bolometric flux at                               
c the dust sublimation radius, r1. For conversion to the physical value                             
c lambda*I_lambda, I_lambda from the program has to be multiplied by F1.                            
c F1 can obtained either as:                                                                        
c      1) F1 = 4*sigma*Tsub**4/Psi (IE96, eq. 15),                                                  
c where Tsub is sublimation temperature and parameter Psi is given in                               
c *.spp file; or as:                                                                                
c      2) F1 = Fbol/alpha1**2 (IE96, eq. 34)                                                        
c where Fbol is the bolometric flux and alpha1 is the angular size of r1                            
c at any particular distance from the envelope (i.e. both F1 and alpha1                             
c correspond to observed quantities). Also note that                                                
c     INT(I_lambda(p)*2Pi*P*dP) = f_lambda                                                          
c where I_lambda is the scaled quantity from the program, P is impact                               
c parameter, and f_lambda is the spectral shape F_lambda/Fbol.                                      
c                                                      [Z.I., Aug. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iL,nG,iY,k,i,iLout,iLstop, iP, iW, nZ, Nzpt, iZ, izloc                                
      DOUBLE PRECISION qaux(npL), Psi, alpha(1,npY), resaux, QUtot1,                                
     &       QpTsub, xP, pst, stelfact, Istell(npL), Planck, w1,                                    
     &       IntL, IntR, xx , alb, Ids(npL,npP), Ide(npL,npP),w2, lw12,                             
     &       ETAzp(npP,npY), numcorr, ETAzpStar, qaux2(npL), z1, z2,                                
     &       delz, zloc, wloc, resint, pT, Tz, Idboth, tzp(100), pUtot,                             
     &       Semis(100), Sscat(100), IntETA, palb, palf, alfa, exterm,                              
     &       Utotloc, Sstem(100), Sstsc(100), Istem(npL,100), Idfront,                              
     &       Istsc(npL,100), delTau, factaux, UtotL, UtotR, ep1,                                    
     &       tauzp1, tauInf, fnum(npL), fdenum(npL), res, denum                                     
c -----------------------------------------------------------------------                           
c     temporary                                                                                     
      IF (nG.GT.1.AND.iX.GE.1) THEN                                                                 
        write(18,*)' FindInt should be fixed, nG>1 !'                                               
        stop                                                                                        
      END IF                                                                                        
c     find impact parameter tangential to the stellar disk                                          
c     first find the Planck averaged absorption efficiencies at Y=1                                 
      DO iL = 1, nL                                                                                 
        qaux(iL) = SigmaA(1,iL) * Utot(iL,1) / lambda (iL)                                          
        xP = 14400.0D+00 / Td(1,1) / lambda(iL)                                                         
        qaux2(iL) = SigmaA(1,iL) * Planck(xP) / lambda (iL)                                         
      END DO                                                                                        
      CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                     
      QUtot1 = resaux                                                                               
      CALL Simpson(npL,1,nL,lambda,qaux2,resaux)                                                    
      QpTsub = resaux                                                                               
c     parameter Psi (see Ivezic & Elitzur, 1996, eq. C4)                                            
      Psi = QUtot1 / QpTsub                                                                         
      alpha(1,1) = Psi                                                                              
c ***alpha is a local array, to match the changes with Zeljko's old expressions                     
      DO iY = 2, nY                                                                                 
c       calculate f1 and f2                                                                         
        DO iL = 1, nL                                                                               
          fnum(iL) = SigmaA(1,iL) * Utot(iL,iY) / lambda(iL)                                        
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,fnum,res)                                                      
c        calculate alpha                                                                            
        DO iL = 1, nL                                                                               
           xP = 14400.0D+00 / lambda(iL) / Td(1,iY)                                                     
           fdenum(iL) = SigmaA(1,iL) * Planck(xP) / lambda(iL)                                      
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,fdenum,denum)                                                  
        alpha(1,iY) = res /  denum                                                                  
      END DO                                                                                        
c *********                                                                                         
c     ratio pst = rstar/rsub (see Ivezic & Elitzur, 1996, eq. 27)                                   
c     Added Apr.07 [MN] to take care of the case of no central source
      IF (Left.eq.0) THEN
         pst = 1.0D+00
      ELSE
         pst = 2.0D+00 / dsqrt(Psi) * (Td(1,1) / Tstar(1))**2.0D+00            
      END IF
c      IF (pst.GE.0.5) THEN                                                                         
c     this is if only central source is present                                                     
      IF (pst.GE.0.5D+00.AND.Right.eq.0) THEN                                                           
         IF (iX.GE.1) THEN                                                                          
            write(18,*)' FindInt: specified dust temperature at the '                               
            write(18,*)' inner radius results in r*/r1 >= 0.5: '                                    
            write(18,*)'    r*/r1 =', pst                                                           
            write(18,*)' This violates some of Dusty`s assumptions'                                 
            write(18,*)'  ------  Please consult the manual ------'                                 
            write(18,*)'  ####  r*/r1 changed by hand to 0.5  ####'                                 
         END IF                                                                                     
         pst = 0.5D+00                                                                                  
      END IF                                                                                        
      stelfact = 1.0D+00 / pst / pst / Pi                                                               
c     generate bOut, i.e. insert two points such that                                               
c     bOut(k)=0.999*pst and bOut(k+1)=1.001*pst                                                     
      CALL GetbOut(npP,nP,P,pst,bOut,k)                                                             
c     correction for numerical errors in tau                                                        
      numcorr = 1.0D+00 / TAUtot(1)                                                                      
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c        stellar intensity, Istell (extinction already included)                                    
         Istell(iL) = fs(iL,nY) * stelfact                                                          
c        total optical depth along a line of sight                                                  
         tauOut(iL) = numcorr*TAUtot(iL)                                                            
      END DO                                                                                        
                                                                                                    
c     generate diffuse intensities, Ide (emission) and Ids (scat)                                   
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
        DO iP = 1, nP                                                                               
c         maximal number of points along tangential position, z                                     
          nZ = nY + 1 - iYfirst(iP)                                                                 
c         starting value for local radius                                                           
          IF (P(iP).GE.1.0D+00) THEN                                                                    
            w2 = P(iP)                                                                              
          ELSE                                                                                      
            w2 = 1.0D+00                                                                                
          END IF                                                                                    
c         initialize intensities                                                                    
          Ide(iL,iP) = 0.0D+00                                                                          
          Ids(iL,iP) = 0.0D+00                                                                          
          IF (iP.LE.k+1) THEN                                                                       
            Istem(iL,iP) = 0.0D+00                                                                      
            Istsc(iL,iP) = 0.0D+00                                                                  
          END IF                                                                                    
c         total optical depth along this impact parameter                                           
          ep1 = ETAzp(iP,nY+1-iYfirst(iP))*TAUtot(iL)                                               
c         loop over z, i.e. steps over points crossing the y grid                                   
          DO iZ = 2, nZ                                                                             
c           index for the ending local radius                                                       
            iW = iYfirst(iP) + iZ - 1                                                               
c           local boundary radii                                                                    
            w1 = w2                                                                                 
            w2 = Y(iW)                                                                              
c           corresponding displacements along a line of sight                                       
            z1 = dsqrt(abs(w1**2.0D+00-P(iP)**2.0D+00))                                                        
            z2 = dsqrt(abs(w2**2.0D+00-P(iP)**2.0D+00))                                                        
c           # of pts. for z integration, should increase with deltaTau                              
c           it is messy because INT function which would do the job is                              
c           not in F77 standard set                                                                 
            Nzpt = 5                                                                                
            delTau = (ETAzp(iP,iW)-ETAzp(iP,iW-1))*TAUtot(iL)                                       
            IF (delTau.GT.1.0D+00) Nzpt = 10.0D+00                                                              
            IF (delTau.GT.5.0D+00) Nzpt = 20.0D+00                                                              
            IF (delTau.GT.10.0D+00) Nzpt = 30.0D+00                                                             
            IF (delTau.GT.20.0D+00) Nzpt = 40.0D+00                                                             
            IF (delTau.GT.50.0D+00) Nzpt = 50.0D+00                                                             
            delz = (z2-z1) / (Nzpt-1)                                                               
c           powers for power-law interpolations between 2 y pts.                                    
            lw12 = dlog(Y(iW-1)/Y(iW))                                                              
c           for T                                                                                   
            pT = dlog(Td(1,iW)/Td(1,iW-1)) / lw12                                                   
c           for albedo                                                                              
            IF (omega(iL,iW-1).GT.0.0D+00
     &                   .AND.omega(iL,iW).GT.0.0D+00) THEN                                 
              palb = dlog(omega(iL,iW)/omega(iL,iW-1)) / lw12                                       
            ELSE                                                                                    
              palb = 0.0D+00                                                                            
            END IF                                                                                  
c           for Utot                                                                                
            UtotL = Utot(iL,iW-1)                                                                   
            UtotR = Utot(iL,iW)                                                                     
            CALL CHKRANGE(dynrange,UtotL)                                                           
            CALL CHKRANGE(dynrange,UtotR)                                                           
            IF (UtotL.GT.0.0D+00.AND.UtotR.GT.0.0D+00) THEN                                                   
              pUtot = dlog(UtotR/UtotL) / lw12                                                      
            ELSE                                                                                    
              pUtot = 0.0D+00                                                                           
            END IF                                                                                  
c           for alpha                                                                               
            palf = dlog(alpha(1,iW)/alpha(1,iW-1)) / lw12                                           
c           tauzp between z=0 and z=z1                                                              
            tauzp1 = ETAzp(iP,iZ-1)*TAUtot(iL)                                                      
c           integrate between adjacent grid points                                                  
            DO izloc = 1, Nzpt                                                                      
              zloc = z1 + (izloc-1)*delz                                                            
              wloc = dsqrt(zloc**2.0D+00 + P(iP)**2.0D+00)                                                       
c             find local TAUzp(w(z))-TAUzp(w1=w(z1))                                                
              tzp(izloc) = IntETA(P(iP),iW-1,w1,wloc)*TAUtot(iL)                                    
c             find Tz = T(zloc) = T(wloc), this works for single                                    
c             size grains only; for multigrain case one needs to                                    
c             get Semis by summation over all Td                                                    
              Tz = Td(1,iW-1) * (Y(iW-1)/wloc)**pT                                                  
              xP = 14400.0D+00/lambda(iL)/Tz                                                              
c             power-law interpolation for albedo                                                    
              alb = omega(iL,iW-1) * (Y(iW-1)/wloc)**palb                                           
c             power-law interpolation for Utot                                                      
              IF (UtotL.GT.0.0D+00) THEN                                                                  
                UtotLoc = UtotL * (Y(iW-1)/wloc)**pUtot                                             
              ELSE                                                                                  
                UtotLoc = 0.0D+00                                                                       
              END IF                                                                                
              CALL CHKRANGE(dynrange,UtotLoc)                                                       
c             power-law interpolation for alpha                                                     
              alfa = alpha(1,iW-1) * (Y(iW-1)/wloc)**palf                                           
c             source functions (wloc**2 because D uses scaled quant.)                               
              factaux = 1.0D+00 / wloc**2.0D+00 / (4.0D+00 * Pi)                                                     
              Semis(izloc) = (1.0D+00-alb) * alfa * Planck(xP) * factaux                                  
              Sscat(izloc) = alb * UtotLoc * factaux                                                
c             check for the dynamic range                                                           
              CALL CHKRANGE(dynrange,Semis(izloc))                                                  
              CALL CHKRANGE(dynrange,Sscat(izloc))                                                  
c             optical depth from infinity along the line of sight                                   
              tauInf = ep1 - tauzp1 - tzp(izloc)                                                    
c             for a line of sight terminating on the star find                                      
c             contribution only from the front part of the envelope                                 
              IF (iP.LE.k+1) THEN                                                                   
                 IF (tauInf.LT.50.0D+00) THEN                                                             
                   exterm = dexp(-tauInf)                                                           
                 ELSE                                                                               
                   exterm = 0.0D+00                                                                     
                 END IF                                                                             
                 Sstem(izloc) = Semis(izloc) * exterm                                               
                 Sstsc(izloc) = Sscat(izloc) * exterm                                               
              END IF                                                                                
c             otherwise take both the front and back contributions                                  
              IF (tauInf.LT.50.0D+00) THEN                                                                
                 exterm = dexp(-tauInf)+dexp(-tauInf-ep1)                                           
              ELSE                                                                                  
                 exterm = 0.0D+00                                                                       
              END IF                                                                                
              Semis(izloc) = Semis(izloc) * exterm                                                  
              Sscat(izloc) = Sscat(izloc) * exterm                                                  
c             end of local loop over z                                                              
            END DO                                                                                  
c           integrate and add contribution from this step                                           
            CALL SIMPSON(100,1,Nzpt,tzp,Semis,resint)                                               
            CALL CHKRANGE(dynrange,resint)                                                          
            Ide(iL,iP) = Ide(iL,iP) + resint                                                        
            CALL SIMPSON(100,1,Nzpt,tzp,Sscat,resint)                                               
            CALL CHKRANGE(dynrange,resint)                                                          
            Ids(iL,iP) = Ids(iL,iP) + resint                                                        
            IF (iP.LE.k+1) THEN                                                                     
              CALL SIMPSON(100,1,Nzpt,tzp,Sstem,resint)                                             
              CALL CHKRANGE(dynrange,resint)                                                        
              Istem(iL,iP) = Istem(iL,iP) + resint                                                  
              CALL SIMPSON(100,1,Nzpt,tzp,Sstsc,resint)                                             
              CALL CHKRANGE(dynrange,resint)                                                        
              Istsc(iL,iP) = Istsc(iL,iP) + resint                                                  
            END IF                                                                                  
c         end of loop over z                                                                        
          END DO                                                                                    
c       end of loop over impact parameter, iP                                                       
        END DO                                                                                      
c     end of loop over wavelengths, iL                                                              
      END DO                                                                                        
c     add all intensities, Istell, Ide, Ids                                                         
      DO iL = 1, nL                                                                                 
c       interpolate optical depth  at pstar                                                         
        IF (iL.EQ.iLfid) THEN                                                                       
          ETAzpStar = (ETAzp(k,nY) - ETAzp(k-1,nY))                                                 
          ETAzpStar = ETAzpStar * (pst-P(k-1)) / (P(k)-P(k-1))                                      
          ETAzpStar = ETAzp(k-1,nY) + ETAzpStar                                                     
        END IF                                                                                      
c       find diffuse contribution at pstar (by linear interpolation)                                
        Idfront = Istsc(iL,k)+Istem(iL,k)-Istsc(iL,k-1)-Istem(iL,k-1)                               
        Idfront = Idfront * (pst-P(k-1)) / (P(k) - P(k-1))                                          
        Idfront = Idfront + Istsc(iL,k-1) + Istem(iL,k-1)                                           
        Idboth = Ids(iL,k) + Ide(iL,k) - Ids(iL,k-1) - Ide(iL,k-1)                                  
        Idboth = Idboth * (pst-P(k-1)) / (P(k) - P(k-1))                                            
        Idboth = Idboth + Ids(iL,k-1) + Ide(iL,k-1)                                                 
c       first for p<pstar, all three contributions                                                  
        DO i = 1, k-1                                                                               
          Intens(iL,i) = Istell(iL) + Istsc(iL,i) + Istem(iL,i)                                     
          IF (iL.EQ.iLfid)                                                                          
     &        tauZout(i) = ETAzp(i,nY)/ETAzp(1,nY)                                                  
        END DO                                                                                      
c       barely on the stellar disk                                                                  
        Intens(iL,k) = Istell(iL) + Idfront                                                         
        tauZout(k) = ETAzpStar/ETAzp(1,nY)                                                          
c       barely off the stellar disk                                                                 
        Intens(iL,k+1) = Idboth                                                                     
        tauZout(k+1) = 2.0D+00 * tauZout(k)                                                              
c       all other p>pstar                                                                           
        DO i = k, nP                                                                                
          Intens(iL,i+2) = Ids(iL,i)+Ide(iL,i)                                                      
          IF (iL.EQ.iLfid) THEN                                                                     
            nZ = nY + 1 - iYfirst(i)                                                                
            tauZout(i+2) = 2.0D+00 * ETAzp(i,nZ)/ETAzp(1,nY)                                             
          END IF                                                                                    
        END DO                                                                                      
      END DO                                                                                        
c     check dynamic range                                                                           
      DO iL = 1, nL                                                                                 
        DO i = 1, nP+2                                                                              
          CALL CHKRANGE(dynrange,Intens(iL,i))                                                      
        END DO                                                                                      
      END DO                                                                                        
c     now interpolate Intens(lambda) to lamOut                                                      
      DO iLout = 1, NlambdaOut                                                                      
c       bracket the needed wavelength                                                               
        iLstop = 0                                                                                  
        iL = 0                                                                                      
        DO WHILE (iLstop.EQ.0)                                                                      
          iL = iL + 1                                                                               
          IF (lambda(iL).GT.LambdaOut(iLout)) iLstop = 1                                            
          IF (iL.EQ.nL) iLstop = 1                                                                  
        END DO                                                                                      
c       interpolate intensity                                                                       
        xx = (LambdaOut(iLout)-lambda(iL-1))/(lambda(iL)-lambda(iL-1))                              
        DO i = 1, nP+2                                                                              
          IntL = Intens(iL-1,i)                                                                     
          IntR = Intens(iL,i)                                                                       
          IntOut(iLout,i) = IntL + xx*(IntR - IntL)                                                 
          CALL CHKRANGE(dynrange,IntOut(iLout,i))                                                   
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE GetbOut(npP,nP,P,pstar,bOut,k)                                                     
c =======================================================================                           
c This subroutine inserts two impact parameters corresponding to pstar,                             
c producing bOut(nP+2) from P(nP). The inserted elements are bOut(k) and                            
c bOut(k+1)                                            [Z.I., Aug. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npP, nP, k, kstop, i                                                                  
      DOUBLE PRECISION P(npP), bOut(npP+2), pstar                                                   
c -----------------------------------------------------------------------                           
      k = 0                                                                                         
      kstop = 0                                                                                     
      DO WHILE (kstop.NE.1)                                                                         
        k = k + 1                                                                                   
        bOut(k) = P(k)                                                                              
        IF (1.001D+00*pstar.LE.P(k).OR.k.EQ.nP) kstop = 1                                               
      END DO                                                                                        
      IF (0.999D+00*pstar.GT.P(k-1)) THEN                                                               
        bOut(k) = 0.999D+00*pstar                                                                       
        ELSE                                                                                        
        bOut(k) = 0.5D+00*(P(k-1)+1.001D+00*pstar)                                                          
      END IF                                                                                        
      IF (1.001D+00*pstar.LT.P(k)) THEN                                                                 
        bOut(k+1) = 1.001D+00*pstar                                                                     
        ELSE                                                                                        
        bOut(k+1) = 0.5D+00*(P(k)+0.999D+00*pstar)                                                          
      END IF                                                                                        
      DO i = k, nP                                                                                  
        bOut(i+2) = P(i)                                                                            
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE getOmega(nG)                                                                       
c =======================================================================                           
c This subroutine generates albedo omega(iL,iY) from the abs/sca cross-                             
c sections and the component abundancies. This is temporary (trivial)                               
c version  for single size grains.                     [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER  iG, nG, iL, iY                                                                       
c -----------------------------------------------------------------------                           
c     generate overall albedo through the envelope                                                  
c      ** this is for future multigrain code **                                                     
c      ** for single grains it is trivial **                                                        
      DO iY = 1, nY                                                                                 
c       calculate albedo                                                                            
        DO iL = 1, nL                                                                               
          omega(iL,iY) = SigmaS(nG,iL) / (SigmaA(nG,iL) + SigmaS(nG,iL))                            
        END DO                                                                                      
c       calculate relative abundances                                                               
        DO iG = 1, nG                                                                               
          abund(iG,iY) = 1.0D+00                                                                        
        END DO                                                                                      
      END DO                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
c **********************************************************************                            
      SUBROUTINE getOptPr(nG,nameQ,nameNK,er)                                                       
c =====================================================================                             
c This subroutine calculates the absorption and scattering efficiences                              
c Qabs and Qsca in the wavelength range of the code or in case of                                   
c user supplied efficiences reads them from a file.                                                 
c                                                 [ZI Mar96; MN Aug97]                              
c =====================================================================                             
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER npLnk                                                             
      PARAMETER (npLnk=98)                                                      
      DOUBLE PRECISION n_sil_ow(npLnk),k_sil_ow(npLnk),n_sil_oc(npLnk),         
     &       k_sil_oc(npLnk), n_sil_dl(npLnk), k_sil_dl(npLnk),                 
     &       n_amc_hn(npLnk), k_amc_hn(npLnk), n_sic_pg(npLnk),                 
     &       k_sic_pg(npLnk), n_gr1_dl(npLnk), k_gr1_dl(npLnk),                 
     &       n_gr2_dl(npLnk), k_gr2_dl(npLnk), lam_nk(npLnk)                    
      COMMON /nkdat/ n_sil_ow, k_sil_ow, n_sil_oc, k_sil_oc,                    
     &               n_sil_dl, k_sil_dl, n_amc_hn, k_amc_hn,                    
     &               n_sic_pg, k_sic_pg, n_gr1_dl, k_gr1_dl,                    
     &               n_gr2_dl, k_gr2_dl, lam_nk                                 
      CHARACTER*235 nameQ(npG), nameNK(10), Fname, dummy*132                                        
      INTEGER iG, nG, io1, iL, nLin, iLaux, Nprop, Na, iA, iC, iCuser,                              
     &        er, Nmax, npA                                                                         
c     Nmax is the number of records in user supplied file with opt.prop.                            
c     and npA is the dimension of the array of grain sizes                                          
      PARAMETER (Nmax=10000, npA=100)                                                               
c      PARAMETER (Nmax=10000, npA=1000)                                                               
       DOUBLE PRECISION aa,bb,cc,lambdain(Nmax),Qain(Nmax),Qsin(Nmax),                               
     &       n(npL),k(npL), aQabs(npA,npL),aQsca(npA,npL), amax,                                    
     &       nsd(npA), a(npA), faux1(npA), faux2(npA), f(npA), int,                                 
     &       ala(Nmax), SigAbs(npA,npL), SigSca(npA,npL), SizeDist,                                 
     &       aQa(Nmax), aQs(Nmax),  Cnorm, a3ave, a2ave,                                            
     &       n_int(npL), k_int(npL)                                                                 
c ----------------------------------------------------------------                                  
c     this should never change                                                                      
      nL = npL                                                                                      
      Nprop = 7                                                                                     
c ----------------------------------------------------------------                                  
      er = 0                                                                                        
c     first check that the user supplied wavelength grid is                                         
c     monotonously increasing                                                                       
      IF (top.LT.3) THEN                                                                            
c       calculate efficiencies from n and k by Mie theory                                           
c       generate the size array                                                                     
        IF (szds.GT.2) THEN                                                                         
          amax = 5.0D+00*a2                                                                             
        ELSE                                                                                        
          amax = a2                                                                                 
        END IF                                                                                      
        IF (dabs(a1-a2).LE.1.0D-03) THEN                                                              
          nA = 1                                                                                    
        ELSE                                                                                        
          nA =50                                                                                    
        END IF                                                                                      
c       Build-up the array of sizes a(nA)                                                           
        CALL GETsizes(npA,nA,a1,amax,a)                                                             
c       evaluate the normalization constant for the size                                            
c       distribution nsd(nA)                                                                        
        DO iA = 1, nA                                                                               
          nsd(iA) = SizeDist(qsd,a(iA),szds,a2)                                                     
        END DO                                                                                      
        CALL PowerInt(npA,1,nA,a,nsd,Cnorm)                                                         
c       find the average grain volume aveV and average grain  eff.                                  
c       area aveA (needed in dynamics)                                                              
        IF(dabs(a1-a2).LE.1.d-3) THEN                                                               
          aveV = 4.0D+00/3.0D+00*Pi*a1**3                                                                     
          aveA = Pi*a1**2.0D+00                                                                           
        ELSE                                                                                        
           DO iA = 1, nA                                                                            
             faux1(iA)=nsd(iA)*a(iA)**3.0D+00                                                             
           END DO                                                                                   
           CALL PowerInt(npA,1,nA,a,faux1,a3ave)                                                    
           aveV = 4.0D+00/3.0D+00*Pi*a3ave/Cnorm                                                              
           DO iA = 1, nA                                                                            
             faux1(iA)=nsd(iA)*a(iA)**2.0D+00                                                             
           END DO                                                                                   
           CALL PowerInt(npA,1,nA,a,faux1,a2ave)                                                    
           aveA = Pi*a2ave/Cnorm                                                                    
        END IF                                                                                      
c      --  LOOP OVER SUPPORTED COMPONENTS --                                                        
        DO iC= 1, Nprop                                                                             
          f(iC) = xC(iC)                                                                            
c         assign optical properties                                                                 
          IF (iC.EQ.1) CALL AssProp(npLnk,n_sil_ow,k_sil_ow,n,k)                                    
          IF (iC.EQ.2) CALL AssProp(npLnk,n_sil_oc,k_sil_oc,n,k)                                    
          IF (iC.EQ.3) CALL AssProp(npLnk,n_sil_dl,k_sil_dl,n,k)                                    
          IF (iC.EQ.4) CALL AssProp(npLnk,n_gr1_dl,k_gr1_dl,n,k)                                    
          IF (iC.EQ.5) CALL AssProp(npLnk,n_gr2_dl,k_gr2_dl,n,k)                                    
          IF (iC.EQ.6) CALL AssProp(npLnk,n_amc_hn,k_amc_hn,n,k)                                    
          IF (iC.EQ.7) CALL AssProp(npLnk,n_sic_pg,k_sic_pg,n,k)                                    
c         interpolate from opt. prop. grid to working grid                                          
          DO iL = 1, nL                                                                             
             CALL LinInter(npLnk,npLnk,lam_nk,n,lambda(iL),iLaux,aa)                                
             n_int(iL) = aa                                                                         
             CALL LinInter(npLnk,npLnk,lam_nk,k,lambda(iL),iLaux,aa)                                
             k_int(iL) = aa                                                                         
          END DO                                                                                    
c         calculate Qabs and Qsca (on working grid, i.e. lambda)                                    
          CALL MIE(npL,nL,lambda,n_int,k_int,npA,nA,a,1,aQabs,aQsca)                                
c         for each lambda integrate Pi*a^2*Qext with n(a)da                                         
          DO iL = 1, nL                                                                             
            DO iA = 1, nA                                                                           
              faux1(iA)=nsd(iA)*aQabs(iA,iL)*Pi*a(iA)**2.0D+00                                            
              faux2(iA)=nsd(iA)*aQsca(iA,iL)*Pi*a(iA)**2.0D+00                                            
            END DO                                                                                  
            CALL PowerInt(npA,1,nA,a,faux1,int)                                                     
            sigAbs(iC,iL) = int/Cnorm                                                               
            CALL PowerInt(npA,1,nA,a,faux2,int)                                                     
            sigSca(iC,iL) = int/Cnorm                                                               
          END DO                                                                                    
        END DO                                                                                      
        IF (top.EQ.2) THEN                                                                          
c         --  LOOP OVER USER SUPPLIED COMPONENTS --                                                 
          DO iCuser = 1, Nfiles                                                                     
            iC = Nprop + iCuser                                                                     
            f(iC) = xCuser(iCuser)                                                                  
c           read in optical properties                                                              
            Fname = nameNK(iCuser)                                                                  
            CALL GetProp(npL,lambda,nL,Fname,n,k,er)                                                
            IF (er.EQ.3) goto 999                                                                   
c           calculate Qabs and Qsca                                                                 
            CALL MIE(npL,nL,lambda,n,k,npA,nA,a,1,aQabs,aQsca)                                      
c           for each lambda integrate Pi*a^2*Qext with n(a)da                                       
            DO iL = 1, nL                                                                           
              DO iA = 1, nA                                                                         
                faux1(iA)=nsd(iA)*aQabs(iA,iL)*Pi*a(iA)**2.0D+00                                          
                faux2(iA)=nsd(iA)*aQsca(iA,iL)*Pi*a(iA)**2.0D+00                                          
              END DO                                                                                
              CALL PowerInt(npA,1,nA,a,faux1,int)                                                   
              sigAbs(iC,iL) = int/Cnorm                                                             
              CALL PowerInt(npA,1,nA,a,faux2,int)                                                   
              sigSca(iC,iL) = int/Cnorm                                                             
            END DO                                                                                  
          END DO                                                                                    
        ELSE                                                                                        
          Nfiles = 0                                                                                
        END IF                                                                                      
c       mix them together (syntetic grain model)                                                    
        DO iL = 1, nL                                                                               
          SigmaA(1,iL) = 0.0D+00                                                                        
          SigmaS(1,iL) = 0.0D+00                                                                        
          DO iC= 1, Nprop+Nfiles                                                                    
            SigmaA(1,iL) = SigmaA(1,iL) + f(iC) * sigAbs(iC,iL)                                     
            SigmaS(1,iL) = SigmaS(1,iL) + f(iC) * sigSca(iC,iL)                                     
          END DO                                                                                    
        END DO                                                                                      
      ELSE                                                                                          
c     this is for top.GE.3 - [sigma/V] from a file                                                  
c      initialize aveV and aveA for this case                                                       
       aveV = 1.                                                                                    
       aveA = 1.                                                                                    
c       read in lambda grid and optical properties                                                  
        DO iG = 1, nG                                                                               
          open(1,ERR=998,file=nameQ(iG),STATUS='OLD')                                               
          read(1,'(a)',ERR=998)dummy                                                                
          read(1,'(a)',ERR=998)dummy                                                                
          read(1,'(a)',ERR=998)dummy                                                                
          iL = 0                                                                                    
          io1 = 0                                                                                   
          DO WHILE (io1.GE.0)                                                                       
            read(1,*,END=900,ERR=998,iostat=io1) aa, bb, cc                                         
            IF (io1.GE.0) THEN                                                                      
              iL = iL + 1                                                                           
              lambdain(iL) = aa                                                                     
              Qain(iL) = bb                                                                         
              Qsin(iL) = cc                                                                         
            END IF                                                                                  
          END DO                                                                                    
900       close(1)                                                                                  
          IF (iL.LT.2) goto 998                                                                     
          nLin = iL                                                                                 
c         if input wavelengths in descending order turn them around                                 
          IF (lambdain(1).GT.lambdain(2)) THEN                                                      
            DO iL = 1, nLin                                                                         
              ala(iL) = lambdain(iL)                                                                
              aQa(iL) = Qain(iL)                                                                    
              aQs(iL) = Qsin(iL)                                                                    
            END DO                                                                                  
            DO iL = 1, nLin                                                                         
              lambdain(iL) = ala(nLin+1-iL)                                                         
              Qain(iL) = aQa(nLin+1-iL)                                                             
              Qsin(iL) = aQs(nLin+1-iL)                                                             
            END DO                                                                                  
          END IF                                                                                    
c         interpolate to Dusty's wavelength grid                                                    
          DO iL = 1, nL                                                                             
c !!!!!!!!!! PowerLaw interpolation (after comment by Sukanya Chakrabarti)[MN'04]                    
c            CALL LinInter(Nmax,nLin,lambdain,Qain,lambda(iL),iLaux,aa)                             
            CALL PowerInter(Nmax,nLin,lambdain,Qain,lambda(iL),iLaux,aa)                            
            SigmaA(iG,iL) = aa                                                                      
c            CALL LinInter(Nmax,nLin,lambdain,Qsin,lambda(iL),iLaux,aa)                             
            CALL PowerInter(Nmax,nLin,lambdain,Qsin,lambda(iL),iLaux,aa)                            
            SigmaS(iG,iL) = aa                                                                      
          END DO                                                                                    
        END DO                                                                                      
      END IF                                                                                        
      goto 999                                                                                      
998   write(12,*)' ***  FATAL ERROR IN DUSTY  ***********'                                          
      write(12,*)' File with optical properties:'                                                   
      write(12,'(a2,a70)')'  ',nameQ(iG)                                                            
      write(12,*)' is missing or not properly formatted?!'                                          
      write(12,*)' **************************************'                                          
      close(12)                                                                                     
      er = 3                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE GetProp(npL,lambda,nL,Fname,en,ek,error)                                           
c =======================================================================                           
c This subroutine reads optical properties en(i,j), ek(i,j) from file                               
c fname(Nf), with i=Nf, j=1..NLL(Nf), and interpolates them onto                                    
c wavelength grid lambda(1..nL)                        [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      CHARACTER*235 Fname                                                                           
      CHARACTER*232 line                                                                            
      INTEGER i, nL, iloc, iL, npL, io1, error, Nmax                                                
c     Nmax is the number of records in the user supplied file                                       
      PARAMETER (Nmax=10000)                                                                        
      DOUBLE PRECISION en(npL), ek(npL), lambda(npL), pw(Nmax),                                     
     &       pren(Nmax), pimn(Nmax), a(Nmax), b(Nmax), c(Nmax), aa,                                 
     &       bb, cc                                                                                 
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
      open(2,ERR=998,file=Fname,STATUS='OLD')                                                       
c     read in a header from the input file                                                          
      DO i = 1, 7                                                                                   
        read(2,'(a)',ERR=998)line                                                                   
      END DO                                                                                        
c     read in input data                                                                            
      iL = 0                                                                                        
      io1 = 0                                                                                       
      DO WHILE (io1.GE.0)                                                                           
        read(2,*,END=900,ERR=998,iostat=io1) aa, bb, cc                                             
        IF (io1.GE.0) THEN                                                                          
          iL = iL + 1                                                                               
          pw(iL) = aa                                                                               
          pren(iL) = bb                                                                             
          pimn(iL) = cc                                                                             
        END IF                                                                                      
      END DO                                                                                        
900   close(2)                                                                                      
      IF (iL.LT.2) goto 998                                                                         
c     if input wavelengths in descending order turn them around                                     
      IF (pw(1).GT.pw(2)) THEN                                                                      
        DO i = 1, iL                                                                                
          a(i) = pw(i)                                                                              
          b(i) = pren(i)                                                                            
          c(i) = pimn(i)                                                                            
        END DO                                                                                      
        DO i = 1, iL                                                                                
          pw(i) = a(iL+1-i)                                                                         
          pren(i) = b(iL+1-i)                                                                       
          pimn(i) = c(iL+1-i)                                                                       
        END DO                                                                                      
      END IF                                                                                        
c     interpolate                                                                                   
      DO i = 1, nL                                                                                  
        CALL LinInter(Nmax,iL,pw,pren,lambda(i),iloc,en(i))                                         
        CALL LinInter(Nmax,iL,pw,pimn,lambda(i),iloc,ek(i))                                         
      END DO                                                                                        
      goto 999                                                                                      
998   write(12,*)' ***  FATAL ERROR IN DUSTY  ***********'                                          
      write(12,*)' File with optical properties:'                                                   
      write(12,'(a2,a70)')'  ',Fname                                                                
      write(12,*)' is missing or not properly formatted?!'                                          
      write(12,*)' **************************************'                                          
      close(12)                                                                                     
      error = 3                                                                                     
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE GETsizes(NN,N,x1,x2,x)                                                             
c =======================================================================                           
c This subroutine generates an array x(i=1..N) of physical size NN,                                 
c with N elements logarithmically spaced between x1 and x2.                                         
c                                              [ZI,Aug'96;MN,Nov'97]                                
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NN, N, i                                                                              
      DOUBLE PRECISION x(NN), x1, x2, fac, pw1, pw2                                                 
c -----------------------------------------------------------------------                           
      IF (N.GT.1) THEN                                                                              
        pw1 = 1.0D+00/(N-1)                                                                             
        fac = (x2/x1)**pw1                                                                          
        DO i = 1, N                                                                                 
          pw2 = 1.0D+00*(i-1)                                                                           
          x(i) = x1*fac **pw2                                                                       
        END DO                                                                                      
      ELSE                                                                                          
        x(1) = x1                                                                                   
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE getTau(model,nG,TAU1,TAU2,TAUin,Nrec,GridType,Nmodel)                              
c =======================================================================                           
c This subroutine generates total optical depth TAUtot.                                             
c                                                      [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER model, Nmodel, nG, iL, GridType, Nrec                                                 
      DOUBLE PRECISION faux1(npL), faux2(npL), SigAfid, SigSfid, q,                                 
     &       TAUin(Nrec), TAU1, TAU2                                                                
c -----------------------------------------------------------------------                           
      IF (nG.GT.1) THEN                                                                             
        write(18,*)'Fix getTAU, nG>1 !'                                                             
        stop                                                                                        
      END IF                                                                                        
      TAUmax = 0.0D+00                                                                                  
      IF(GridType.EQ.3) THEN                                                                        
        TAUfid = TAUin(model)                                                                       
      ELSE                                                                                          
c      calculate TAUfid for given model                                                             
       IF (model.EQ.1) THEN                                                                         
        TAUfid = TAU1                                                                               
       ELSE                                                                                         
        IF (model.EQ.Nmodel) THEN                                                                   
          TAUfid = TAU2                                                                             
        ELSE                                                                                        
          IF (GridType.EQ.1) THEN                                                                   
            q =  (TAU2 - TAU1)/(Nmodel-1.0D+00)                                                         
            TAUfid = TAU1 + q*(model-1.0D+00)                                                           
          ELSE                                                                                      
            q = dexp(dlog(TAU2/TAU1)/(Nmodel-1.0D+00))                                                   
            TAUfid = TAU1 * q**(model-1.0D+00)                                                          
          END IF                                                                                    
        END IF                                                                                      
       END IF                                                                                       
      END IF                                                                                        
c     generate TAUtot and find TAUmax                                                               
      DO iL = 1, nL                                                                                 
        faux1(iL) = SigmaA(nG,iL)                                                                   
        faux2(iL) = SigmaS(nG,iL)                                                                   
      END DO                                                                                        
      IF (lamfid.LT.lambda(1)) THEN                                                                 
        write(12,*)' Fiducial wavelength was too small.'                                            
        write(12,'(a8,e9.3,a17)')' Using ',lambda(1),' micron instead.'                             
      END IF                                                                                        
      IF (lamfid.GT.lambda(nL)) THEN                                                                
        write(12,*)' Fiducial wavelength was too large.'                                            
        write(12,'(a8,e9.3,a17)')' Using ',lambda(nL),' micron instead.'                            
      END IF                                                                                        
      CALL LinInter(npL,nL,lambda,faux1,lamfid,iLfid,SigAfid)                                       
      CALL LinInter(npL,nL,lambda,faux2,lamfid,iLfid,SigSfid)                                       
c     extinction efficiency at fiducial wavelength                                                  
      SigExfid = SigAfid + SigSfid                                                                  
      DO iL = 1, nL                                                                                 
        TAUtot(iL) = TAUfid*(SigmaA(nG,iL) + SigmaS(nG,iL)) / SigExfid                              
        IF (TAUtot(iL).GE.TAUmax) TAUmax = TAUtot(iL)                                               
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE getETAzp(ETAzp)                                                                    
c =======================================================================                           
c This function calculates ETAzp(iP,iZ) along the line of sight with                                
c impact parameter P(iP) and iZ=1, nZ. Here iZ = 1 corresponds to z=0                               
c and iZ=nZ to the outer edge. Other grid points coincide with the                                  
c radial grid. The method used is spline approximation for normalized                               
c density distribution ETA, with subsequent z-integration performed                                 
c analytically in function IntETA                                                                   
c                                               [ZI,Feb'95; MN,Aug'97]                              
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iYfirst, YPequal, Plast                                           
      DIMENSION iYfirst(npP), YPequal(npP), Plast(npY)                          
      COMMON /Yfirst/ iYfirst, YPequal, Plast                                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER iP, nZ, iZ, iW                                                                        
      DOUBLE PRECISION ETAzp(npP,npY), IntETA, auxEta, w1, w2                                       
c -----------------------------------------------------------------------                           
c     loop over impact parameters                                                                   
      DO iP = 1, nP                                                                                 
c       maximal number of points along tangential position, z                                       
        nZ = nY + 1 - iYfirst(iP)                                                                   
c       starting values for z and ETAzp(iP,iZ)                                                      
        IF (P(iP).GE.1.0D+00) THEN                                                                      
          w2 = P(iP)                                                                                
          ELSE                                                                                      
          w2 = 1.0D+00                                                                                  
        END IF                                                                                      
c       initialize ETAzp(iP,iZ)*TAUtot(iL)                                                          
        ETAzp(iP,1) = 0.0D+00                                                                           
c       loop over z                                                                                 
        DO iZ = 2, nZ                                                                               
c         index for local radius, w2                                                                
          iW = iYfirst(iP) + iZ - 1                                                                 
c         limits for integration                                                                    
          w1 = w2                                                                                   
          w2 = Y(iW)                                                                                
c           find next step in ETAzp                                                                 
            auxEta = IntETA(P(iP),iW-1,w1,w2)                                                       
c           add next step in ETAzp                                                                  
            ETAzp(iP,iZ) = ETAzp(iP,iZ-1) + auxEta                                                  
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION IMAGFN(y)                                                           
c =======================================================================                           
c This function evaluates auxiliary functions needed to produce                                     
c visibility curves and convolved images. It is called from the image                               
c integration subroutine ROMBY.                        [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x, y, PSFN, Bessel                                                           
      INTEGER ftype                                                             
      DOUBLE PRECISION Ckn, Cxout, Cphi, Cqtheta                                
      COMMON /imfn1/ ftype                                                      
      COMMON /imfn2/ Ckn, Cxout, Cphi, Cqtheta                                  
c -----------------------------------------------------------------------                           
      IF (ftype.EQ.1) THEN                                                                          
c       this part is for convolution                                                                
        x = dsqrt(dabs(Cxout*Cxout+y*y-2.0D+00*Cxout*y*dcos(Cphi)))                                        
        imagfn = PSFN(x) * y**Ckn                                                                   
      ELSE                                                                                          
c       this part is for visibility                                                                 
c       argument is Pi*q*y (not 2*Pi*q*y) to account for the fact that                              
c       theta1 is diameter rather than radius (so V is function of                                  
c       q*theta1, like in IE, '96, MNRAS 279, 1019)                                                 
        imagfn = Bessel(2.0D+00*dSIN(1.0D+00)*Cqtheta*y) * y**Ckn                                            
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MIE(npL,nL,lambda,Ere,Eim,npA,nA,a,nG1,Qabs,Qsca)                                  
c =======================================================================                           
c This subroutine calculates Qabs and Qsca for a given diffractive                                  
c index Ere, Eim, wavelength lambda and size a. Here, lambda is an                                  
c array (1..nL), Ere and Eim are given on this array, a is an array                                 
c of sizes (1..nA). Qabs and Qsca are arrays (nG1..nG1+nA,nL), i.e. for                             
c each wavelength lambda, Qabs and Qsca are evaluated for nA different                              
c sizes. The numbering, however, does not start from 1, but rather from                             
c nG1.                                                [Z.I., Aug. 1996]                             
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npL, nL, npA, nA, nG1, iL, iA                                                         
      DOUBLE PRECISION lambda(npL), Ere(npL), Eim(npL), a(npA),                                     
     &       Qabs(npA,npL), Qsca(npA,npL)                                                           
      DOUBLE PRECISION xx, Qex, Qsc, Qback                                                                      
      COMPLEX refrel, s1(200), s2(200)                                                              
c -----------------------------------------------------------------------                           
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c       complex index of refraction                                                                 
        refrel = cmplx(Ere(iL),Eim(iL))                                                             
c       loop over sizes                                                                             
        DO iA = 1, nA                                                                               
c         size parameter                                                                            
          xx=2.0D+00*3.14159265D+00*a(iA)/lambda(iL)                                                        
c         if size parameter xx>100 use xx=100 (geometrical optics)                                  
          IF (xx.GT.100.0) xx = 100.0D+00                                                               
c         calculate efficiencies                                                                    
          CALL bhmie(xx,refrel,2,s1,s2,Qex,Qsc,Qback)                                               
c         store the result                                                                          
          Qabs(nG1+iA-1,iL) = Qex - Qsc                                                             
          Qsca(nG1+iA-1,iL) = Qsc                                                                   
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION PSFN(x)                                                             
c =======================================================================                           
c This function evaluates the point spread function. For psftype.EQ.1                               
c the function is evaluated as a sum of two Gaussians, for psftype.EQ.3                             
c it is provided by user in a file. psftype and all other relevant                                  
c parameters come from COMMON /psf/ and are initialized in subroutine                               
c INPUT.                                               [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x                                                                            
      INTEGER idummy                                                                                
      INTEGER psftype, Npsf, iLambda                                            
      DOUBLE PRECISION kPSF(20), FWHM1(20), FWHM2(20), Theta1,                  
     &       xpsf(1000), ypsf(1000), psfArea(20)                                
      COMMON /psf1/ iLambda, psftype, Npsf                                      
      COMMON /psf2/ kPSF, FWHM1, FWHM2, Theta1,                                 
     &       xpsf, ypsf, psfArea                                                
c -----------------------------------------------------------------------                           
      IF (psftype.LT.3) THEN                                                                        
        psfn = dexp(-(1.665D+00*x/FWHM1(iLambda))**2.0D+00)                                                  
        IF (psftype.EQ.2)                                                                           
     &    psfn = (psfn + kPSF(iLambda) *                                                            
     &           dexp(-(1.665D+00*x/FWHM2(iLambda))**2.0D+00))/
     &                                    (1.0D+00+kPSF(iLambda))                            
        ELSE                                                                                        
        CALL LinInter(1000,Npsf,xpsf,ypsf,x,idummy,psfn)                                            
      ENDIF                                                                                         
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE setupETA                                                                           
c =======================================================================                           
c This subroutine finds spline coefficients ETAcoef (defined in file                                
c 'density.inc') such that normalized density function ETA(Y(iY)) is:                               
c ETAcoef(iY,1)+ETAcoef(iY,2)/Y(iY)+...+ETAcoef(iY,2)/Y(iY)^3                                       
c If spline approximation differs more than maxerr (see below) at the                               
c midpoint, then a straight line is used instead. (In case of wavelength                            
c depend. ETA, use ETAfun where any new dens. laws should be described).                            
c Coefficients ETAcoef are later used in getETAzp to calculate ETAzp.                               
c                                                [ZI, Feb'96; MN,Aug'97]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iY, iC                                                                                
      DOUBLE PRECISION coef(npY,4), ETA, maxerr, Ymid, Yinverse(npY),                               
     &       ETAaux(npY), ETAmid(npY)                                                               
c -----------------------------------------------------------------------                           
c       generate input function for SPLINE2                                                         
        DO iY = 1, nY                                                                               
          Yinverse(iY) = 1.0D+00 / Y(iY)                                                                 
          ETAaux(iY) = ETA(Y(iY))                                                                   
          IF (iY.LT.nY) THEN                                                                        
            Ymid = dsqrt(Y(iY)*Y(iY+1))                                                             
            ETAmid(iY) = ETA(Ymid)                                                                  
          END IF                                                                                    
        END DO                                                                                      
c       calculate spline coefficients                                                               
        CALL SPLINE2(Yinverse,ETAaux,nY,coef)                                                       
c       check and fix spline coefficients                                                           
        maxerr = 0.1D+00                                                                                
c       RDW is initialized in Input                                                                 
        CALL CHKSPLIN(Yinverse,ETAaux,ETAmid,nY,coef,maxerr,RDW)                                    
c       copy coefficients to the output array ETAcoef                                               
        DO iY = 1, nY                                                                               
          DO iC = 1, 4                                                                              
            ETAcoef(iY,iC) = coef(iY,iC)                                                            
          END DO                                                                                    
        END DO                                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION SizeDist(q,aa,sdtype,a0)                                            
c =======================================================================                           
c This subroutine calculates size distribution n(a) for a=aa. The size                              
c distribution is MRN type n(a)~1/a**q for sdtype.LE.2 and KMH type                                 
c n(a)~dexp(-a/a0)/a**q otherwise                                                                   
c                                                      [Z.I., Aug. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER sdtype                                                                                
      DOUBLE PRECISION aa, a0, q                                                                    
c -----------------------------------------------------------------------                           
      IF (sdtype.LE.2) THEN                                                                         
        SizeDist = 1.0D+00/aa**q                                                                        
        ELSE                                                                                        
        SizeDist = dexp(-aa/a0)/aa**q                                                               
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Spectral(model,denstyp,nL,Lambda)                                                  
c =======================================================================                           
c     This subroutine finds the spectral features for spp and zpp files.                            
c     It employs Sub SpFeatur                              [MN, Jan'99]                             
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER i, iL, model, nL, denstyp, Nchar                                                      
      PARAMETER (Nchar=11)                                                                          
      DOUBLE PRECISION Charac(Nchar),Spectr(npL),Lambda(npL)                                        
c -----------------------------------------------------------------------                           
c     find features for *.spp file                                                                  
      IF (denstyp.eq.0) THEN                                                                        
        DO iL = 1, nL                                                                               
            Spectr(iL) = ftot(iL,nYok) + ksi*fsR(iL,nYok)                                           
        END DO                                                                                      
      ELSE                                                                                          
        DO iL = 1, nL                                                                               
c            Spectr(iL) = Spectrum(iL)                                                              
c          fsL is the central source rad, fsRp is the outward external rad.                         
c           Spectr(iL) = fsL(iL,nYok) + fsRp(iL,nYok)                                               
c     &                + fde(iL,nYok) + fds(iL,nYok)                                                
c          Only the shell emission, external contribution not added                                 
           Spectr(iL) = fsL(iL,nYok)                                                                
     &                + fde(iL,nYok) + fds(iL,nYok)                                                 
        END DO                                                                                      
      END IF                                                                                        
      CALL SpFeatur(model,nL,Lambda,Spectr,Charac)                                                  
      DO i = 1, Nchar                                                                               
       SpecChar(i,model) = Charac(i)                                                                
      END DO                                                                                        
c     find features for *.zpp file for slab                                                         
      IF (denstyp.eq.0) THEN                                                                        
         DO iL = 1, nL                                                                              
            Spectr(iL) = dabs(ftot(iL,1) - fsL(iL,1))                                               
         END DO                                                                                     
       CALL SpFeatur(model,nL,Lambda,Spectr,Charac)                                                 
         DO i = 1, Nchar                                                                            
            SpecChar(i+11,model) = Charac(i)                                                        
         END DO                                                                                     
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SpFeatur(model,nL,Lambda,Spectr,Charac)                                            
c =======================================================================                           
c This subroutine calculates IRAS colors and other spectral quantities                              
c Filters data from Neugebauer et al, 1984, ApJ, 278, L1.                                           
c Procedure described in Bedijn, 1987, A&A, 186, 136.  [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER i, j, iaux, model, nL                                                                 
      DOUBLE PRECISION  f1(7), f2(7), f3(7), f4(7), w1(7), w2(7), w3(7),                            
     &        w4(7), phi(4,7), al(4,7), cl(4), prz(4), tinf(4), flxy(9),                            
     &        wav(9), lambda(npL), Spectr(npL), Charac(11), wmid, flx1,                             
     &        flx2, faux, B98, B11, rat9818, beta813, beta1422, f12,                                
     &        f25, f60, f100, an98, f98c, f11c, an11                                                
c -----------------------------------------------------------------------                           
c     Data for 4 IRAS filters                                                                       
c     wavelengths                                                                                   
       DATA w1/7.55D+0,8.0D+0,10.3D+0,11.5D+0,13.4D+0,14.7D+0,15.5D+0/                                             
       DATA w2/16.6D+0,22.5D+0,25.6D+0,26.8D+0,27.5D+0,29.3D+0,31.1D+0/                                            
       DATA w3/30.5D+0,40.1D+0,40.2D+0,65.2D+0,74.2D+0,83.8D+0,83.9D+0/                                            
      DATA w4/72.7D0,95.4D0,111.2D0,116.6D0,137.4D+0,137.5D0,137.6D0/                                       
c     transmittivities                                                                              
       DATA f1/0.000D0,0.618D0,0.940D0,0.750D0,1.022D0,0.906D0,0.000D0/                                     
       DATA f2/0.235D0,0.939D0,0.939D0,0.745D0,0.847D0,0.847D0,0.000D0/                                     
       DATA f3/0.000D0,0.102D0,0.260D0,1.026D0,0.842D0,0.001D0,0.000D0/                                     
       DATA f4/0.000D0,0.910D0,1.000D0,0.330D0,0.002D0,0.001D0,0.000D0/                                     
c     ------------------------------------------------------------                                  
c     initialization                                                                                
       DO i = 1, 4                                                                                  
         tinf(i) = 0.0D+00                                                                              
         cl(i) = 0.0D+00                                                                                
       END DO                                                                                       
       DO j = 1, 7                                                                                  
         al(1,j) = w1(j)                                                                            
         phi(1,j) = f1(j)                                                                           
         al(2,j) = w2(j)                                                                            
         phi(2,j) = f2(j)                                                                           
         al(3,j) = w3(j)                                                                            
         phi(3,j) = f3(j)                                                                           
         al(4,j) = w4(j)                                                                            
         phi(4,j) = f4(j)                                                                           
       END DO                                                                                       
c ------------------------------------------------------------------------                          
c     first find IRAS colors                                                                        
      DO j = 2, nL                                                                                  
c       middle wavelength                                                                           
        wmid = 0.5D+00*(Lambda(j-1)+Lambda(j))                                                          
c       interpolate filters for wmid                                                                
        CALL PHILAM(wmid,prz,al,phi)                                                                
c       convert Spectrum to Flambda                                                                 
        flx1 = Spectr(j-1) / Lambda(j-1)                                                            
        flx2 = Spectr(j) / Lambda(j)                                                                
c       add contribution to the integral (index is over filters)                                    
        DO i = 1, 4                                                                                 
          tinf(i) = tinf(i) + prz(i)*0.5D+00*(flx2+flx1)*                                               
     &                                    (Lambda(j)-Lambda(j-1))                                   
          cl(i) = cl(i) + prz(i) * (Lambda(j)-Lambda(j-1))                                          
        END DO                                                                                      
      END DO                                                                                        
      DO i = 1, 4                                                                                   
        tinf(i) = tinf(i) / cl(i)                                                                   
      END DO                                                                                        
c     Spectrum corrected for IRAS filters                                                           
      f12 = tinf(1)*12.0D+00                                                                            
      f25 = tinf(2)*25.0D+00                                                                            
      f60 = tinf(3)*60.0D+00                                                                            
      f100 = tinf(4)*100.0D+00                                                                          
c     now find  B98, B11, F98/F18, beta 8-13, beta 14-22                                            
c     find fluxes at all needed wavelengths (energy increases with index)                           
      DATA wav/2.2, 8.0, 9.8, 11.3, 13.0, 14.0, 18.0, 22.0, 0.55/                                   
      DO j = 1, 9                                                                                   
        CALL LinInter(npL,nL,lambda,Spectr,wav(j),iaux,faux)                                        
        flxy(j) = faux                                                                              
      END DO                                                                                        
c     the feature strength at 9.8 and 11.4 microns                                                  
      IF((flxy(2)*flxy(5)*flxy(3)*flxy(4)).GT.0.0D+00) THEN                                             
        an98 = log(flxy(5)/flxy(2))/log(wav(5)/wav(2))                                              
        f98c = flxy(2)*(wav(3)/wav(2))**an98                                                        
        B98 = log(flxy(3)/f98c)                                                                     
        an11 = log(flxy(5)/flxy(3))/log(wav(5)/wav(3))                                              
        f11c = flxy(3)*(wav(4)/wav(3))**an11                                                        
        B11 = log(flxy(4)/f11c)                                                                     
      ELSE                                                                                          
        B98 = 0.0D+00                                                                                   
        B11 = 0.0D+00                                                                                   
        IF(iX.GE.1)                                                                                 
     &    write(18,*) ' No 10 micron feature strength, fluxes are 0.'                               
      END IF                                                                                        
c     ratio F9.8/F18                                                                                
      IF((flxy(2)*flxy(5)*flxy(7)).GT.0.0D+00) THEN                                                     
        rat9818 = flxy(3)/flxy(7)*wav(7)/wav(3)                                                     
c       beta 8-13 and beta 14-22 (see Neugebauer)                                                   
        beta813 = dlog(flxy(5)/flxy(2))/dlog(13.0D+00/8.0D+00) - 1.0D+00                                          
      ELSE                                                                                          
        rat9818 = 0.0D+00                                                                               
        beta813 = 0.0D+00                                                                               
        IF(iX.GE.1)                                                                                 
     &    write(18,*) ' No 8-13 microns slope, fluxes are 0.'                                       
      END IF                                                                                        
      IF((flxy(6)*flxy(8)).GT.0.0D+00) THEN                                                             
        beta1422 = dlog(flxy(8)/flxy(6))/dlog(22.0D+00/14.0D+00)-1.0D+00                                        
      ELSE                                                                                          
        beta1422 = 0.0D+00                                                                              
        IF(iX.GE.1)                                                                                 
     &    write(18,*) ' No 14-22 microns slope, fluxes are 0.'                                      
      END IF                                                                                        
c     store SpecChar to output array SpecChar                                                       
      Charac(1) = B98                                                                               
      Charac(2) = B11                                                                               
      Charac(3) = rat9818                                                                           
      Charac(4) = beta813                                                                           
      Charac(5) = beta1422                                                                          
      Charac(6) = flxy(9)                                                                           
      Charac(7) = flxy(1)                                                                           
      Charac(8) = f12                                                                               
      IF((f12*f25).GT.0.0D+00) THEN                                                                      
        Charac(9) = dlog10(25.0D+00*f25/f12/12.0D+00)                                                        
      ELSE                                                                                          
        Charac(9) = 0.0D+00                                                                             
      END IF                                                                                        
      IF((f12*f60).GT.0.0D+00) THEN	                                                                     
        Charac(10) = dlog10(60.0D+00*f60/f12/12.0D+00)                                                       
      ELSE                                                                                          
        Charac(10) = 0.0D+00                                                                            
      END IF                                                                                        
      IF((f60*f100).GT.0.0D+00) THEN                                                                     
        Charac(11) = dlog10(f100*100.0D+00/f60/60.0D+00)                                                     
      ELSE                                                                                          
        Charac(11) = 0.0D+00                                                                            
      END IF                                                                                        
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c *******************************************************************                               
                                                                                                    
c *******************************************************************                               
      SUBROUTINE PHILAM(Alam,F,Al,Phi)                                                              
c     interpolates IRAS filters [f(4)] for a given wavelength alam                                  
      IMPLICIT NONE
      INTEGER i,im,istop
      DOUBLE PRECISION a,b,alam,Al(4,7),phi(4,7),f(4)                                                            
c -----------------------------------------------                                                   
      DO i = 1, 4                                                                                   
        F(i) = 0.0D+00                                                                                  
        im = 0                                                                                      
        istop = 0                                                                                   
        DO WHILE (istop.NE.1)                                                                       
              im = im + 1                                                                           
            IF ( (Alam-Al(i,im))*(Alam-Al(i,im+1)).LE.0.0D+00) THEN                                       
               a = (Phi(i,im+1)-Phi(i,im))                                                          
     &           /dlog10(Al(i,im+1)/Al(i,im))                                                        
               b = Phi(i,im) - a*log10(Al(i,im))                                                    
               F(i) = a*dlog10(Alam) + b                                                             
            IF ( F(i).GT.1.0D+00 ) F(i) = 1.0D+00                                                           
              END IF                                                                                
            IF (im.EQ.6) istop = 1                                                                  
        END DO                                                                                      
      END DO                                                                                        
c ------------------------------------------------------                                            
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           

c$$$c *******************************************************************                               
c$$$      SUBROUTINE PHILAM(Alam,F,Al,Phi)                                                              
c$$$c     interpolates IRAS filters [f(4)] for a given wavelength alam                                  
c$$$      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                                            
c$$$      DIMENSION Phi(4,7), Al(4,7), F(4)                                                             
c$$$c -----------------------------------------------                                                   
c$$$      DO i = 1, 4                                                                                   
c$$$        F(i) = 0.0D+00                                                                                  
c$$$        im = 0                                                                                      
c$$$        istop = 0                                                                                   
c$$$        DO WHILE (istop.NE.1)                                                                       
c$$$              im = im + 1                                                                           
c$$$            IF ( (Alam-Al(i,im))*(Alam-Al(i,im+1)).LE.0) THEN                                       
c$$$               a = (Phi(i,im+1)-Phi(i,im))                                                          
c$$$     &           /log10(Al(i,im+1)/Al(i,im))                                                        
c$$$               b = Phi(i,im) - a*log10(Al(i,im))                                                    
c$$$               F(i) = a*log10(Alam) + b                                                             
c$$$            IF ( F(i).GT.1.0 ) F(i) = 1.0                                                           
c$$$              END IF                                                                                
c$$$            IF (im.EQ.6) istop = 1                                                                  
c$$$        END DO                                                                                      
c$$$      END DO                                                                                        
c$$$c ------------------------------------------------------                                            
c$$$      RETURN                                                                                        
c$$$      END                                                                                           
c$$$c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Visibili(IntOut)                                                                   
c =======================================================================                           
c This subroutine finds visibility functions corresponding to IntOut.                               
c The work horse is subroutine Visi2D, and this subroutine is used to                               
c prepare everything.                                  [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER i, j, N1, N2                                                                          
      DOUBLE PRECISION  IntOut(20,npP+2), Visi(1000), Int1D(npP+2)                                  
c -----------------------------------------------------------------------                           
c     generate spatial frequency (q) grid                                                           
c     first N1 points up to qtheta1=1.22 (Rayleigh limit for a disk)                                
      N1 = 80                                                                                       
c     first 2 points manually:                                                                      
c     there must be 0!                                                                              
      qtheta1(1) = 0.0D+00                                                                              
c     make sure the whole envelope is resolved                                                      
      qtheta1(2) = 0.5D+00 / bOut(nP+2)                                                                 
c     and the rest on logarithmic grid up to 1.22                                                   
      DO i = 1, N1-2                                                                                
       qtheta1(i+2)=qtheta1(2)*(1.22D+00/qtheta1(2))**(i*1.0D+00/(N1-2))                               
      END DO                                                                                        
c     envelope is well sampled, now to be sure that the star will be OK                             
c     for small taus add N2 points on a logarithmic grid up to 1.22/p*                              
      N2 = 20                                                                                       
      DO i = 1, N2                                                                                  
        qtheta1(N1+i) = 1.22D+00 / bOut(2)**(i*1.0D+00/N2)                                                  
      END DO                                                                                        
      Nvisi = N1 + N2                                                                               
c     find visibility wavelength by wavelength                                                      
      DO j = 1, NlambdaOut                                                                          
        DO i = 1, nP+2                                                                              
          Int1D(i) = IntOut(j,i)                                                                    
          CALL CHKRANGE(dynrange,Int1D(i))                                                          
          IF (Int1D(i).LT.dynrange) Int1D(i)=0.0D+00                                                    
        END DO                                                                                      
        CALL Visi2D(npP+2,nP+2,bOut,Int1D,1000,N1+N2,qtheta1,Visi)                                  
c       copy 1D convolved visibility to Visib                                                       
        DO i = 1, N1+N2                                                                             
c         check dynamic range                                                                       
          CALL CHKRANGE(dynrange,Visi(i))                                                           
          Visib(j,i) = Visi(i)                                                                      
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Visi2D(NinMax,Nin,Xin,Yin,Noutmax,Nout,Xout,Yout)                                  
c =======================================================================                           
c This subroutine finds the visibility function (the spatial Fourier                                
c transform of the intensity distribution) corresponding to the                                     
c intensity Yin(Xin[i]), i=1,Nin. Visibility, Yout, is evaluated at q                               
c positions (spatial frequency) given in Xout[i], i=1,Nout. Maximum size                            
c of Xin is NinMax, maximum size of Xout is NoutMax. The Bessel function                            
c of the zeroth order is provided separately. The integration is done by                            
c calling subroutine ROMBY (Bessel function is called from IMGFN).                                  
c Note:                                                                                             
c The visibility function V(q) for a circularly symmetric intensity                                 
c I(x) is:                                                                                          
c          V(q) = F(q)/F(0)                                                                         
c where Jo is the Bessel function of the zeroth order, and                                          
c          F(q) = Int[Jo(2Pi*q*x)*I(x)*2Pi*x*dx]                                                    
c Note that F(0) is nothing more than flux. For more details see                                    
c Ivezic & Elitzur, 1996, MNRAS, 279, 1019 and ref. therein.                                        
c                                                      [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NinMax, Nin, NoutMax, Nout, iq, iXin                                                  
      DOUBLE PRECISION Xin(NinMax), Yin(NinMax), Xout(NoutMax),                                     
     &       Yout(NoutMax),  F(1000), F0, int1, int2, A, B, imagfn                                  
      INTEGER ftype                                                             
      DOUBLE PRECISION Ckn, Cxout, Cphi, Cqtheta                                
      COMMON /imfn1/ ftype                                                      
      COMMON /imfn2/ Ckn, Cxout, Cphi, Cqtheta                                  
      EXTERNAL imagfn                                                                               
c -----------------------------------------------------------------------                           
c     loop over spatial frequency q (= Xout)                                                        
      DO iq = 1, Nout                                                                               
        Cqtheta = Xout(iq)                                                                          
        F(iq) = 0.0D+00                                                                                 
c       loop over radial positions                                                                  
        DO iXin = 1, Nin                                                                            
c         find F(q)                                                                                 
          ftype = 2                                                                                 
          Ckn = 1.0D+00                                                                                 
          CALL ROMBY(imagfn,Xin(iXin),Xin(iXin+1),int1)                                             
          Ckn = 2.0D+00                                                                                 
          CALL ROMBY(imagfn,Xin(iXin),Xin(iXin+1),int2)                                             
c         contribution from this annulus (lin. approx. for intensity)                               
          A = Xin(iXin+1)*Yin(iXin)-Xin(iXin)*Yin(iXin+1)                                           
          A = A /(Xin(iXin+1)-Xin(iXin))                                                            
          B = (Yin(iXin+1)-Yin(iXin))/(Xin(iXin+1)-Xin(iXin))                                       
          F(iq) = F(iq) + A*int1 + B*int2                                                           
        END DO                                                                                      
      END DO                                                                                        
c     flux                                                                                          
      F0 = F(1)                                                                                     
      DO iq = 1, Nout                                                                               
       IF(F0.EQ.0.0D+00) THEN                                                                            
         Yout(iq) = 0.0D+00                                                                              
       ELSE                                                                                         
         Yout(iq) = dabs(F(iq) / F0)                                                                
       END IF                                                                                       
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ======================================================================                            
c This is the file with auxiliary math and number-to-string conversion                              
c subroutines.                                             [MN, Mar,99]                             
c ======================================================================                            
C     Table of Contents                                                                             
C                                                                                                   
C     ADD                                                                                           
C     ADD2                                                                                          
C     ANALINT                                                                                       
C     BESSEL                                                                                        
C     BHMIE                                                                                         
C     ChkAngle                                                                                      
C     CHKRANGE                                                                                      
C     CHKSPLIN                                                                                      
C     FindErr                                                                                       
C     FINDMAX                                                                                       
C     FINDRMS                                                                                       
C     H                                                                                             
C     KRON                                                                                          
C     LININTER                                                                                      
C     LINSYS                                                                                        
C     LUBKSB                                                                                        
C     LUDCMP                                                                                        
C     MAPLE3                                                                                        
C     MIDSQL                                                                                        
C     MPROVE                                                                                        
C     MULTIPLY                                                                                      
C     MULTIP2                                                                                       
C     MYSPLINE                                                                                      
C     POLINT                                                                                        
C     POWERINT                                                                                      
C     PowerInter                                                                                    
C     DoPRODUCT                                                                                     
C     ROMBERG2                                                                                      
C     ROMBY                                                                                         
C     Scaleto1                                                                                      
C     ScaletoArea                                                                                   
C     SHIFT                                                                                         
C     SIMPSON                                                                                       
C     SORT                                                                                          
C     SPLINE                                                                                        
C     SPLINE2                                                                                       
C     SPLINT                                                                                        
C     TRAPZD                                                                                        
C     ZBRAC                                                                                         
C     ZRIDDR                                                                                        
c ======================================================================                            
                                                                                                    
                                                                                                    
c **********************************************************************                            
      SUBROUTINE ADD(np1,nr1,np2,nr2,q1,q2,q3,qOut)                                                 
c ======================================================================                            
c This subroutine evaluates the following expression:                                               
c [qOut] = [q1] + [q2] + [q3]. qout, q1, q2 and q2 are matrices of                                  
c physical size (np2,np1) and real size (nr2,nr1).     [Z.I., Nov. 1995]                            
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER  np1, nr1, np2, nr2, i2, i1                                                           
      DOUBLE PRECISION  q1(np2,np1), q2(np2,np1), q3(np2,np1),                                      
     &       qOut(np2,np1)                                                                          
c ----------------------------------------------------------------------                            
c     loop over index 2                                                                             
      DO i2 = 1, nr2                                                                                
c       loop over index 1                                                                           
        DO i1 = 1, nr1                                                                              
          qOut(i2,i1) = q1(i2,i1) +  q2(i2,i1) + q3(i2,i1)                                          
        END DO                                                                                      
      END DO                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
c **********************************************************************                            
      SUBROUTINE ADD2(flxS,flxE,fBSum,nY)                                                           
c ======================================================================                            
c This subroutine is auxiliary for finding the bolometric                                           
c components of the scattered and emitted diffuse flux.   [MN, May'99]                              
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, iY                                                                                
      DOUBLE PRECISION flxS(npL,npY), flxE(npL,npY), flxSB(npY),                                    
     &          flxEB(npY), fBSum(npY)                                                              
c ----------------------------------------------------------------------                            
      CALL Bolom(flxS,flxSB)                                                                        
      CALL Bolom(flxE,flxEB)                                                                        
      DO iY = 1, nY                                                                                 
        fBSum(iY) = flxSB(iY) + flxEB(iY)                                                           
      END DO                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
c **********************************************************************                            
      SUBROUTINE ANALINT(Nanal,xaux,yaux,m,aux,error)                                               
c ======================================================================                            
c This subroutine calculates integral I(x**m*y(x)*dx). Both y and x are                             
c 1D arrays, y(i), x(i) with i=1,Nanal. The method used is approximation                            
c of y(x) by y = P(x) + d/sqrt(1-x*x), where P(x) is the polynomial of                              
c order Nanal-1, and analytic evaluation of the integral. It is assumed                             
c that xaux(1)=0. Coefficients are determined from the set of Nanal                                 
c linear equations and subsequent call to the linear system solver                                  
c LINSYS.                                              [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER i, j, Nanal, error                                                                    
      DOUBLE PRECISION xaux(Nanal), yaux(Nanal), coeff(4), A(npY,npY),                              
     &               m, aux, b                                                                      
c ----------------------------------------------------------------------                            
      error = 0                                                                                     
c     generate matrix A and vector B                                                                
      DO i = 1, Nanal                                                                               
        DO j = 1, Nanal-1                                                                           
          IF (xaux(i).EQ.0.0D+00.AND.j.EQ.1) THEN                                                       
            A(i,j) = 1.0D+00                                                                            
          ELSE                                                                                      
            A(i,j) = xaux(i)**(1.0D+00*j-1.0D+00)                                                           
          END IF                                                                                    
        END DO                                                                                      
        A(i,Nanal) = 1.0D+00/sqrt(1.0D+00-xaux(i)*xaux(i))                                                  
      END DO                                                                                        
                                                                                                    
c     solve for the coefficients                                                                    
      CALL LINSYS(Nanal,A,yaux,coeff,error)                                                         
        IF(error.NE.0) THEN                                                                         
         CALL MSG(19)                                                                               
         iERROR = iERROR + 1                                                                        
         RETURN                                                                                     
        END IF                                                                                      
c     upper limit for integration:                                                                  
      b = xaux(Nanal)                                                                               
c     evaluate m-dependent contribution of the last term                                            
      IF (m.GT.0.1D+00) THEN                                                                            
        IF (m.GT.1.1D+00) THEN                                                                          
c         this is for m=2                                                                           
          aux = 0.5D+00*(DASIN(b)-b*dsqrt(1.0D+00-b*b))                                                       
        ELSE                                                                                        
c         this is for m=1                                                                           
          aux = 1.0D+00 - sqrt(1.0D+00-b*b)                                                                  
        ENDIF                                                                                       
      ELSE                                                                                          
c       this is for m=0                                                                             
        aux = DASIN(b)                                                                              
      ENDIF                                                                                         
      aux = aux * coeff(Nanal)                                                                      
c     add contribution from the polynom                                                             
      DO i = 1, Nanal-1                                                                             
        aux = aux + coeff(i) * (b**(m+1.0D+00*i)) / (m+1.0D+00*i)                                           
      END DO                                                                                        
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION Bessel(x)                                                           
c =======================================================================                           
c This function evaluates the Bessel function of the zeroth kind.                                   
c Formulae are from Abramowitz & Stegun.               [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER i                                                                                     
      DOUBLE PRECISION x, c(6)                                                                      
c -----------------------------------------------------------------------                           
      c(1) = -2.2499997D+00                                                                             
      c(2) =  1.2656208D+00                                                                             
      c(3) = -0.3163866D+00                                                                             
      c(4) =  0.0444479D+00                                                                             
      c(5) = -0.0039444D+00                                                                             
      c(6) =  0.00021D+00                                                                               
      Bessel=0.0D+00                                                                                    
      IF (x.LE.3.0D+00)THEN                                                                             
        DO i=1,6                                                                                    
          Bessel = Bessel + c(i)*(x/3.0D+00)**(2.0D+00*i)                                                   
        END DO                                                                                      
        Bessel = 1.0D+00 + Bessel                                                                       
        ELSE                                                                                        
        Bessel = dsqrt(2.0D+00/Pi/x) * dcos(x-Pi/4.0D+00)                                                    
      ENDIF                                                                                         
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
c This subroutine obtained from prof. P. Menguc, Dept. of Mechanical                                
c Eng., University of Kentucky.                        [Z.I., Aug. 1996]                            
c -----------------------------------------------------------------------                           
c     __________________________________________________________________                            
c                                                                                                   
c     SUBROUTINE BHMIE CALCULATES AMPLITUDE SCATTERING MATRIX ELEMENTS                              
C     & EFFICIENCIES FOR EXTINCTION, TOTAL SCATTERING AND BACSCATTERING,                            
C     FOR A GIVEN SIZE PARAMETER AND RELATIVE REFRACTIVE INDEX                                      
C     __________________________________________________________________                            
C                                                                                                   
      subroutine bhmie (x,refrel,nang,s1,s2,qext,qsca,qback)                                        
      double precision amu(100),theta(100),pi(100),tau(100)
      double precision pi0(100),pi1(100)                              
      integer nang
      complex d(3000),y,refrel,xi,xi0,xi1,an,bn,s1(200),s2(200)                                     
      double precision psi0,psi1,psi,dn,dx,x,qext,qsca,qback                                                          
      dx=x                                                                                          
      y=x*refrel                                                                                    
c     ___________________________________________________________________                           
c     series terminated after nstop terms                                                           
c     ___________________________________________________________________                           
      xstop=x+4.0D+00*x**0.3333D+00 +2.0D+00                                                                      
      nstop=xstop                                                                                   
      ymod=cabs(y)                                                                                  
      nmx=amax1(xstop,ymod) + 15                                                                    
c      dang=1.570796327D+00/float(nang-1)                                                                
      dang=1.570796327D+00/dble(nang-1)                                                                
      do 555 j = 1,nang                                                                             
c      theta(j)= (float(j)-1.0D+00)*dang                                                                  
      theta(j)= (dble(j)-1.0D+00)*dang                                                                  
555   amu(j)=dcos(theta(j))                                                                          
c     __________________________________________________________________                            
c     logarithmic derivative d(j) calculated by downward recurrence                                 
c     beginning with initial value 0.0 + i*0.0 at j = nmx                                           
c     __________________________________________________________________                            
c                                                                                                   
      d(nmx)=cmplx(0.0,0.0)                                                                         
      nn=nmx-1                                                                                      
      do 120 n=1,nn                                                                                 
      rn=nmx-n+1                                                                                    
      d(nmx-n)=(rn/y)-(1.0D+00/(d(nmx-n+1)+rn/y))                                                        
120   continue                                                                                      
      do 666 j=1,nang                                                                               
      pi0(j)=0.0D+00                                                                                    
      pi1(j)=1.0D+00                                                                                    
666   continue                                                                                      
      nn=2*nang-1                                                                                   
      do 777 j=1,nn                                                                                 
      s1(j)=cmplx(0.0,0.0)                                                                          
      s2(j)=cmplx(0.0,0.0)                                                                          
777   continue                                                                                      
c     __________________________________________________________________                            
c     riccati bessel functions with real argument x calculated by upward                            
c     recurrence                                                                                    
c     __________________________________________________________________                            
c                                                                                                   
      psi0=dcos(dx)                                                                                  
      psi1=dsin(dx)                                                                                  
      chi0=-1.0D+00*dsin(x)                                                                                  
      chi1=dcos(x)                                                                                   
      apsi0=psi0                                                                                    
      apsi1=psi1                                                                                    
      xi0=cmplx(apsi0,-chi0)                                                                        
      xi1=cmplx(apsi1,-chi1)                                                                        
      qsca=0.0D+00                                                                                      
      n=1                                                                                           
200   dn=n                                                                                          
      rn=n                                                                                          
      fn=(2.0D+00*rn+1.0D+00)/(rn*(rn+1.0D+00))                                                                    
      psi=(2.0D+00*dn-1.0D+00)*psi1/dx-psi0                                                                   
      apsi=psi                                                                                      
      chi=(2.0D+00*rn-1.0D+00)*chi1/x -  chi0                                                                 
      xi = cmplx(apsi,-chi)                                                                         
      an=(d(n)/refrel+rn/x)*apsi - apsi1                                                            
      an=an/((d(n)/refrel+rn/x)*xi - xi1)                                                           
      bn=(refrel *d(n)+rn/x)*apsi - apsi1                                                           
      bn=bn/((refrel*d(n)+rn/x)*xi - xi1)                                                           
      qsca=qsca+(2.0D+00*rn+1.0D+00)*
     *                     (cabs(an)*cabs(an)+cabs(bn)*cabs(bn))                                    
      do 789 j=1,nang                                                                               
      jj=2*nang-j                                                                                   
      pi(j)=pi1(j)                                                                                  
      tau(j)=rn*amu(j)*pi(j) - (rn+1.)*pi0(j)                                                       
      p=(-1.0D+00)**(n-1)                                                                                
      s1(j)=s1(j)+fn*(an*pi(j)+bn*tau(j))                                                           
      t=(-1.0D+00)**n                                                                                    
      s2(j)=s2(j) + fn*(an*tau(j)+bn*pi(j))                                                         
      if (j .eq. jj) go to 789                                                                      
      s1(jj)=s1(jj) + fn*(an*pi(j)*p + bn*tau(j)*t)                                                 
      s2(jj)=s2(jj) + fn*(an*tau(j)*t + bn*pi(j)*p)                                                 
789   continue                                                                                      
      psi0=psi1                                                                                     
      psi1=psi                                                                                      
      apsi1=psi1                                                                                    
      chi0=chi1                                                                                     
      chi1=chi                                                                                      
      xi1=cmplx(apsi1,-chi1)                                                                        
      n=n+1                                                                                         
      rn=n                                                                                          
      do 999 j=1,nang                                                                               
      pi1(j)=((2.0D+00*rn-1.0D+00)/(rn-1.0D+00))*amu(j)*pi(j)                                                      
      pi1(j)=pi1(j) - rn*pi0(j)/(rn-1.0D+00)                                                             
      pi0(j) = pi(j)                                                                                
999   continue                                                                                      
      if((n-1-nstop).ge.0)then 
         go to 300 
      else 
         go to 200 
      endif                                                              
300   qsca=(2.0D+00/(x*x))*qsca                                                                          
      qext=(4.0D+00/(x*x))*real(s1(1))                                                                   
      qback=(4.0D+00/(x*x))*cabs(s1(2*nang -1))*cabs(s1(2*nang -1))                                      
      return                                                                                        
      end                                                                                           
c ***********************************************************************                           
                                                                                                    
c***********************************************************************                            
      SUBROUTINE ChkAngle(angle)                                                                    
c=======================================================================                            
c     Checks if the input angles are in [0,85] degrees interval.  [MN,2005]                         
c=======================================================================                            
      IMPLICIT none                                                                                 
	INTEGER error                                                                                      
      DOUBLE PRECISION angle                                                                        
c-----------------------------------------------------------------------                            
      IF (angle.gt.85.0D+00) THEN                                                                       
       write(12,*)' ********** Message from INPUT: ***************'                                 
       write(12,*)' * Slab illumination angles have to be in the *'                                 
       write(12,*)' * range [0,85] degrees. Setting the maximum  *'                                 
       write(12,*)' * illumination angle to 85 degrees.          *'                                 
       write(12,*)' **********************************************'                                 
       angle = 85.0D+00                                                                                 
      ELSE IF (angle.lt.0.0D+00) THEN                                                                   
       write(12,*)' ********** Message from INPUT: ***************'                                 
       write(12,*)' * Slab illumination angles have to be in the *'                                 
       write(12,*)' * range [0,85] degrees. Setting the miminum  *'                                 
       write(12,*)' * illumination angle to 0.0 degrees.         *'                                 
       write(12,*)' **********************************************'                                 
      END IF                                                                                        
c-----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c***********************************************************************                            
                                                                                                    
c***********************************************************************                            
      SUBROUTINE CHKRANGE(dr,x)                                                                     
c=======================================================================                            
c This subroutine checks if x is within the allowed range defined by                                
c dr<<1:                                                                                            
c         dr**2 < x < 1/dr**2                                                                       
c If it is not then x = 0.0                            [Z.I., Jan. 1997]                            
c=======================================================================                            
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x, dr                                                                        
c-----------------------------------------------------------------------                            
      IF ((x-dr*dr)*(x-1.0D+00/dr/dr).LT.0.0D+00) THEN                                                       
        continue                                                                                    
      ELSE                                                                                          
c        continue                                                                                   
        x = 0.0D+00                                                                                     
      END IF                                                                                        
c-----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c***********************************************************************                            
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CHKSPLIN(x,fun,funmid,N,coef,maxerr,RDW)                                           
c ======================================================================                            
c This subroutine checks the spline coefficients coef(i,j):                                         
c fun(x)=coef(i,1) + coef(i,2)*x + coef(i,3)*x^2 + coef(i,4)*x^3,                                   
c for x(i).LE.x.LE.x(i+1) with i=1..N. Array funmid(1..N-1) contains the                            
c values of function fun at mid points defined as                                                   
c xmid(i)=SQRT(x(i)*x(i+1). If spline approximation produces error                                  
c greater than maxerr, or funmid<0, a straight line is produced between                             
c x(i) and x(i+1).                                   [Z.I., Feb. 1995]                              
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER N, i, iC                                                                              
      DOUBLE PRECISION x(npY), fun(npY), funmid(npY), coef(npY,4),                                  
     &       maxerr, error, slope, xmid, funSpline, aux, power, yR, yL                              
      LOGICAL RDW                                                                                   
c ---------------------------------------------------------                                         
c       check the midpoints                                                                         
        DO i = 1, N - 1                                                                             
          xmid = dsqrt(x(i)*x(i+1))                                                                 
          funSpline = 0.0D+00                                                                           
          DO iC=1,4                                                                                 
            IF (xmid.EQ.0.0D+00.AND.iC.EQ.1) THEN                                                       
              aux = 1.0D+00                                                                             
              ELSE                                                                                  
c              aux = xmid**(float(iC)-1.0D+00)                                                           
              aux = xmid**(dble(iC)-1.0D+00)                                                           
            END IF                                                                                  
            funSpline = funSpline + coef(i,iC)*aux                                                  
          END DO                                                                                    
          error = DABS((funSpline - funmid(i))/funmid(i))                                             
c         check for the deviation at the midpoint                                                   
          IF (error.GE.maxerr.OR.funSpline.LE.0.0) THEN                                             
            slope = (fun(i+1) - fun(i)) / (x(i+1)-x(i))                                             
            coef(i,1) = fun(i) - x(i) * slope                                                       
            coef(i,2) = slope                                                                       
            coef(i,3) = 0.0D+00                                                                         
            coef(i,4) = 0.0D+00                                                                         
          END IF                                                                                    
c         check for the logarithmic derivative (only for RDW)                                       
          IF(RDW) THEN                                                                              
            yL = fun(i)                                                                             
            yR = fun(i+1)                                                                           
            IF (x(i)*x(i+1).GT.0.AND.yL*yR.GT.0) THEN                                               
              power = log(yR/yL)/log(x(i+1)/x(i))                                                   
              IF (abs(power).GT.10.) THEN                                                           
                slope = (yR - yL) / (x(i+1)-x(i))                                                   
                coef(i,1) = yL - x(i) * slope                                                       
                coef(i,2) = slope                                                                   
                coef(i,3) = 0.0D+00                                                                     
                coef(i,4) = 0.0D+00                                                                     
              END IF                                                                                
            END IF                                                                                  
          END IF                                                                                    
        END DO                                                                                      
c ---------------------------------------------------------                                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CHKSPLINold(x,fun,funmid,N,coef,maxerr)                                            
c =======================================================================                           
c This subroutine checks the spline coefficients coef(i,j):                                         
c fun(x)=coef(i,1) + coef(i,2)*x + coef(i,3)*x^2 + coef(i,4)*x^3,                                   
c for x(i).LE.x.LE.x(i+1) with i=1..N. Array funmid(1..N-1) contains the                            
c values of function fun at mid points defined as                                                   
c xmid(i)=SQRT(x(i)*x(i+1). If spline approximation produces error                                  
c greater than maxerr, or funmid<0, a straight line is produced between                             
c x(i) and x(i+1).                                     [Z.I., Feb. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER N, i, iC                                                                              
      DOUBLE PRECISION x(npY), fun(npY), funmid(npY), coef(npY,4), aux,                             
     &     funSpline, maxerr, error, slope, xmid                                                    
c -----------------------------------------------------------------------                           
c       check the midpoints                                                                         
        DO i = 1, N - 1                                                                             
          xmid = dsqrt(x(i)*x(i+1))                                                                 
          funSpline = 0.0D+00                                                                           
          DO iC=1,4                                                                                 
            IF (xmid.EQ.0.0D+00.AND.iC.EQ.1) THEN                                                       
              aux = 1.0D+00                                                                             
              ELSE                                                                                  
              aux = xmid**(dble(iC)-1.0D+00)                                                           
c              aux = xmid**(float(iC)-1.0)                                                           
            END IF                                                                                  
            funSpline = funSpline + coef(i,iC)*aux                                                  
          END DO                                                                                    
          error = DABS((funSpline -funmid(i))/funmid(i))                                             
          IF (error.GE.maxerr.OR.funSpline.LE.0.0D+00) THEN                                             
            slope = (fun(i+1) - fun(i)) / (x(i+1)-x(i))                                             
            coef(i,1) = fun(i) - x(i) * slope                                                       
            coef(i,2) = slope                                                                       
            coef(i,3) = 0.0D+00                                                                         
            coef(i,4) = 0.0D+00                                                                         
          END IF                                                                                    
        END DO                                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c *************************************************************************                         
      SUBROUTINE FindErr(fbol,maxFerr,nY)                                                           
c ========================================================================                          
c This subroutine finds maximum err in flux conservation for both                                   
c spherical and slab case as (fmax-fmin)/(fmax+fmin)   [MN,Aug'99]                                  
c =========================================================================                         
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER nY, iY                                                                                
      DOUBLE PRECISION fbol(npY), maxFerr, fmin, fmax, aux    
!      REAL*8 fbol(npY), maxFerr, fmin, fmax, aux                                          
c -----------------------------------------------------------------------                           
c     Find the min and max of fbol values                                                           
c     The abs and lower limit on fbol are protection for the case                                   
c     of completely symmetric slab illumination. The lower limit                                    
c     is bound by the numerical accuracy of the flux calculation                                    
        fmin = 1.0D+50                                                                                   
        fmax = 0.0D+00                                                                               
        DO iY = 1, nY                                                                               
           aux = fbol(iY)                                                                           
           IF (ksi.eq.1.0D+00) aux = dabs(aux)                                                          
           IF (dabs(aux).LE.accFbol) aux = accFbol                                                  
           IF(aux.LT.fmin) fmin = aux                                                               
           IF(aux.GT.fmax) fmax = aux                                                               
        END DO                                                                                      
        if (fmax.LT.0.0D+00) then                                                                        
c     bad solution; overall flux cannot be negative                                                 
            maxFerr = 1                                                                             
c           write(6,'(3E12.3)') fmax, fmin,maxferr

        else                                                                              
           maxFerr = (fmax - fmin)/(fmax + dabs(fmin))                                             
c           write(6,'(3E12.3)') fmax, fmin,maxferr

        end if
c -----------------------------------------------------------------------                           
      RETURN
      END
c *************************************************************************


c ***********************************************************************                           
      SUBROUTINE FindMax(NN,i1,i2,A,Amax)                                                           
c =======================================================================                           
c This subroutine finds maximum values, Amax, of an array A(nY) between                             
c values A(i1) and A(i2).                              [Z.I., Jul. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NN, i1, i2, i                                                                         
      DOUBLE PRECISION A(NN), Amax                                                                  
c -----------------------------------------------------------------------                           
      Amax = A(i1)                                                                                  
c     loop over radial positions                                                                    
      DO i = i1, i2                                                                                 
        IF (A(i).GT.Amax) Amax = A(i)                                                               
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c =======================================================================                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE FindRMS(typ,X,val,accur,N)                                                         
c =======================================================================                           
c Finds relative deviations 'accur' of an array X(N) from a given value val.                        
c For typ=1 accur is maximal deviation, and for typ=2 the rms deviation.                            
c                                                         [ZI'95; MN'99]                            
c =======================================================================                           
      IMPLICIT NONE                                                                                 
      INTEGER N, i, typ                                                                             
      DOUBLE PRECISION X(N), val, accur, ss, dev                                                    
c -----------------------------------------------------------------------                           
      IF (typ.EQ.1) THEN                                                                            
        accur = 0.0D+00                                                                                 
        DO i = 1, N                                                                                 
          dev = (X(i)-val)/val                                                                      
          IF (DABS(dev).GT.accur) accur = DABS(dev)                                                 
        END DO                                                                                      
      ELSE                                                                                          
        ss = 0.0D+00                                                                                    
        DO i = 1, N                                                                                 
          dev = X(i)-val                                                                            
          ss = ss + dev*dev                                                                         
        END DO                                                                                      
        accur = dsqrt(ss/N/(N-1.0D+00))                                                                   
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION H(x1,x2)                                                            
c =======================================================================                           
c This function calculates the step function: H=1 for x1 >= x2 and H=0                              
c for x1 < x2.                                         [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x1, x2                                                                       
c -----------------------------------------------------------------------                           
      IF (x1.GE.x2) THEN                                                                            
        H = 1.0D+00                                                                                     
      ELSE                                                                                          
        H = 0.0D+00                                                                                     
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      INTEGER FUNCTION Kron(i1,i2)                                                                  
c =======================================================================                           
c This function is Kronecker delta-function defined as:                                             
c Kron(i1,i2) = 1 for i1=i2                                                                         
c Kron(i1,i2) = 0 otherwise.                           [Z.I., Dec. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER i1, i2                                                                                
c -----------------------------------------------------------------------                           
      IF (i1.EQ.i2) THEN                                                                            
        Kron = 1                                                                                    
      ELSE                                                                                          
        Kron = 0                                                                                    
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE LinInter(NN,N,x,y,xloc,iNloc,yloc)                                                 
c =======================================================================                           
c This subroutine performs linear interpolation for y(x) such that                                  
c yloc = y(xloc). It is assumed that x is monotonously increasing.                                  
c                                                      [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NN, N, i, istop, iNloc                                                                
      DOUBLE PRECISION x(NN), y(NN), xloc, yloc                                                     
c -----------------------------------------------------------------------                           
      IF (N.GT.1) THEN                                                                              
        IF ((x(1)-xloc)*(x(N)-xloc).LE.0.0D+00) THEN                                                    
          istop = 0                                                                                 
          i = 1                                                                                     
          DO WHILE (istop.NE.1)                                                                     
            i = i + 1                                                                               
            IF (i.GT.N) stop 'LinInter ???'                                                         
            IF (x(i).GE.xloc) THEN                                                                  
              istop = 1                                                                             
              iNloc = i                                                                             
              yloc = y(i-1) + (y(i)-y(i-1))/(x(i)-x(i-1))*(xloc-x(i-1))                             
            END IF                                                                                  
          END DO                                                                                    
          ELSE                                                                                      
          IF (xloc.LE.x(1)) yloc = y(1)                                                             
          IF (xloc.GE.x(N)) yloc = y(N)                                                             
        END IF                                                                                      
        ELSE                                                                                        
        yloc = y(1)                                                                                 
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE LINSYS(Nreal,A,B,X,error)                                                          
c =======================================================================                           
c This subroutine solves the set of linear equations [A]*[X] = [B] for                              
c X [A(k,1)*X(1)+A(k,2)*X(2)+...+A(k,Nreal)*X(Nreal) = B(k), k=1,Nreal).                            
c The real size of matrix A is Nreal x Nreal and its physical dimension                             
c is npY x npY, where npY comes from INCLUDE 'userpar.inc'. Both vectors                            
c B and X have real lengths Nreal. The set is solved by calls to LUDCMP                             
c and LUBKSB and the solution is improved subsequently by a call to                                 
c MPROVE. These three subroutines are taken from Numerical Recipes.                                 
c                                                      [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER Nreal, indx(npY), i, j, error                                                         
      DOUBLE PRECISION A(npY,npY), B(npY), X(npY)                                                   
      DOUBLE PRECISION A1(npY,npY), B1(npY), A2(npY,npY), B2(npY), d                                
c -----------------------------------------------------------------------                           
      error = 0                                                                                     
c generate DOUBLE PRECISION copies of A and B (two copies because they                              
c are changed in LUDCMP and LUBKSB, but still needed for MPROVE)                                    
      DO i = 1, Nreal                                                                               
        B1(i) = B(i)                                                                                
        B2(i) = B(i)                                                                                
        DO j = 1, Nreal                                                                             
           A1(i,j) = A(i,j)                                                                         
           A2(i,j) = A(i,j)                                                                         
        END DO                                                                                      
      END DO                                                                                        
c     solve the system                                                                              
      CALL LUDCMP(A1,Nreal,npY,indx,d,error)                                                        
      IF (error.NE.0) RETURN                                                                        
      CALL LUBKSB(A1,Nreal,npY,indx,B1)                                                             
c     improve the solution (saved in B)                                                             
      CALL MPROVE(A2,A1,Nreal,npY,indx,B2,B1)                                                       
c     copy the improved solution to output vector X                                                 
      DO i = 1, Nreal                                                                               
        X(i) = B1(i)                                                                                
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE LUBKSB(A,N,NP,INDX,B)                                                              
c =======================================================================                           
      implicit none
      integer ii,i,j,ll,n,np,indx(np)                                                                    
      DOUBLE PRECISION A(NP,NP),B(NP),sum                                                              
c -------------------------------------------------------------------                               
      II=0                                                                                          
      DO 12 I=1,N                                                                                   
      LL=INDX(I)                                                                                    
      SUM=B(LL)                                                                                     
      B(LL)=B(I)                                                                                    
      IF (II.NE.0)THEN                                                                              
        DO 11 J=II,I-1                                                                              
          SUM=SUM-A(I,J)*B(J)                                                                       
11        CONTINUE                                                                                  
      ELSE IF (SUM.NE.0.0D+00) THEN                                                                      
        II=I                                                                                        
      ENDIF                                                                                         
      B(I)=SUM                                                                                      
12    CONTINUE                                                                                      
      DO 14 I=N,1,-1                                                                                
      SUM=B(I)                                                                                      
      IF(I.LT.N)THEN                                                                                
        DO 13 J=I+1,N                                                                               
          SUM=SUM-A(I,J)*B(J)                                                                       
13        CONTINUE                                                                                  
      ENDIF                                                                                         
      B(I)=SUM/A(I,I)                                                                               
14    CONTINUE                                                                                      
c -------------------------------------------------------------------                               
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
c$$$c ***********************************************************************                           
c$$$      SUBROUTINE LUBKSB(A,N,NP,INDX,B)                                                              
c$$$c =======================================================================                           
c$$$      DIMENSION INDX(NP)                                                                            
c$$$      DOUBLE PRECISION A(NP,NP),B(NP)                                                               
c$$$c -------------------------------------------------------------------                               
c$$$      II=0                                                                                          
c$$$      DO 12 I=1,N                                                                                   
c$$$      LL=INDX(I)                                                                                    
c$$$      SUM=B(LL)                                                                                     
c$$$      B(LL)=B(I)                                                                                    
c$$$      IF (II.NE.0)THEN                                                                              
c$$$        DO 11 J=II,I-1                                                                              
c$$$          SUM=SUM-A(I,J)*B(J)                                                                       
c$$$11        CONTINUE                                                                                  
c$$$      ELSE IF (SUM.NE.0.) THEN                                                                      
c$$$        II=I                                                                                        
c$$$      ENDIF                                                                                         
c$$$      B(I)=SUM                                                                                      
c$$$12    CONTINUE                                                                                      
c$$$      DO 14 I=N,1,-1                                                                                
c$$$      SUM=B(I)                                                                                      
c$$$      IF(I.LT.N)THEN                                                                                
c$$$        DO 13 J=I+1,N                                                                               
c$$$          SUM=SUM-A(I,J)*B(J)                                                                       
c$$$13        CONTINUE                                                                                  
c$$$      ENDIF                                                                                         
c$$$      B(I)=SUM/A(I,I)                                                                               
c$$$14    CONTINUE                                                                                      
c$$$c -------------------------------------------------------------------                               
c$$$      RETURN                                                                                        
c$$$      END                                                                                           
c$$$c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE LUDCMP(A,N,NP,INDX,D,error)                                                        
c =======================================================================                           
      IMPLICIT NONE
      INTEGER N,NP,NMAX
      DOUBLE PRECISION TINY
      PARAMETER (NMAX=10000,TINY=1.0D-20)  
      INTEGER error,indx(nP),i,j,k,iMax                                                                                 
      DOUBLE PRECISION A(NP,NP),VV(NMAX), D, SUM,AAMAX,dum                                                    
                                                         
c  -------------------------------------------------------------------                               
      error = 0                                                                                     
      D = 1.0D+00                                                                                        
      DO I = 1, N                                                                                   
       AAMAX=0.0D+00                                                                                     
       DO J = 1, N                                                                                  
        IF (DABS(A(I,J)).GT.AAMAX) AAMAX=DABS(A(I,J))                                               
       END DO                                                                                       
c       IF (AAMAX.EQ.0.) PAUSE 'Singular matrix.'                                                   
       IF (AAMAX.EQ.0.0D+00) THEN                                                                        
        error = 5                                                                                   
        RETURN                                                                                      
       ENDIF                                                                                        
       VV(I)=1.0D+00/AAMAX                                                                               
      END DO                                                                                        
      DO J = 1 , N                                                                                  
       IF (J.GT.1) THEN                                                                             
        DO I = 1, J-1                                                                               
          SUM=A(I,J)                                                                                
          IF (I.GT.1)THEN                                                                           
            DO K = 1, I-1                                                                           
             SUM=SUM-A(I,K)*A(K,J)                                                                  
            END DO                                                                                  
            A(I,J)=SUM                                                                              
          ENDIF                                                                                     
        END DO                                                                                      
       ENDIF                                                                                        
       AAMAX=0.0D+00                                                                                     
       DO I = J, N                                                                                  
        SUM=A(I,J)                                                                                  
        IF (J.GT.1)THEN                                                                             
          DO K = 1, J-1                                                                             
            SUM=SUM-A(I,K)*A(K,J)                                                                   
          END DO                                                                                    
          A(I,J)=SUM                                                                                
        ENDIF                                                                                       
        DUM=VV(I)*DABS(SUM)                                                                         
        IF (DUM.GE.AAMAX) THEN                                                                      
          IMAX=I                                                                                    
          AAMAX=DUM                                                                                 
        ENDIF                                                                                       
       END DO                                                                                       
       IF (J.NE.IMAX)THEN                                                                           
        DO K = 1, N                                                                                 
          DUM=A(IMAX,K)                                                                             
          A(IMAX,K)=A(J,K)                                                                          
          A(J,K)=DUM                                                                                
        END DO                                                                                      
        D=-D                                                                                        
        VV(IMAX)=VV(J)                                                                              
       ENDIF                                                                                        
       INDX(J)=IMAX                                                                                 
       IF(J.NE.N)THEN                                                                               
        IF(A(J,J).EQ.0.)A(J,J)=TINY                                                                 
        DUM=1./A(J,J)                                                                               
        DO I = J+1, N                                                                               
          A(I,J)=A(I,J)*DUM                                                                         
        END DO                                                                                      
       ENDIF                                                                                        
      END DO                                                                                        
      IF(A(N,N).EQ.0.0D+00)A(N,N)=TINY                                                                   
c -------------------------------------------------------------------                               
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
c$$$c ***********************************************************************                           
c$$$      SUBROUTINE LUDCMP(A,N,NP,INDX,D,error)                                                        
c$$$c =======================================================================                           
c$$$      PARAMETER (NMAX=10000,TINY=1.0D-20)                                                           
c$$$      DIMENSION INDX(NP)                                                                            
c$$$      INTEGER error                                                                                 
c$$$      DOUBLE PRECISION A(NP,NP),VV(NMAX), D, SUM                                                    
c$$$c -------------------------------------------------------------------                               
c$$$      error = 0                                                                                     
c$$$      D = 1.                                                                                        
c$$$      DO I = 1, N                                                                                   
c$$$       AAMAX=0.                                                                                     
c$$$       DO J = 1, N                                                                                  
c$$$        IF (DABS(A(I,J)).GT.AAMAX) AAMAX=DABS(A(I,J))                                               
c$$$       END DO                                                                                       
c$$$c       IF (AAMAX.EQ.0.) PAUSE 'Singular matrix.'                                                   
c$$$       IF (AAMAX.EQ.0.) THEN                                                                        
c$$$        error = 5                                                                                   
c$$$        RETURN                                                                                      
c$$$       ENDIF                                                                                        
c$$$       VV(I)=1./AAMAX                                                                               
c$$$      END DO                                                                                        
c$$$      DO J = 1 , N                                                                                  
c$$$       IF (J.GT.1) THEN                                                                             
c$$$        DO I = 1, J-1                                                                               
c$$$          SUM=A(I,J)                                                                                
c$$$          IF (I.GT.1)THEN                                                                           
c$$$            DO K = 1, I-1                                                                           
c$$$             SUM=SUM-A(I,K)*A(K,J)                                                                  
c$$$            END DO                                                                                  
c$$$            A(I,J)=SUM                                                                              
c$$$          ENDIF                                                                                     
c$$$        END DO                                                                                      
c$$$       ENDIF                                                                                        
c$$$       AAMAX=0.                                                                                     
c$$$       DO I = J, N                                                                                  
c$$$        SUM=A(I,J)                                                                                  
c$$$        IF (J.GT.1)THEN                                                                             
c$$$          DO K = 1, J-1                                                                             
c$$$            SUM=SUM-A(I,K)*A(K,J)                                                                   
c$$$          END DO                                                                                    
c$$$          A(I,J)=SUM                                                                                
c$$$        ENDIF                                                                                       
c$$$        DUM=VV(I)*DABS(SUM)                                                                         
c$$$        IF (DUM.GE.AAMAX) THEN                                                                      
c$$$          IMAX=I                                                                                    
c$$$          AAMAX=DUM                                                                                 
c$$$        ENDIF                                                                                       
c$$$       END DO                                                                                       
c$$$       IF (J.NE.IMAX)THEN                                                                           
c$$$        DO K = 1, N                                                                                 
c$$$          DUM=A(IMAX,K)                                                                             
c$$$          A(IMAX,K)=A(J,K)                                                                          
c$$$          A(J,K)=DUM                                                                                
c$$$        END DO                                                                                      
c$$$        D=-D                                                                                        
c$$$        VV(IMAX)=VV(J)                                                                              
c$$$       ENDIF                                                                                        
c$$$       INDX(J)=IMAX                                                                                 
c$$$       IF(J.NE.N)THEN                                                                               
c$$$        IF(A(J,J).EQ.0.)A(J,J)=TINY                                                                 
c$$$        DUM=1./A(J,J)                                                                               
c$$$        DO I = J+1, N                                                                               
c$$$          A(I,J)=A(I,J)*DUM                                                                         
c$$$        END DO                                                                                      
c$$$       ENDIF                                                                                        
c$$$      END DO                                                                                        
c$$$      IF(A(N,N).EQ.0.)A(N,N)=TINY                                                                   
c$$$c -------------------------------------------------------------------                               
c$$$      RETURN                                                                                        
c$$$      END                                                                                           
c$$$c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Maple3(w,z,p,MpInt)                                                                
c =======================================================================                           
c This function calculates indefinite integral:                                                     
c    MpInt(iC) = INT(w^(2-iC) / sqrt(w^2-p^2) * dw), for iC=1,2,3,4.                                
c                                                      [Z.I., Apr. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      DOUBLE PRECISION w, z, p, MpInt(4)                                                            
c -----------------------------------------------------------------------                           
c     integrals                                                                                     
      MpInt(1) = z                                                                                  
      MpInt(2) = dlog(w+z)                                                                          
      IF (p.GT.0.0D+00) THEN                                                                            
        MpInt(3) = dacos(p/w)/p                                                                     
        MpInt(4) = z/w/p/p                                                                          
        ELSE                                                                                        
        MpInt(3) = -1.0D+00 / w                                                                         
        MpInt(4) = -0.5D+00 / w / w                                                                     
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE midsql(funk,aa,bb,s,n)                                                             
c =======================================================================                           
      IMPLICIT NONE
      INTEGER n                                                                                     
      DOUBLE PRECISION aa,bb,s,funk                                                                 
      EXTERNAL funk                                                                                 
      INTEGER it,j                                                                                  
      DOUBLE PRECISION ddel,del,sum,tnm,x,func,a,b                                                  
c -----------------------------------------------------------------------                           
      func(x)=2.0D+00*x*funk(aa+x**2.0D+00)                                                                    
      b=dsqrt(bb-aa)                                                                                
      a=0.0D+00                                                                                          
      if (n.eq.1) then                                                                              
        s=(b-a)*func(0.5D+00*(a+b))                                                                     
      else                                                                                          
        it=3**(n-2)                                                                                 
        tnm=it                                                                                      
        del=(b-a)/(3.0D+00*tnm)                                                                          
        ddel=del+del                                                                                
        x=a+0.5D+00*del                                                                                 
        sum=0.0D+00                                                                                      
        do 11 j=1,it                                                                                
          sum=sum+func(x)                                                                           
          x=x+ddel                                                                                  
          sum=sum+func(x)                                                                           
          x=x+del                                                                                   
11      continue                                                                                    
        s=(s+(b-a)*sum/tnm)/3.0D+00                                                                      
      endif                                                                                         
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MPROVE(A,ALUD,N,NP,INDX,B,X)                                                       
c =======================================================================                           
      IMPLICIT NONE
      integer N,Np,Nmax
      PARAMETER (NMAX=10000)                                                                        
      INTEGER INDX(N),i,j                                                                             
      DOUBLE PRECISION SDP,A(NP,NP),ALUD(NP,NP),B(N),X(N),R(NMAX)                                   
c -----------------------------------------------------------------------                           
      DO i = 1, N                                                                                   
       SDP = -B(i)                                                                                  
       DO j = 1, N                                                                                  
         SDP = SDP + A(i,j)*X(j)                                                                    
       END DO                                                                                       
       R(i) = SDP                                                                                   
      END DO                                                                                        
      CALL LUBKSB(ALUD,N,NP,INDX,R)                                                                 
      DO i = 1, N                                                                                   
       X(i) = X(i) - R(i)                                                                           
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
c$$$c ***********************************************************************                           
c$$$      SUBROUTINE MPROVE(A,ALUD,N,NP,INDX,B,X)                                                       
c$$$c =======================================================================                           
c$$$      PARAMETER (NMAX=10000)                                                                        
c$$$      DIMENSION INDX(N)                                                                             
c$$$      DOUBLE PRECISION SDP,A(NP,NP),ALUD(NP,NP),B(N),X(N),R(NMAX)                                   
c$$$c -----------------------------------------------------------------------                           
c$$$      DO i = 1, N                                                                                   
c$$$       SDP = -B(i)                                                                                  
c$$$       DO j = 1, N                                                                                  
c$$$         SDP = SDP + A(i,j)*X(j)                                                                    
c$$$       END DO                                                                                       
c$$$       R(i) = SDP                                                                                   
c$$$      END DO                                                                                        
c$$$      CALL LUBKSB(ALUD,N,NP,INDX,R)                                                                 
c$$$      DO i = 1, N                                                                                   
c$$$       X(i) = X(i) - R(i)                                                                           
c$$$      END DO                                                                                        
c$$$c -----------------------------------------------------------------------                           
c$$$      RETURN                                                                                        
c$$$      END                                                                                           
c$$$c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MULTIPLY(type,np1,nr1,np2,nr2,mat,vec1,omat,flag,q1,q2)                            
c =======================================================================                           
c This subroutine evaluates the following expression:                                               
c [q2] = flag*[q1] + [mat]*[tt*vec1]. Here tt is [omat] for type=1 and                              
c 1-[omat] for type=2. mat is matrix of physical size (np2,np1,np1) and                             
c real size (nr2,nr1,nr1). omat, vec1, q1 and q2 are matrices of                                    
c physical size (np2,np1) and real size (nr2,nr1).     [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER type, np1, nr1, np2, nr2, flag, i2, i1, idum                                          
      DOUBLE PRECISION mat(np2,np1,np1), vec1(np2,np1), omat(np2,np1),                              
     &       aux, q1(np2,np1), q2(np2,np1)                                                          
c -----------------------------------------------------------------------                           
c     loop over index 2                                                                             
      DO i2 = 1, nr2                                                                                
c       loop over index 1                                                                           
        DO i1 = 1, nr1                                                                              
          q2(i2,i1) = flag * q1(i2,i1)                                                              
c         loop over dummy index (multiplication)                                                    
          DO idum = 1, nr1                                                                          
            IF (type.EQ.1) THEN                                                                     
              aux = omat(i2,idum)                                                                   
              ELSE                                                                                  
              aux = 1.0D+00 - omat(i2,idum)                                                             
            END IF                                                                                  
            q2(i2,i1) = q2(i2,i1) + mat(i2,i1,idum)*aux*vec1(i2,idum)                               
          END DO                                                                                    
          IF (q2(i2,i1).LT.dynrange*dynrange) q2(i2,i1) = 0.0D+00                                       
        END DO                                                                                      
      END DO                                                                                        
                                                                                                    
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MULTIP2(type,np1,nr1,np2,nr2,nr3,np3,mat,vec1,omat,q1)                             
c =======================================================================                           
c This subroutine evaluates the following expression:                                               
c [q1] = [mat]*[tt*vec1] / 4Pi. Here tt is [omat] for type=1 and                                    
c 1-[omat] for type=2. mat is matrix of physical size (np2,np3,np1) and                             
c real size (nr2,nr3,nr1). omat and vec1 are matrices of physical size                              
c (np2,np1) and real size (nr2,nr1). q1 is a matrix of physical size                                
c (np2,np3) and real size (nr2,nr3)                                                                 
c 1, 2 and 3 correspond to nY, nL and nP.              [Z.I., Nov. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER type, np1, nr1, np2, nr2, np3, nr3, i2, i3, idum                                      
      DOUBLE PRECISION mat(np2,np3,np1), vec1(np2,np1), omat(np2,np1),                              
     &       aux, q1(np2,np3)                                                                       
c -----------------------------------------------------------------------                           
c     loop over index 2 (wavelength)                                                                
      DO i2 = 1, nr2                                                                                
c       loop over index 3 (impact parameter)                                                        
        DO i3 = 1, nr3                                                                              
          q1(i2,i3) = 0.0D+00                                                                           
c         loop over dummy index (multiplication)                                                    
          DO idum = 1, nr1                                                                          
            IF (type.EQ.1) THEN                                                                     
              aux = omat(i2,idum)                                                                   
            ELSE                                                                                    
              aux = 1.0D+00 - omat(i2,idum)                                                             
            END IF                                                                                  
            q1(i2,i3) = q1(i2,i3) + mat(i2,i3,idum)*aux*vec1(i2,idum)                               
          END DO                                                                                    
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE MYSPLINE(x,N,alpha,beta,gamma,delta)                                               
c =======================================================================                           
c This subroutine finds arrays alpha, beta, gamma and delta describing                              
c a cubic spline approximation of an unknown function f(x) given as an                              
c array f(i)=f(x(i)) with i=1..N. The cubic spline approximation is:                                
c f(x)=a(i) + b(i)*t + c(i)*t^2 + d(i)*t^3  for x(i).LE.x.LE.x(i+1)                                 
c and t = (x-x(i))/(x(i+1)-x(i)), i=1..N-1. Coefficients a,b,c,d are                                
c equal to:                                                                                         
c a(i) = alpha(i,1)*f(1) + alpha(i,2)*f(2) + ... + alpha(i,N)*f(N)                                  
c and b,c,d analogously.                               [Z.I., Dec. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER N, i, j, dummy, Kron                                                                  
      DOUBLE PRECISION x(npY), alpha(npY,npY), beta(npY,npY),                                       
     &       delta(npY,npY), secnder(npY,npY), yaux(npY), deraux(npY),                              
     &       y2at1, y2atN, D, gamma(npY,npY)                                                        
      EXTERNAL Kron                                                                                 
c -----------------------------------------------------------------------                           
c     generate second derivatives, secnder(j,l)                                                     
      DO j = 1, N                                                                                   
        DO dummy = 1, N                                                                             
          IF (dummy.EQ.j) THEN                                                                      
            yaux(dummy) = 1.0D+00                                                                       
            ELSE                                                                                    
            yaux(dummy) = 0.0D+00                                                                       
          END IF                                                                                    
        END DO                                                                                      
        y2at1 = (yaux(2)-yaux(1))/(x(2)-x(1))                                                       
        y2atN = (yaux(N)-yaux(N-1))/(x(N)-x(N-1))                                                   
        CALL SPLINE(x,yaux,N,y2at1,y2atN,deraux)                                                    
        DO i = 1, N                                                                                 
          secnder(i,j) =  deraux(i)                                                                 
c          secnder(i,j) = 0.0                                                                       
        END DO                                                                                      
      END DO                                                                                        
c     generate alpha, beta, gamma, delta                                                            
      DO i = 1, N-1                                                                                 
        D = (x(i+1) - x(i))*(x(i+1) - x(i)) / 6.0D+00                                                   
        DO j = 1, N                                                                                 
          alpha(i,j) = Kron(i,j)*1.0D+00                                                                
          beta(i,j) = Kron(i+1,j) - Kron(i,j)                                                       
          beta(i,j) = beta(i,j)-D*(2.0D+00*secnder(i,j)+secnder(i+1,j))                                
          gamma(i,j) = 3.0D+00 * D * secnder(i,j)                                                        
          delta(i,j) = D*(secnder(i+1,j)-secnder(i,j))                                              
        END DO                                                                                      
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE polint(xa,ya,n,x,y,dy)                                                             
c =======================================================================                           
      implicit none
      INTEGER n,NMAX                                                                                
      DOUBLE PRECISION dy,x,y,xa(n),ya(n)                                                           
      PARAMETER (NMAX=10)                                                                           
      INTEGER i,m,ns                                                                                
      DOUBLE PRECISION den,dif,dift,ho,hp,w,c(NMAX),d(NMAX)                                         
c -----------------------------------------------------------------------                           
      ns=1                                                                                          
      dif=DABS(x-xa(1))                                                                             
      do 11 i=1,n                                                                                   
        dift=DABS(x-xa(i))                                                                          
        if (dift.lt.dif) then                                                                       
          ns=i                                                                                      
          dif=dift                                                                                  
        endif                                                                                       
        c(i)=ya(i)                                                                                  
        d(i)=ya(i)                                                                                  
11    continue                                                                                      
      y=ya(ns)                                                                                      
      ns=ns-1                                                                                       
      do 13 m=1,n-1                                                                                 
        do 12 i=1,n-m                                                                               
          ho=xa(i)-x                                                                                
          hp=xa(i+m)-x                                                                              
          w=c(i+1)-d(i)                                                                             
          den=ho-hp                                                                                 
          if(den.eq.0.0D+00) then 
             write(6,'(A)') 'failure in polint'
             stop
          endif
          den=w/den                                                                                 
          d(i)=hp*den                                                                               
          c(i)=ho*den                                                                               
12      continue                                                                                    
        if (2*ns.lt.n-m)then                                                                        
          dy=c(ns+1)                                                                                
        else                                                                                        
          dy=d(ns)                                                                                  
          ns=ns-1                                                                                   
        endif                                                                                       
        y=y+dy                                                                                      
13    continue                                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE PowerInt(N,N1,N2,x,y,integral)                                                     
c =======================================================================                           
c This subroutine calculates integral I(y(x)*dx). Both y and x are                                  
c 1D arrays, y(i), x(i) with i=1,N (declared with NN). Lower and upper                              
c integration limits are x(N1) and x(N2), respectively. The method used                             
c is a power-law approximation for y(x) between any two points .                                    
c (This subroutine is used for integration over size distribution) [ZI,'96]                         
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER i, N, N1, N2                                                                          
      DOUBLE PRECISION x(N), y(N), integral, pow, C, delint                                         
c -----------------------------------------------------------------------                           
c     set integral to 0 and accumulate result in the loop                                           
      integral = 0.0D+00                                                                                
c     calculate weight, wgth, and integrate in the same loop                                        
      IF (N2.GT.N1) THEN                                                                            
        DO i = N1, N2-1                                                                             
          pow = dlog(y(i+1)/y(i)) / dlog(x(i+1)/x(i))                                               
          C = y(i) / x(i)**pow                                                                      
         delint=(x(i+1)**(pow+1.0D+0)-x(i)**(pow+1.0D+0))*C/(pow+1.0D+0)                                      
c         add contribution to the integral                                                          
          integral = integral + delint                                                              
        END DO                                                                                      
      ELSE                                                                                          
        integral = 0.0D+00                                                                              
c        this was in case of single size grains                                                     
c        integral = y(1)                                                                            
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                       					                                                                        
c ***********************************************************************                           
      SUBROUTINE PowerInter(NN,N,x,y,xloc,iNloc,yloc)                                               
c =======================================================================                           
c This subroutine performs power law interpolation for y(x) such that                               
c yloc = y(xloc). It is assumed that x is monotonously increasing.                                  
c [based on sub LinInter by ZI'96, modified for power law interp. by MN'03]                         
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NN, N, i, istop, iNloc                                                                
      DOUBLE PRECISION x(NN), y(NN), xloc, yloc, pow                                                
c -----------------------------------------------------------------------                           
      IF (N.GT.1) THEN                                                                              
        IF ((x(1)-xloc)*(x(N)-xloc).LE.0.0D+00) THEN                                                    
          istop = 0                                                                                 
          i = 1                                                                                     
          DO WHILE (istop.NE.1)                                                                     
            i = i + 1                                                                               
            IF (i.GT.N) stop 'PowInter ???'                                                         
            IF (x(i).GE.xloc) THEN                                                                  
              istop = 1                                                                             
              iNloc = i                                                                             
              IF (y(i)*y(i-1).GT.0.0D+00) THEN			                                                       
                 pow = dlog(y(i)/y(i-1)) / dlog(x(i)/x(i-1))                                          
                 yloc = y(i-1) * ((xloc / x(i-1))**pow)                                             
              ELSE                                                                                  
                 yloc = 0.0D+00                                                                         
              END IF			                                                                             
            END IF                                                                                  
          END DO                                                                                    
          ELSE                                                                                      
          IF (xloc.LE.x(1)) yloc = y(1)                                                             
          IF (xloc.GE.x(N)) yloc = y(N)                                                             
        END IF                                                                                      
        ELSE                                                                                        
        yloc = y(1)                                                                                 
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE DoProduct(NN,Yt,pt,p0,j,Prd)                                                       
c =======================================================================                           
c This is an auxiliary subroutine which evaluates a messy expression                                
c needed to calculate normalization constants for a broken power law                                
c density.                                             [Z.I., Aug. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER NN, i, j                                                                              
      DOUBLE PRECISION Yt(NN), pt(NN), Prd, p0                                                      
c -----------------------------------------------------------------------                           
      Prd = Yt(1)**(pt(1) - p0)                                                                     
      IF (j.GT.1) THEN                                                                              
        DO i = 2, j                                                                                 
          Prd = Prd * Yt(i)**(pt(i) - pt(i-1))                                                      
        END DO                                                                                      
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ROMBERG2(a,b,ss8)                                                                  
c =======================================================================                           
c This subroutine performs Romberg integration of 8 functions calculated                            
c in trapzd2 (by calling subroutine TWOFUN) on interval [a,b].                                      
c The results are returned in ss8(1..8). Desired accuracy accRomb is                                
c user supplied and comes through COMMON /numerics/ read in from                                    
c 'numerics.inc'. This subroutine is based on slightly changed versions                             
c of 'qromb' and 'qromo' from Numerical Recipes.                                                    
c                                                    [MN & ZI,Aug'96]                               
c =======================================================================                           
      IMPLICIT NONE
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER fconv(8),JMAX,JMAXP,K,KM, J, iC, idone, kaux                                          
      PARAMETER (JMAX=50, JMAXP=JMAX+1, K=5, KM=K-1)                                                
      DOUBLE PRECISION ss, ss8(8), S2D(8,JMAXP), h(JMAXP), sjKM(JMAXP),                             
     &                 a, b, EPS, h0, dss, s8(8), chk(8)                                            
c -----------------------------------------------------------------------                           
      EPS = accRomb                                                                                 
      h0 = 0.0D+00                                                                                      
      h(1)=1.0D+00                                                                                      
c     intialize convergence flags                                                                   
      DO iC = 1, 8                                                                                  
         fconv(iC) = 0                                                                              
      END DO                                                                                        
c     integrate until all 8 intergrals converge                                                     
      idone = 0                                                                                     
      j = 0                                                                                         
      DO WHILE(idone.NE.1.and.j.LE.JMAX)                                                            
        j = j + 1                                                                                   
c       integrate with j division points                                                            
        call trapzd2(a,b,s8,j)                                                                      
        DO iC = 1, 8                                                                                
           S2D(iC,j) = S8(iC)                                                                       
        END DO                                                                                      
c       check if any of 8 integrals has converged                                                   
        IF (j.ge.K) THEN                                                                            
           idone = 1                                                                                
           DO iC = 1, 8                                                                             
             IF (fconv(iC).EQ.0) THEN                                                               
c              generate array for polint                                                            
               DO kaux = 1, j                                                                       
                 sjKM(kaux) = S2D(iC,kaux)                                                          
               END DO                                                                               
c              predict the integral for stepsize h->h0=0.0                                          
               CALL polint(h(j-KM),sjKM(j-KM),K,h0,ss,dss)                                          
               IF (dabs(dss).le.EPS*dabs(ss)) THEN                                                  
                 SS8(iC) = ss                                                                       
                 fconv(iC) = 1                                                                      
               ELSE                                                                                 
                 chk(iC) = dabs(dss)/dabs(ss)                                                       
               END IF                                                                               
             END IF                                                                                 
             idone = idone*fconv(iC)                                                                
           END DO                                                                                   
        END IF                                                                                      
        h(j+1)=0.25D+00*h(j)                                                                            
      END DO                                                                                        
      IF (j.GE.jMAX) THEN                                                                           
        write(*,*)' Reached the limiting number of steps in ROMBERG2'                               
        write(*,*)'You might want to change accRomb in the input file'                              
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ROMBY(fnc,a,b,ss)                                                                  
c =======================================================================                           
c This subroutine performs Romberg integration of function func on                                  
c interval [a,b]. The result is returned in ss. Desired accuracy is set                             
c to 0.002.                                            [Z.I., Feb. 1996]                            
c =======================================================================                           
      IMPLICIT NONE
      INTEGER JMAX,JMAXP,K,KM, J                                                                    
      PARAMETER (JMAX=30, JMAXP=JMAX+1, K=3, KM=K-1)                                                
      DOUBLE PRECISION a,b,fnc,ss,EPS, aux, dss,h(JMAXP),s(JMAXP)                                   
      EXTERNAL fnc                                                                                  
c -----------------------------------------------------------------------                           
      EPS = 0.002D+00                                                                                   
      h(1)=1.0D+00                                                                                       
      do 11 j=1,JMAX                                                                                
        call trapzd(fnc,a,b,s(j),j)                                                                 
        if (j.ge.K) then                                                                            
          aux = 0.0D+00                                                                                 
          call polint(h(j-KM),s(j-KM),K,aux,ss,dss)                                                 
          IF (dabs(dss).le.EPS*dabs(ss)) RETURN                                                     
        endif                                                                                       
        s(j+1)=s(j)                                                                                 
        h(j+1)=0.25D+00*h(j)                                                                            
11    continue                                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ScaleTo1(Nmax,N,Y)                                                                 
c =======================================================================                           
c This subroutine scales vector Y such that Y(1) = 1.0                                              
c                                                      [Z.I., Jan. 1997]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER Nmax, N, i                                                                            
      DOUBLE PRECISION Y(Nmax), Scale                                                               
c -----------------------------------------------------------------------                           
      Scale = Y(1)                                                                                  
      DO i = 1, N                                                                                   
        Y(i) = Y(i) / Scale                                                                         
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE ScaletoArea(Nmax,N,X,Y,Area)                                                       
c =======================================================================                           
c This subroutine scales a function Y(x) by the area A=Int{2*Pi Y(x)xdx}.                           
c X and Y are 1D arrays. (Used for PSF normalization.)       [MN, Sep'04]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER Nmax, N, i                                                                            
      DOUBLE PRECISION Y(Nmax),X(Nmax),Fn(Nmax),Area,Pi                                             
c -----------------------------------------------------------------------                           
      Pi = 2.0D+00*ASIN(1.0)                                                                            
      DO i = 1, N                                                                                   
	  Fn(i) = Y(i)*X(i)                                                                                
      END DO                                                                                        
c     Integrate:                                                                                    
      Area = 0.0D+00                                                                                    
      DO i = 1, N-1                                                                                 
        Area = Area + 0.5D+00*(Fn(i+1)+Fn(i))*(X(i+1)-X(i)) 	                                           
	END DO                                                                                             
	Area = 2.0D+00*Pi*Area                                                                                  
c     Normalize:                                                                                    
      DO i = 1, N                                                                                   
        Y(i) = Y(i) / Area                                                                          
      END DO                                            		                                          
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
				                                                                                                
c ***********************************************************************                           
      SUBROUTINE SHIFT(X,Nmax,N,Xins,i)                                                             
c =======================================================================                           
c Rearranges a vector X by inserting a new element Xins.    [MN, Aug'96]                            
c =======================================================================                           
      implicit none                                                                                 
      integer Nmax, N, i,j                                                                          
      DOUBLE PRECISION X(Nmax),Xins                                                                 
c -----------------------------------------------------------------------                           
      DO j = N+1, i+2, -1                                                                           
        x(j) = x(j-1)                                                                               
      END DO                                                                                        
      x(i+1) = xins                                                                                 
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SIMPSON(N,N1,N2,x,y,integral)                                                      
c =======================================================================                           
c This subroutine calculates integral I(y(x)*dx). Both y and x are                                  
c 1D arrays, y(i), x(i) with i=1,N (declared with NN). Lower and upper                              
c integration limits are x(N1) and x(N2), respectively. The method used                             
c is Simpson (trapezoid) approximation. The resulting integral is sum of                            
c y(i)*wgth, i=N1,N2.                                  [Z.I., Mar. 1996]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER i, N, N1, N2                                                                          
      DOUBLE PRECISION x(N), y(N), wgth, integral                                                   
c -----------------------------------------------------------------------                           
c     set integral to 0 and accumulate result in the loop                                           
      integral = 0.0D+00                                                                                
c     calculate weight, wgth, and integrate in the same loop                                        
      IF (N2.GT.N1) THEN                                                                            
        DO i = N1, N2                                                                               
c         weigths                                                                                   
          IF (i.NE.N1.AND.i.NE.N2) THEN                                                             
            wgth = 0.5D+00 * (x(i+1)-x(i-1))                                                            
          ELSE                                                                                      
            IF (i.eq.N1) wgth = 0.5D+00 * (x(N1+1)-x(N1))                                               
            IF (i.eq.N2) wgth = 0.5D+00 * (x(N2)-x(N2-1))                                               
          END IF                                                                                    
c         add contribution to the integral                                                          
          integral = integral + y(i) * wgth                                                         
        END DO                                                                                      
      ELSE                                                                                          
        integral = 0.0D+00                                                                              
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SORT(RA,N)                                                                         
c =======================================================================                           
      INTEGER N                                                                                     
      DOUBLE PRECISION RA(N)                                                                        
c -----------------------------------------------------------------------                           
      L=N/2+1                                                                                       
      IR=N                                                                                          
10    CONTINUE                                                                                      
        IF(L.GT.1)THEN                                                                              
          L=L-1                                                                                     
          RRA=RA(L)                                                                                 
        ELSE                                                                                        
          RRA=RA(IR)                                                                                
          RA(IR)=RA(1)                                                                              
          IR=IR-1                                                                                   
          IF(IR.EQ.1)THEN                                                                           
            RA(1)=RRA                                                                               
            RETURN                                                                                  
          ENDIF                                                                                     
        ENDIF                                                                                       
        I=L                                                                                         
        J=L+L                                                                                       
20      IF(J.LE.IR)THEN                                                                             
          IF(J.LT.IR)THEN                                                                           
            IF(RA(J).LT.RA(J+1))J=J+1                                                               
          ENDIF                                                                                     
          IF(RRA.LT.RA(J))THEN                                                                      
            RA(I)=RA(J)                                                                             
            I=J                                                                                     
            J=J+J                                                                                   
          ELSE                                                                                      
            J=IR+1                                                                                  
          ENDIF                                                                                     
        GO TO 20                                                                                    
        ENDIF                                                                                       
        RA(I)=RRA                                                                                   
      GO TO 10                                                                                      
c -----------------------------------------------------------------------                           
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE Spline(x,y,n,yp1,ypn,y2)                                                           
c =======================================================================                           
      INTEGER n,NMAX                                                                                
      DOUBLE PRECISION yp1,ypn,x(n),y(n),y2(n)                                                      
      PARAMETER (NMAX=500)                                                                          
      INTEGER i,k                                                                                   
      DOUBLE PRECISION p,qn,sig,un,u(NMAX)                                                          
c -----------------------------------------------------------------------                           
      if (yp1.gt.0.99d30) then                                                                       
        y2(1)=0.0D+00                                                                                    
        u(1)=0.0D+00                                                                                     
      else                                                                                          
        y2(1)=-0.5D+00                                                                                  
        u(1)=(3.0D+00/(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)                                         
      endif                                                                                         
      do 11 i=2,n-1                                                                                 
        sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))                                                           
        p=sig*y2(i-1)+2.0D+00                                                                            
        y2(i)=(sig-1.0D+00)/p                                                                            
        u(i)=(6.0D+00*((y(i+1)-y(i))/(x(i+                                                               
     *1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*                                    
     *u(i-1))/p                                                                                     
11    continue                                                                                      
      if (ypn.gt.0.99D30) then                                                                       
        qn=0.0D+00                                                                                       
        un=0.0D+00                                                                                       
      else                                                                                          
        qn=0.5D+00                                                                                      
        un=(3.0D+00/(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))                                     
      endif                                                                                         
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.0D+00)                                                          
      do 12 k=n-1,1,-1                                                                              
        y2(k)=y2(k)*y2(k+1)+u(k)                                                                    
12    continue                                                                                      
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SPLINE2(x,fun,N,coef)                                                              
c =======================================================================                           
c This subroutine finds coefficients coef(i,j) such that                                            
c fun(x)=coef(i,1) + coef(i,2)*x + coef(i,3)*x^2 + coef(i,4)*x^3                                    
c for x(i).LE.x.LE.x(i+1) is a cubic spline approximation of fun(x),                                
c with i=1..N.                                         [Z.I., Feb. 1995]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER N, i                                                                                  
      DOUBLE PRECISION x(npY), coef(npY,4), secnder(npY), y2at1, y2atN,                             
     &       Dd, xL, xR, dR, dL, fun(npY), fL, fR                                                   
c -----------------------------------------------------------------------                           
c     find second derivative, secnder                                                               
        y2at1 = (fun(2)-fun(1))/(x(2)-x(1))                                                         
        y2atN = (fun(N)-fun(N-1))/(x(N)-x(N-1))                                                     
        CALL SPLINE(x,fun,N,y2at1,y2atN,secnder)                                                    
c     generate coef(i,j), j=1,2,3,4                                                                 
      DO i = 1, N-1                                                                                 
        Dd = x(i+1) - x(i)                                                                          
        xL = x(i)                                                                                   
        xR = x(i+1)                                                                                 
        dL = secnder(i)                                                                             
        dR = secnder(i+1)                                                                           
        fL = fun(i)                                                                                 
        fR = fun(i+1)                                                                               
        coef(i,1) = (xR*fL-xL*fR)/Dd + dL*xR*Dd/
     &              6.0D+00*((xR/Dd)**2.0D+00-1.0D+00)                                 
        coef(i,1) = coef(i,1) - dR*xL*Dd/
     &              6.0D+00*((xL/Dd)**2.0D+00-1.0D+00)                                       
        coef(i,2) = (fR-fL)/Dd + dL*Dd/
     &              6.0D+00*(1.0D+00-3.0D+00*(xR/Dd)**2.0D+00)                                       
        coef(i,2) = coef(i,2) - dR*Dd/
     &              6.0D+00*(1.0D+00-3.0D+00*(xL/Dd)**2.0D+00)                                        
        coef(i,3) = (dL*xR-dR*xL)/Dd/2.0D+00                                                             
        coef(i,4) = (dR-dL)/6.0D+00/Dd                                                                   
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE splint(xa,ya,y2a,n,x,y)                                                            
c =======================================================================                           
      IMPLICIT NONE
      INTEGER n                                                                                     
      DOUBLE PRECISION x,y,xa(n),y2a(n),ya(n)                                                       
      INTEGER k,khi,klo                                                                             
      DOUBLE PRECISION a,b,h                                                                        
c -------------------------------------------------------------------------                         
      klo=1                                                                                         
      khi=n                                                                                         
1     if (khi-klo.gt.1) then                                                                        
        k=(khi+klo)/2                                                                               
        if(xa(k).gt.x)then                                                                          
          khi=k                                                                                     
        else                                                                                        
          klo=k                                                                                     
        endif                                                                                       
      goto 1                                                                                        
      endif                                                                                         
      h=xa(khi)-xa(klo)                                                                             
      if (h.eq.0.0D+00) then
         write(6,'(a)')'bad xa input in splint'                                                   
         stop
      endif
      a=(xa(khi)-x)/h                                                                               
      b=(x-xa(klo))/h                                                                               
      y=a*ya(klo)+b*ya(khi)+((a**3.0D+00-a)*y2a(klo)+(b**3.0D+00-b)*
     &y2a(khi))*(h**2.0D+00)/6.0D+00                                                                                         
c -------------------------------------------------------------------------                         
      return                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE trapzd(func,a,b,s,n)                                                               
c =======================================================================                           
      IMPLICIT NONE
      INTEGER n                                                                                     
      DOUBLE PRECISION a,b,s,func                                                                   
      EXTERNAL func                                                                                 
      INTEGER it,j                                                                                  
      DOUBLE PRECISION del,sum,tnm,x                                                                
c -------------------------------------------------------------------------                         
      IF (n.eq.1) THEN                                                                              
        s=0.5D+00*(b-a)*(func(a)+func(b))                                                               
      ELSE                                                                                          
        it=2**(n-2)                                                                                 
        tnm=it                                                                                      
        del=(b-a)/tnm                                                                               
        x=a+0.5D+00*del                                                                                 
        sum=0.                                                                                      
        DO j = 1, it                                                                                
          sum=sum+func(x)                                                                           
          x=x+del                                                                                   
        END DO                                                                                      
        s=0.5D+00*(s+(b-a)*sum/tnm)                                                                     
      END IF                                                                                        
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE zbrac(func,x1,x2,Ntry,succes)                                                      
c =======================================================================                           
      IMPLICIT NONE
      INTEGER NTRY, succes                                                                          
      DOUBLE PRECISION x1,x2,func,FACTOR                                                            
      EXTERNAL func                                                                                 
      PARAMETER (FACTOR=1.6D+00)                                                                        
      INTEGER j                                                                                     
      DOUBLE PRECISION f1,f2                                                                        
c -------------------------------------------------------------------------                         
      IF(x1.eq.x2) THEN                                                                             
	  write(18,'(a16,1p,2e12.4)') 'In ZBRAC: x1,x2=', x1,x2                                            
        succes=0                                                                                    
      END IF                                                                                        
      f1=func(x1)                                                                                   
      f2=func(x2)                                                                                   
      succes=1                                                                                      
      DO j = 1, NTRY                                                                                
        IF(f1*f2.lt.0.0D+00) RETURN                                                                      
        IF(DABS(f1).lt.DABS(f2)) THEN                                                               
          x1=x1+FACTOR*(x1-x2)                                                                      
c         f1=func(x1)                                                                               
c     IF's added to prevent breaking of slab case on DEC [MN,Jun'99]                                
          IF (x1.LT.(-100.0D+00)) THEN                                                                   
            f1 = 5.0D+05                                                                              
          ELSE                                                                                      
            f1=func(x1)                                                                             
          END IF                                                                                    
        ELSE                                                                                        
          x2=x2+FACTOR*(x2-x1)                                                                      
          f2=func(x2)                                                                               
        END IF                                                                                      
      END DO                                                                                        
      succes=0                                                                                      
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      DOUBLE PRECISION FUNCTION zriddr(func,x1,x2,MAXIT,xacc)                                       
c =======================================================================                           
      IMPLICIT NONE
      INTEGER MAXIT                                                                                 
      DOUBLE PRECISION x1,x2,xacc,func,UNUSED                                                       
      PARAMETER (UNUSED=-1.11D+30)                                                                   
      EXTERNAL func                                                                                 
      INTEGER j                                                                                     
c     aux will be used as argument for SIGN function few lines below.                               
c     It needs to be REAL to conform to FORTRAN90                                                   
c      REAL aux                                                                                      
      DOUBLE PRECISION fh,fl,fm,fnew,s,xh,xl,xm,xnew,aux                                                
c -------------------------------------------------------------------------                         
c      fl=func(x1)                                                                                  
c     IF's added to prevent breaking of slab case on DEC [MN,Jun'99]                                
      IF (x1.LT.(-100.0D+00)) THEN                                                                       
        fl = 5.0D+05                                                                                  
      ELSE                                                                                          
        fl=func(x1)                                                                                 
      END IF                                                                                        
      fh=func(x2)                                                                                   
      if((fl.gt.0.0D+00.and.fh.lt.0.0D+00)
     &          .or.(fl.lt.0.0D+00.and.fh.gt.0.0D+00))then                                    
        xl=x1                                                                                       
        xh=x2                                                                                       
        zriddr=UNUSED                                                                               
        do 11 j=1,MAXIT                                                                             
          xm=0.5D+00*(xl+xh)                                                                            
          fm=func(xm)                                                                               
          s=sqrt(fm**2.0D+00-fl*fh)                                                                      
          if(s.eq.0.0D+00)return                                                                         
          aux = fl-fh                                                                               
          xnew=xm+(xm-xl)*(sign(1.0D+00,aux)*fm/s)                                                       
          if (DABS(xnew-zriddr).le.xacc) return                                                     
          zriddr=xnew                                                                               
          fnew=func(zriddr)                                                                         
          if (fnew.eq.0.0D+00) return                                                                    
          if(dsign(fm,fnew).ne.fm) then                                                             
            xl=xm                                                                                   
            fl=fm                                                                                   
            xh=zriddr                                                                               
            fh=fnew                                                                                 
          else if(dsign(fl,fnew).ne.fl) then                                                        
            xh=zriddr                                                                               
            fh=fnew                                                                                 
          else if(dsign(fh,fnew).ne.fh) then                                                        
            xl=zriddr                                                                               
            fl=fnew                                                                                 
          else                                                                                      
            write(6,'(a)')'Fatal error in zriddr'
            stop
          endif                                                                                     
          if(dabs(xh-xl).le.xacc) return                                                            
11      continue                                                                                    
        write(6,'(a)')'zriddr exceed maximum iterations'
        stop
      else if (fl.eq.0.0D+00) then                                                                       
        zriddr=x1                                                                                   
      else if (fh.eq.0.0D+00) then                                                                       
        zriddr=x2                                                                                   
      else                                                                                          
        write(6,'(a)')'root must be bracketed in zriddr'
        stop
      endif                                                                                         
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
c =======================================================================                           
c     Full dynamical calculation of radiatively driven winds,                                       
c     implementing the formalism of EI01 (MNRAS 327, 403) without                                   
c     their correction for sub-sonic drift.                                                         
c     Apart from WINDS,                                                                             
c     which provides the interface to radiative transfer,                                           
c     this is a stand-alone module                                                                  
c     Single grains only at this time, currently zeta is the only                                   
c     quantity with room for multigrains                                                            
c                                         [ME, Jul'00]                                              
c =======================================================================                           
C     Table of Contents                                                                             
C                                                                                                   
C     WINDS                                                                                         
C     DYNAMICS                                                                                      
C     CalcVel                                                                                       
C     CalcETA                                                                                       
C     CalcDrift                                                                                     
c =======================================================================                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE WINDS(nG,EtaOK,ftot)                                                               
c =======================================================================                           
c This subroutine takes care of the interface between radiatively driven                            
c winds and radiative transfer.  It is entered                                                      
C after a radiative transfer calculation with given eta.                                            
C This sub caclulates the reddening profile phi and passes it to the dynamics                       
C module, which returns the velocity and density profiles corresponding                             
C to the given phi. Convergence is achived when the eta returned from                               
C the dynamics calculation is the same as that used to produce phi.                                 
c                                                                                                   
c Notations follow EI01 (MNRAS 327, 403)                                                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER ver                                                               
      DOUBLE PRECISION ugas(npY), qF(npY), vrat(npG,npY), Gamma(npY),           
     &       I1, I2, I3, CMdot, Cve, CM, Cr1, G1, Ginf, Prdw, delta,            
     &       winf, Phi, PIrdw, QV, q_star, zeta1, tauFdyn(npY)                  
      COMMON /dyn/ ugas, qF, vrat, Gamma, I1, I2, I3, CMdot, Cve, CM,           
     &       Cr1, G1, Ginf, Prdw, delta, winf, Phi, PIrdw, QV, q_star,          
     &       zeta1, tauFdyn, ver                                                
                                                                                
                                                                                                    
      INTEGER nG, EtaOK, iY, iL, err                                                                
      DOUBLE PRECISION ETAold(npY),accETA,ftot(npL,npY), resaux,                                    
     &       Faux(npL), Qstar, Qfid, phi1, localP, eps, GammaMax,                                   
     &       wScale, uacc, reddn(npY), w(npY), gmax                                                 
C     the parameter ver determines the version of the velocity formal solution                      
C     1 for linear, 2 quadratic.  It is specified in INPUT and carried in /dyn/                     
C     The quadratic solution is from equation D1 in EI01. The linear is                             
c     obtained similarly from the differential equation 24                                          
c     by using dw^2 = 2wdw and dividing through by 2w                                               
c                                                                                                   
c -----------------------------------------------------------------------                           
      IF (iX.GE.1) THEN                                                                             
         write(18,*)' Doing Dynamics'                                                               
         IF (ver.EQ.1) THEN                                                                         
           write(18,*)' Linear version of velocity formal solution'                                 
         ELSEIF (ver.EQ.2) THEN                                                                     
           write(18,*)' Quadratic version of velocity formal solution'                              
         ELSE                                                                                       
           write(12,*)' **************************** '                                              
           write(12,'(a,i3)')'  Illegal Input ver = ', ver                                          
           write(12,*)'     ver must be 1 or 2!      '                                              
           write(12,*)'       PROGRAM STOPPED        '                                              
           write(12,*)' **************************** '                                              
           stop                                                                                     
         END IF                                                                                     
      END IF                                                                                        
      IF(iVerb.EQ.2) write(*,*)' Doing Dynamics'                                                    
c     so far it works for nG=1 only:                                                                
      IF (nG.GT.1) THEN                                                                             
        write(12,*)' **************************** '                                                 
        write(12,*)' Change dynamics sub to nG>1! '                                                 
        write(12,*)'       PROGRAM STOPPED        '                                                 
        write(12,*)' **************************** '                                                 
        stop                                                                                        
      END IF                                                                                        
c -----------------------------------------------------------------------                           
c     assign input parameters to local variables                                                    
      GammaMax = ptr(1)                                                                             
      eps = pow                                                                                     
c     accuracy for velocity convergence same as for Utot:                                           
      uacc = accConv                                                                                
c     extinction efficiency at the fiducial wavelength                                              
      Qfid = SigExfid/aveA                                                                          
c     calculate Qstar and the scale factor of w:                                                    
      DO iL = 1, nL                                                                                 
         Faux(iL) = (SigmaA(1,iL)+SigmaS(1,iL))*ftot(iL,1)/lambda(iL)                               
      END DO                                                                                        
      CALL Simpson(npL,1,nL,lambda,Faux,resaux)                                                     
c                                                                                                   
c     Qstar is from EI01 equation 4, wscale is from equation 29                                     
c                                                                                                   
      Qstar = resaux / aveA                                                                         
      wScale = TAUfid/Qfid                                                                          
c                                                                                                   
c -----------------------------------------------------------------------                           
C     Here's the eta that was used in the radiative transfer                                        
      DO iY = 1, nY                                                                                 
        ETAold(iY) = ETAdiscr(iY)                                                                   
      END DO                                                                                        
c     and here's the resulting reddening profile                                                    
      DO iY = 1, nY                                                                                 
        DO iL = 1, nL                                                                               
          Faux(iL) = (SigmaA(1,iL)+SigmaS(1,iL))*ftot(iL,iY)/lambda(iL)                             
        END DO                                                                                      
        CALL Simpson(npL,1,nL,lambda,Faux,resaux)                                                   
        if (iY.eq.1)    phi1 = resaux                                                               
        reddn(iY) = resaux / phi1                                                                   
      END DO                                                                                        
c     Now Find new ETA                                                                              
      err = 0                                                                                       
      CALL DYNAMICS(eps, GammaMax, wScale, reddn, w, vrat, gmax,                                    
     &             localP, ETAdiscr, Y, nY, nG, uacc, err, iX, ver)                                 
c     and check convergence (ptr(2) is specified in INPUT)                                          
      accETA = ptr(2) * accuracy                                                                    
      CALL ChkConv(nY,accETA,ETAold,ETAdiscr,EtaOK)                                                 
      IF (iX.GE.1) THEN                                                                             
        write(18,'(2(a,1pe10.3))')                                                                  
     &    '  P = ', localP, '  gmax = ', gmax                                                       
        write(18,*)                                                                                 
     &      '     Y    ugas(new)   tauF      ETAold    ETAnew    ratio'                             
           DO iY = 1, nY                                                                            
           END DO                                                                                   
        DO iY = 1, nY                                                                               
C**************************************                                                             
c        for output compatibility; we can do away with qF and tauF, which                           
c        have only nostalgic reasons.  EI01 never uses them                                         
          ugas(iY) = Qstar*w(iY)                                                                    
          qF(iY)   = (Qstar/Qfid)*reddn(iY)                                                         
          Faux(iY) = qF(iY)*ETAdiscr(iY)                                                            
          CALL SIMPSON(npY,1,iY,Y,Faux,resaux)                                                      
          tauFdyn(iY) = TAUfid*resaux                                                               
C**************************************                                                             
          accETA = ETAold(iY) / ETAdiscr(iY)                                                        
          write(18,'(1p,6e10.3)')Y(iY), ugas(iY), tauFdyn(iY),                                      
     &                           ETAold(iY), ETAdiscr(iY),accETA                                    
        END DO                                                                                      
        IF (EtaOK.EQ.1) THEN                                                                        
          write(18,*)' Convergence on Eta achieved'                                                 
        ELSE                                                                                        
          write(18,*)' Convergence on Eta not achieved.'                                            
          write(18,*)' Going to the next iteration.'                                                
        END IF                                                                                      
      END IF                                                                                        
c     save Y to Yprev and nY to nYprev                                                              
      DO iY = 1, nY                                                                                 
         Yprev(iY) = Y(iY)                                                                          
      END DO                                                                                        
      nYprev = nY                                                                                   
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE DYNAMICS(eps, f, uScale, phi, u, zeta, gmax, P, eta,                               
     &           Y, nY, nG, acc, err, ipr, ver)                                                     
c =======================================================================                           
c Calculates the velocity structure of a radiatively driven                                         
c wind given the reddening profile phi.  It returns the                                             
c profiles w, eta and zeta, and the wind parameters P and gmax.                                     
c                                                                                                   
c This subroutine calculates the initial guess and controlls the                                    
c convergence of the iterative procedure, with CalcVel actually                                     
c calculating a new velocity profile from the previous one.                                         
c Convergence is checked both for u(y) (= w(y)) and its derivative eta(y)                           
c because eta is crucial for the radiative transfer.                                                
c *** This version works for single size grains only ***                                            
c                                                                                                   
c Implementing equations from EI01 (MNRAS 327, 403)                                                 
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nG, nY, iY, itr, ETAconv, uconv, err, ipr, itmax, ver                                 
      DOUBLE PRECISION eta(npY), ETAold(npY), u(npY), uold(npY),                                    
     &       phi(npY), zeta(npY), Y(npY), eps, f, acc, gmax, uScale,                                
     &       N, P, wf, k, e1                                                                        
      DATA   itMax/100/, k/0.4/                                                                     
C  We may wish to control itMax and k as input parameters                                           
c -----------------------------------------------------------------------                           
c     Initial approximation for u(y) from EI01, eq C6                                               
c     wf is from eq. 29 with epsilon correction (eq. C8)                                            
      wf = (1.0D+00/(1.0D+00 - eps))*phi(nY)*uScale                                                           
c     add a correction for the finite outer radius so that wf = u(nY):                              
      e1 = 1.0D+00 - eps**(1.0D+00/k)                                                                         
      wf = wf/(1.0D+00 - e1/y(nY))**k                                                                    
c     and now calculate all u from eq. C6                                                           
      DO iY = 1, nY                                                                                 
         uold(iY) = wf*(1.0D+00 - e1/y(iY))**k                                                           
c        initial eta is irrelevant; might as well use                                               
c        the one passed from radiative transfer:                                                    
         ETAold(iY) = eta(iY)                                                                       
      END DO                                                                                        
c     ITERATIONS until u and eta converge within acc                                                
      DO itr = 1, itMax                                                                             
         Call CalcVel(eps,f,uScale,phi,uold,u,zeta,gmax,Y,nY,ver)                                   
         CALL CalcETA(u, zeta, eta, N, Y, nY)                                                       
         P = dsqrt(uScale/N)                                                                        
c        check convergence of u and Eta                                                             
         CALL ChkConv(nY,acc,uold,u,uconv)                                                          
         CALL ChkConv(nY,acc,ETAold,eta,ETAconv)                                                    
c        convergence required for both u(y) and ETA(y)                                              
         err = 1 - ETAconv * uconv                                                                  
         IF (err.NE.0) THEN                                                                         
c           did not converge, repeat the exercise...                                                
            DO iY =1, nY                                                                            
              uold(iY) = u(iY)                                                                      
              ETAold(iY) = eta(iY)                                                                  
            END DO                                                                                  
         ELSE                                                                                       
c          we're done:                                                                              
           IF (ipr.GE.1)                                                                            
     &     write(18,'(a35,i3)')' Number of iterations to converge:',itr                             
           RETURN                                                                                   
         END IF                                                                                     
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CalcVel(eps, f, ws, phi, wold, w, zeta, gmax,                                      
     &                   Y, nY, ver)                                                                
c =======================================================================                           
c Calculates the scaled gas velocity w(y) from wold(y), the previous                                
c velocity profile, and the given reddening profile phi                                             
c The calculation follows the formal solution in Appendix D                                         
c ver = 1 triggers the linear version, 2 the quadratic (eq. D1)                                     
c All symbols are as defined there, ws = tauV/QV and P2 = P^2                                       
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER ver, nY, iY                                                                           
      DOUBLE PRECISION eps, f, wold(npY), w(npY), phi(npY),                                         
     &      zeta(npG,npY), Y(npY), z(npY), zz(npY), gmax, g,                                        
     &      ws, N, P2, ww1, aux, F1(npY), F2(npY)                                                   
c -----------------------------------------------------------------------                           
c     first get the drift profile zeta                                                              
      CALL CalcDrift(phi, wold, zeta, nY)                                                           
c     then the normalization N (= EtaINT; eq D3)                                                    
      DO iY = 1, nY                                                                                 
        F1(iY) = zeta(1,iY)/(wold(iY)*Y(iY)*Y(iY))                                                  
      END DO                                                                                        
      CALL SIMPSON(npY,1,nY,Y, F1, N)                                                               
c     and finally P (eq. D3):                                                                       
      P2 = 2.0D+00*ws/N                                                                                  
C     Now the two versions diverge:                                                                 
      IF (ver. eq. 2) THEN                                                                          
c        Quadratic version (eq. D1):                                                                
c         Get the profile z = integral(zeta*phi/y^2) and gmax                                       
c         (= Gamma_min), the maximum gravitational correction                                       
c         as defined in eqs D4 and D5:                                                              
          F1(1) = 0.0D+00                                                                                
          z(1)  = 0.0D+00                                                                                
          gmax  = 1.0D+00/zeta(1,1)                                                                      
          DO iY = 2, nY                                                                             
             F1(iY) = zeta(1,iY)*phi(iY)/(Y(iY)*Y(iY))                                              
             CALL SIMPSON(npY,1,iY,Y, F1, z(iY))                                                    
             aux = (1.0D+00 - 1.0D+00/Y(iY))/z(iY)                                                            
             if (aux.gt.gmax) gmax = aux                                                            
          END DO                                                                                    
          g = f/gmax                                                                                
c         All ready.  Calculate the new w1 (ww1 = w1^2):                                            
          aux  = eps*eps                                                                            
          ww1  =(aux/(1.0D+00-aux))*P2*(z(nY)-g*(1.0D+00-1.0D+00/Y(nY)))                                    
          w(1) = dsqrt(ww1)                                                                         
c         and now the rest of the profile:                                                          
          DO iY = 2, nY                                                                             
             aux   = ww1 + P2*(z(iY)-g*(1.0D+00-1.0D+00/Y(iY)))                                           
             w(iY) = dsqrt(aux)                                                                     
          END DO                                                                                    
      ELSE                                                                                          
c        Linear version.                                                                            
c         obtained from the differential equation 24                                                
c         by using dw^2 = 2wdw and dividing through by 2w                                           
c         Now we need the profiles z = integral(zeta*phi/w*y^2),                                    
c         zz = integral(1/w*y^2) and then gmax = max(zz/z)                                          
          F1(1) = 0.0D+00                                                                                
          F2(1) = 0.0D+00                                                                                
          z(1)  = 0.0D+00                                                                                
          zz(1) = 0.0D+00                                                                                
          gmax  = 1./zeta(1,1)                                                                      
          DO iY = 2, nY                                                                             
             F2(iY) = 1.0D+00/(wold(iY)*Y(iY)*Y(iY))                                                     
             F1(iY) = F2(iY)*zeta(1,iY)*phi(iY)                                                     
             CALL SIMPSON(npY,1,iY,Y, F1, z(iY))                                                    
             CALL SIMPSON(npY,1,iY,Y, F2, zz(iY))                                                   
             aux = zz(iY)/z(iY)                                                                     
             if (aux.gt.gmax) gmax = aux                                                            
          END DO                                                                                    
          g = f/gmax                                                                                
c         All ready.  Calculate the new w1:                                                         
          w(1)  = (eps/(1.0D+00-eps))*0.5D+00*P2*(z(nY) - g*zz(nY))                                        
c         and now the rest of the profile:                                                          
          DO iY = 2, nY                                                                             
             w(iY) = w(1) + 0.5D+00*P2*(z(iY) - g*zz(iY))                                               
          END DO                                                                                    
      END IF                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CalcETA(w, zeta, Eta, EtaINT, Y, nY)                                               
c =======================================================================                           
c Calculates the dimensionless density profile ETA(y) from EI eq. 25 given                          
c the velocity profile w(y) and its corresponding drift zeta(y)                                     
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER iY, nY                                                                                
      DOUBLE PRECISION w(npY), Eta(npY), zeta(npG,npY), Y(npY),                                     
     &       EtaINT                                                                                 
c ======================================================================                            
      DO iY = 1, nY                                                                                 
        Eta(iY) = zeta(1,iY)/(w(iY)*Y(iY)*Y(iY))                                                    
      END DO                                                                                        
c     now normalize eta:                                                                            
      CALL SIMPSON(npY,1,nY,Y,Eta,EtaINT)                                                           
      DO iY = 1, nY                                                                                 
        Eta(iY) = Eta(iY)/EtaINT                                                                    
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE CalcDrift(phi,w,zeta,nY)                                                           
c =======================================================================                           
c Calculates the drift profile zeta from EI01 eq. 24                                                
c without the correction for sub-sonic drift (theta = 0).                                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, iY                                                                                
      DOUBLE PRECISION phi(npY), w(npY), zeta(npG,npY)                                              
c -----------------------------------------------------------------------                           
      DO iY = 1, nY                                                                                 
         zeta(1,iY) = 1.0D+00 / (1.0D+00 + dsqrt(phi(iY)/w(iY)))                                            
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c =========================================================================                         
c          Below are the subroutines for calculation in slab geometry                               
c                     arranged in alphabetical order                                                
c =========================================================================                         
C     Table of Contents                                                                             
C                                                                                                   
C     SLBANALYT                                                                                     
C     SLBdifF                                                                                       
C     Eint1                                                                                         
C     Eint2                                                                                         
C     Eint3                                                                                         
C     Eint4                                                                                         
C     Eint5                                                                                         
C     SLBacc                                                                                        
C     SLBGRAY                                                                                       
C     SLBIniT                                                                                       
C     SLBIntensity                                                                                  
C     SLBmat                                                                                        
C     SLBmisc                                                                                       
C     SLBRadT                                                                                       
C     SLBSOLVE                                                                                      
C     SLBSTAR                                                                                       
C     SLBTAU                                                                                        
C     SLBTRACE                                                                                      
C     SLBY                                                                                          
c =========================================================================                         
                                                                                                    
c *************************************************************************                         
      SUBROUTINE SLBAnalyt(TAU,L1,L2,L3,L4,N,NN)                                                    
c =========================================================================                         
c     Finds the integrals of the moments of the first exponential function E1                       
c     Lk(Tau)=Int{t^(k-1) E1|t-Tau|}, k=1..4. The analytical expressions used                       
c     are obtained integrating Lk by parts.                     [MN,Nov'98]                         
c =========================================================================                         
      IMPLICIT NONE                                                                                 
      INTEGER i, j, N, NN                                                                           
      DOUBLE PRECISION L1(NN,NN), L2(NN,NN), L3(NN,NN), L4(NN,NN), del,                             
     &          TAU(NN), arg, arg1, Eint2, Eint3, Eint4, Eint5, Lt1,                                
     &          Lt2, Lt3, Lt4, E2a1, E3a1, E4a1                                                     
c ----------------------------------------------------------------------                            
      DO i = 1, N                                                                                   
       DO j = 1, N                                                                                  
        L1(i,j) = 0.0D+00                                                                                
        L2(i,j) = 0.0D+00                                                                                
        L3(i,j) = 0.0D+00                                                                                
        L4(i,j) = 0.0D+00                                                                                
       END DO                                                                                       
      END DO                                                                                        
c     Calculate Lk(i)=Int_t^t1 {x**(k-1)E1|x-TAU(i)| dx}                                            
      DO j = 1, N                                                                                   
        DO i = 1, N-1                                                                               
          del = TAU(i+1)-TAU(i)                                                                     
          arg1 = dabs(TAU(j)-TAU(i+1))                                                              
          arg = dabs(TAU(j)-TAU(i))                                                                 
                                                                                                    
          E2a1 = Eint2(arg1)                                                                        
          E3a1 = Eint3(arg1)                                                                        
          E4a1 = Eint4(arg1)                                                                        
          Lt1 = E2a1-Eint2(arg)                                                                     
          Lt2 =-(E3a1-Eint3(arg))/del                                                               
          Lt3 = E2a1 + 2.0D+00/del/del*(E4a1-Eint4(arg))                                                 
          Lt4 =-3.0D+00/del*E3a1 -6.0D+00/del/del/del*                                                        
     *                     (Eint5(arg1)-Eint5(arg))                                                 
          IF(i.LT.j) THEN                                                                           
             L1(i,j) = 0.5D+00*Lt1                                                                      
             L2(i,j) = 0.5D+00*(Lt2 + E2a1)                                                             
             L3(i,j) = 0.5D+00*(Lt3 - 2.0D+00/del*E3a1)                                                      
             L4(i,j) = 0.5D+00*(Lt4 + E2a1 + 6.0D+00/del/del*E4a1)                                           
           ELSE                                                                                     
            L1(i,j) = -0.5D+00*Lt1                                                                      
            L2(i,j) = 0.5D+00*(Lt2 - E2a1)                                                              
            L3(i,j) = 0.5D+00*(-Lt3 - 2.0D+00/del*E3a1 )                                                     
            L4(i,j) = 0.5D+00*(Lt4 - E2a1 - 6.0D+00/del/del*E4a1)                                            
          END IF                                                                                    
        END DO                                                                                      
      END DO                                                                                        
                                                                                                    
      DO i =1 , N                                                                                   
        DO j = 1, N                                                                                 
          IF(L1(i,j).LT.1.D-20) L1(i,j) = 0.0D+00                                                        
          IF(L2(i,j).LT.1.D-20) L2(i,j) = 0.0D+00                                                        
          IF(L3(i,j).LT.1.D-20) L3(i,j) = 0.0D+00                                                        
          IF(L4(i,j).LT.1.D-20) L4(i,j) = 0.0D+00                                                        
        END DO                                                                                      
      END DO                                                                                        
c ---------------------------------------------------------------------                             
      RETURN                                                                                        
      END                                                                                           
c *********************************************************************                             
                                                                                                    
                                                                                                    
c *********************************************************************                             
      SUBROUTINE SLBdifF(flag,om,grid,mat1,nL,nY,mat2,fp,fm)                                        
c =========================================================================                         
c     Integration of U(lam,t)*E2|Tau-t| to get the diffuse flux.                                    
c     flag=1 is for scattered and flag=0 for emitted flux. [MN, Apr'98]                             
c =========================================================================                         
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER iL, iY, j, nL, nY, flag                                                               
      DOUBLE PRECISION mat1(npL,npY), mat2(npL,npY), grid(npL,npY),                                 
     &             om(npL,npY), fp(npL,npY), fm(npL,npY), TAU(npY),                                 
     &             faux(npY), Efact, fave, SUM, Eint3                                               
c --------------------------------------------------------------------                              
      DO iL = 1, nL                                                                                 
        DO iY = 1, nY                                                                               
          TAU(iY) = grid(iL,iY)                                                                     
          IF (flag.EQ.1) THEN                                                                       
             faux(iY) = om(iL,iY)*mat1(iL,iY)                                                       
          ELSE                                                                                      
             faux(iY) = (1.0D+00-om(iL,iY))*mat1(iL,iY)                                                 
          END IF                                                                                    
        END DO                                                                                      
                                                                                                    
c       Find f(+) (in arg Tau>t)                                                                    
        DO iY = 1, nY                                                                               
          SUM = 0.0D+00                                                                                  
          DO j = 1, iY-1                                                                            
           Efact = dabs(Eint3(TAU(iY)-TAU(j))-Eint3(TAU(iY)-TAU(j+1)))                              
           fave = 0.5D+00*(faux(j)+faux(j+1))                                                           
           SUM = SUM + fave*Efact                                                                   
          END DO                                                                                    
          fp(iL,iY) = 0.5D+00*SUM                                                                       
c       and f(-) (in arg Tau>t)                                                                     
          SUM = 0.0D+00                                                                                 
          DO j = iY, nY-1                                                                           
           Efact = dabs(Eint3(TAU(iY)-TAU(j))-Eint3(TAU(iY)-TAU(j+1)))                              
           fave = 0.5D+00*(faux(j)+faux(j+1))                                                           
           SUM = SUM + fave*Efact                                                                   
          END DO                                                                                    
          fm(iL,iY) = 0.5D+00*SUM                                                                       
        END DO                                                                                      
                                                                                                    
        DO iY = 1, nY                                                                               
           mat2(iL,iY) = fp(iL,iY) - fm(iL,iY)                                                      
        END DO                                                                                      
c     End of loop over iL                                                                           
      END DO                                                                                        
c --------------------------------------------------------------------                              
      RETURN                                                                                        
      END                                                                                           
c *********************************************************************                             
                                                                                                    
                                                                                                    
c **********************************************************************                            
      DOUBLE PRECISION FUNCTION Eint1(x)                                                            
c ======================================================================                            
c Needed for the slab geometry. It calculates the first exponential                                 
c integral E1(x) by analytical f-la (13.13) from Abramovitz & Stegun(1994)                          
c                                                         [MN,Dec'97]                               
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER i                                                                                     
      DOUBLE PRECISION AC(4),BC(4), CC(6), x, aux, poly, denom                                      
      DATA AC/8.5733287401D+00,18.0590169730D+00,
     &        8.6347608925D+00,0.2677737343D+00/                                 
      DATA BC/9.5733223454D+00,25.6329561486D+00,
     &       21.0996530827D+00,3.9584969228D+00/                                
      DATA CC/-0.57721566D+00,0.99999193D+00,-0.24991055D+00,
     &         0.05519968D+00,-0.00976004D+00,0.00107857D+00/                                                                           
c ----------------------------------------------------------------------                            
c  For x=1D-15, E1~30 (used below to limit the value at x=0);for x>1, E1<1D-8                       
c  Two approximations are used, for x>1 and x<1, respectively                                       
      IF (x.GT.1.0D+00) THEN                                                                            
         poly = 0.0D+00                                                                                 
         denom = 0.0D+00                                                                              
         aux = 1.0D+00                                                                                  
         DO i = 1, 4                                                                                
           poly = poly + AC(5-i)*aux                                                                
           denom = denom + BC(5-i)*aux                                                              
           aux = aux * x                                                                            
         END DO                                                                                     
           poly = poly + aux                                                                        
           denom = denom + aux                                                                      
         Eint1 = poly/denom/x*dexp(-x)                                                              
      ELSE                                                                                          
         IF (x.LE.1.0D-15) x=1.0D-15                                                                 
         poly = 0.0D+00                                                                                 
         aux = 1.0D+00                                                                                  
         DO i = 1, 6                                                                                
           poly = poly + CC(i)*aux                                                                  
           aux = aux * x                                                                            
         END DO                                                                                     
         Eint1 = poly - dlog(x)                                                                     
      END IF                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
c **********************************************************************                            
      DOUBLE PRECISION FUNCTION Eint2(x)                                                            
c ======================================================================                            
c Needed for the slab geometry. It calculates the second exponential                                
c integral E2(x) by the recurrence f-la. (see Abramovitz & Stegun,1994)                             
c                                                         [MN,Dec'97]                               
c ======================================================================                            
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x, Eint1                                                                     
c -------------------------------------------------------------------------                         
       IF(x.LT.0.0D+00) x=dabs(x)                                                                        
       IF (x.LT.1.0D-15) THEN                                                                       
         Eint2 = 1.0D+00                                                                                
        ELSE                                                                                        
         Eint2 = dexp(-x) - x*Eint1(x)                                                              
       END IF                                                                                       
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
c **********************************************************************                            
      DOUBLE PRECISION FUNCTION Eint3(x)                                                            
c ======================================================================                            
c Needed for the slab geometry. It calculates the third exponential                                 
c integral E3(x) by the recurrence f-la. (see Abramovitz & Stegun,1994)                             
c                                                        [MN,Dec'97]                                
c ======================================================================                            
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x, Eint1                                                                     
c -------------------------------------------------------------------------                         
       IF(x.LT.0.0D+00) x=dabs(x)                                                                        
       IF (x.LT.1.0D-15) THEN                                                                       
         Eint3 = 0.5D+00                                                                                
        ELSE                                                                                        
         Eint3 = 0.5D+00*((1.0D+00-x)*dexp(-x)+x*x*Eint1(x))                                                
       END IF                                                                                       
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
                                                                                                    
c **********************************************************************                            
      DOUBLE PRECISION FUNCTION Eint4(x)                                                            
c ======================================================================                            
c Needed for the slab geometry. It calculates the fourth exponential                                
c integral E4(x) by the recurrence f-la. (see Abramovitz & Stegun,1994)                             
c                                                         [MN,Jan'97]                               
c ======================================================================                            
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x, Eint3                                                                     
c -------------------------------------------------------------------------                         
       IF(x.LT.0.0D+00) x=dabs(x)                                                                        
       IF (x.LT.1.0D-15) THEN                                                                       
         Eint4 = 1.0D+00/3.0D+00                                                                      
        ELSE                                                                                        
         Eint4 = (dexp(-x)-x*Eint3(x))/3.0D+00                                                       
       END IF                                                                                       
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c **********************************************************************                            
                                                                                                    
                                                                                                    
c **********************************************************************                            
      DOUBLE PRECISION FUNCTION Eint5(x)                                                            
c ======================================================================                            
c Needed for the slab geometry. It calculates the fifth exponential                                 
c integral E5(x) by the recurrence f-la. (see Abramovitz & Stegun,1994)                             
c                                                         [MN,Jan'97]                               
c ======================================================================                            
      IMPLICIT none                                                                                 
      DOUBLE PRECISION x, Eint4                                                                     
c -------------------------------------------------------------------------                         
        IF(x.LT.0.0D+00) x=dabs(x)                                                                       
       IF (x.LT.1.0d-15) THEN                                                                       
         Eint5 = 0.25D+00                                                                            
        ELSE                                                                                        
         Eint5 = 0.25D+00*(dexp(-x)-x*Eint4(x))                                                      
       END IF                                                                                       
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SLBacc(flux,accuracy,devmax,FbolOK,error)                                          
c =======================================================================                           
c This is SUB ChkFlux modified to be used for slab calculation.                                     
c Checks the bolometric flux conservation at any point of the slab grid.                            
c In case of nonconservation inserts a number of points at certain                                  
c places.                                             [MN,99; ZI'96]                                
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER iYins(npY), k, kins, iY, flag, error, istop, FbolOK                                   
      DOUBLE PRECISION Yins(npY), flux(npY), delTAUmax, devmax, ratio,                              
     &        accuracy, devfac, ff, ffold                                                           
c --------------------------------------------------------------------------                        
      error = 0                                                                                     
      kins = 0                                                                                      
      devmax = 0.0D+00                                                                                  
c     maximal delTAU is no more than 2 times the average value                                      
      delTAUmax = 2.0D+00*TAUtot(1)/nY                                                                  
c     find maximal relative deviation of fbol:                                                      
      DO iY = 2, nY                                                                                 
        ratio = (dabs(flux(iY))-dabs(fmed))/dabs(fmed)                                              
        IF (dabs(ratio).GT.devmax) devmax = dabs(ratio)                                             
      END DO                                                                                        
      ff = 0.0D+00                                                                                      
      istop = 0                                                                                     
      devfac = 0.1D+00                                                                                  
c     search for places to improve the grid                                                         
      DO WHILE (istop.NE.1)                                                                         
        DO iY = 2, nY                                                                               
          ratio = (dabs(flux(iY))-dabs(fmed))/dabs(fmed)                                            
          ffold = dabs(flux(iY-1)/fmed-1.0D+00)                                                          
          ff = dabs(flux(iY)/fmed-1.0D+00)                                                               
          flag = 0                                                                                  
c         if any of these criteria is satisfied insert a point:                                     
          IF(ff.GT.accuracy) flag=1                                                                 
c         1) if error is increasing too fast                                                        
          IF (abs(ff-ffold).GT.devfac*devmax) flag = 1                                              
c         2) if delTAU is too large at the left edge:                                               
          IF(TAUslb(1,iY).LT.5.0D+00) THEN                                                               
           IF ((TAUslb(1,iY)-TAUslb(1,iY-1)).GT.                                                    
     &                             delTAUmax) flag = 1                                              
          END IF                                                                                    
          IF(flag.EQ.1.AND.devmax.GE.accuracy) THEN                                                 
            kins = kins + 1                                                                         
            Yins(kins) = Y(iY-1)+0.5D+00*(Y(iY)-Y(iY-1))                                                
            iYins(kins) = iY-1                                                                      
          END IF                                                                                    
        END DO                                                                                      
        IF (devmax.LT.accuracy.OR.devfac.LT.0.01D+00) THEN                                              
          istop = 1                                                                                 
        ELSE                                                                                        
          IF (kins.GT.0) istop = 1                                                                  
        END IF                                                                                      
        devfac = devfac / 2.0D+00                                                                       
      END DO                                                                                        
                                                                                                    
      IF (kins.EQ.0) THEN                                                                           
         FbolOK = 1                                                                                 
        ELSE                                                                                        
c       Add all new points to Y(nY). This gives the new Y(nY+kins).                                 
c       However, check if npY is large enough to insert all points:                                 
        IF ((nY+kins).GT.npY) THEN                                                                  
         IF (iX.GE.1) THEN                                                                          
         write(18,*)' ****************     WARNING   ******************'                            
         write(18,*)'  The new Y grid can not accomodate more points!'                              
         write(18,'(a,i5)')'   Specified accuracy would require',nY+kins                            
         write(18,'(a,i5,a)')'   points, while npY =',npY,'.'                                       
         write(18,*)'  For the required accuracy npY must be increased,'                            
         write(18,*)'  (see the manual S3.5 Numerical Accuracy).'                                   
         write(18,*)' *************************************************'                            
         END IF                                                                                     
         kins = npY - nY                                                                            
         iWARNING = iWARNING + 1                                                                    
         error = 2                                                                                  
        END IF                                                                                      
        DO k = 1, kins                                                                              
          CALL SHIFT(Y,npY,nY+k-1,Yins(k),iYins(k)+k-1)                                             
        END DO                                                                                      
      END IF                                                                                        
c     new size of the Y grid                                                                        
      nY = nY + kins                                                                                
c --------------------------------------------------------------------------                        
777   RETURN                                                                                        
      END                                                                                           
c *********************************************************************                             
                                                                                                    
c *********************************************************************                             
      SUBROUTINE SLBmisc(fbol,fmax,fmed,AveDev,RMS,nY)                                              
c =======================================================================                           
c     Finds some additional quantities: favD-the average and fmed- the                              
c     median value of fbol in the slab, average and RMS deviations of                               
c     fbol from fmed.                                     [MN,Aug'98]                               
c =======================================================================                           
      IMPLICIT NONE                                                                                 
      INTEGER iY, nY, imid, iup, idn                                                                
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      DOUBLE PRECISION fbol(npY), fsort(npY), fave, fmed, AveDev,                                   
     &                 err, RMS, rnY, fmax, aux                                                     
c --------------------------------------------------------------------------                        
c     Find the median of fbol values distribution                                                   
      DO iY = 1, nY                                                                                 
        aux = DMAX1(dabs(fbol(iY)), accFbol)                                                        
        fbol(iY) = aux                                                                              
      END DO                                                                                        
      DO iY = 1, nY                                                                                 
        fsort(iY) = fbol(iY)                                                                        
      END DO                                                                                        
      CALL sort(fsort,nY)                                                                           
      IF (MOD(nY,2).NE.0) THEN                                                                      
c       if nY odd:                                                                                  
        imid = (nY+1)/2                                                                             
        fmed = fsort(imid)                                                                          
      ELSE                                                                                          
c       if nY even:                                                                                 
        iup = nY/2 + 1                                                                              
        idn = nY/2                                                                                  
        fmed = 0.5D+00*(fsort(iup) + fsort(idn))                                                        
      END IF                                                                                        
c     In sub PrOut: if(fmed.LE.accFbol) fmed =0                                                     
      rnY = 1.0D+00*nY                                                                                  
      fave = 0.0D+00                                                                                     
      fmax = 0.0D+00                                                                                     
c     find the max |fbol| (carried in slab.inc, needed in SLBacc)                                   
      DO iY = 1, nY                                                                                 
        fave = fave + fbol(iY)                                                                      
        aux = dabs(fbol(iY))                                                                        
        IF(aux.GT.fmax) fmax = aux                                                                  
      END DO                                                                                        
      fave = fave / rnY                                                                             
c     AveDev is the average relative deviation from the median                                      
      AveDev = 0.0D+00                                                                                   
      RMS = 0.0D+00                                                                                     
      DO iY = 1, nY                                                                                 
        aux = dabs(fbol(iY))                                                                        
c        err = dabs(fmed-aux) /fmax                                                                 
        err = dabs(fmed-aux) /fmed                                                                  
        AveDev = AveDev + err                                                                       
        RMS = RMS + err*err                                                                         
      END DO                                                                                        
      RMS = sqrt(RMS/rnY/(rnY-1.0D+00))                                                                  
      AveDev = AveDev/rnY                                                                           
c --------------------------------------------------------------------                              
      RETURN                                                                                        
      END                                                                                           
c ********************************************************************                              
                                                                                                    
c ********************************************************************                              
      SUBROUTINE SLBgray(model,nG,error)                                                            
c =======================================================================                           
c     Solves the gray slab problem. For single lambda calculation                                   
c     comment the call to Spectral in 'Main.for' and the calls to FindErr                           
c     in 'Analysis.for'                                      [MN, May'98]                           
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER iY, nG                                                                                
      INTEGER error, nLst, model                                                                    
      character tt*58                                                                               
      DOUBLE PRECISION mat0(npL,npY,npY), Em(npL,npY), Uold(npL,npY),                               
     &         fdsp(npL,npY),fdsm(npL,npY), fdep(npL,npY),fdem(npL,npY),                            
     &         fp(npY), fm(npY), fd(npY), Ud(npY), PsiGB, arg, FeGB                                 
c --------------------------------------------------------------------------                        
      nLst = nL                                                                                     
      nL = 1                                                                                        
c     generate some temporary arrays                                                                
      DO iY = 1, nY                                                                                 
c       to prevent exp underflow:                                                                   
        arg = TAUslb(1,iY)/mu1                                                                      
        IF(arg.GE.50.0D+00) THEN                                                                         
          Us(1,iY) = 0.0D+00                                                                             
        ELSE                                                                                        
          Us(1,iY) = 1.0D+00/mu1*dexp(-arg)                                                              
        END IF                                                                                      
        fs(1,iY) = dexp(-arg)                                                                       
        Em(1,iY) = 0.0D+00                                                                               
        omega(1,iY) = 1.0D+00                                                                            
      END DO                                                                                        
c     find radiative transfer matrices                                                              
      IF (iX.GE.1) write(18,*)' Calculating matrix, pure scatt, iL=1'                               
      CALL SLBMat(TAUslb,mat0)                                                                      
c     solve for Utot                                                                                
      CALL INVERT(nY,nL,mat0,Us,Em,omega,Utot,Uold,error)                                           
c      find new Td                                                                                  
       DO iY = 1, nY                                                                                
        IF(iY.eq.1.AND.typEntry(1).eq.1) THEN                                                       
c        typEntry(1)=1 is for Tsub(1) given in input                                                
         Tei = Tsub(1)*(4.0D+00/Utot(1,1))**0.25D+00                                                        
         Td(1,1) = Tsub(1)                                                                          
        END IF                                                                                      
        Td(1,iY) = Tei*(Utot(1,iY)/4.0D+00)**0.25D+00                                                       
        Ud(iY) = Utot(1,iY) - Us(1,iY)                                                              
       END DO                                                                                       
      PsiGB = mu1*Utot(1,1)                                                                         
c     this is mu1-independent, since Tei^4 ~ mu1                                                    
c      PsiGB = 4.*mu1*(Td(1,1)/Tei)**4.                                                             
      IF(typEntry(1).eq.1) THEN                                                                     
        FeGB=mu1 * 4.0D+00*5.67D+04/PsiGB*(Tsub(1)/1000.0D+00)**4.0D+00                                              
      ELSE                                                                                          
        FeGB = 5.67D-08*Tei**4.D+00                                                                     
      END IF                                                                                        
c      Find the diffuse scattered flux(fl=1 for scatt. and fl=0 is for emission)                    
       CALL SLBdifF(1,omega,TAUslb,Utot,nL,nY,fds,fdsp,fdsm)                                        
c      Find the diffuse emitted flux                                                                
       CALL SLBdifF(0,omega,TAUslb,Utot,nL,nY,fde,fdep,fdem)                                        
       CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                      
c      overall conservation of flux - min/max err                                                   
       DO iY = 1, nY                                                                                
        fbol(iY) = fTot(1,iY)                                                                       
        fsbol(iY) = fs(1,iY)                                                                        
        fp(iY) = fdsp(1,iY)+fdep(1,iY)                                                              
        fm(iY) = fdsm(1,iY)+fdem(1,iY)                                                              
        fd(iY) = fp(iY)-fm(iY)                                                                      
       END DO                                                                                       
c     FindErr calculates the err acc. to min/max values of fbol                                     
      CALL FindErr(fbol,maxFerr,nY)                                                                 
      CALL SLBmisc(fbol,fmax,fmed,AveDev,RMS,nY)                                                    
c --------------------------------------------------------------                                    
c     The slab Tau-profile at the fiducious lambda (needed in PrOut)                                
      DO iY = 1, nY                                                                                 
        tr(iY) = TAUslb(1,iY)/TAUslb(1,nY)                                                          
      END DO                                                                                        
      IF(iInn.EQ.1) THEN                                                                            
       write(18,*) '----- Single Lambda Case (iL=1) -----'                                          
        write(18,'(a10,1p,E11.3)')'    tauT =', TAUslb(1,nY)                                        
        write(18,'(a10,1p,E11.3)')'   PsiGB =',PsiGB                                                
        write(18,'(a10,1p,E11.3)')'    FeGB =',FeGB                                                 
        write(18,'(a10,1p,E11.3)')'    fmed =',fmed                                                 
c        write(18,'(a11,1p,E11.3)')'  RMS err =',RMS                                                
        write(18,'(a10,1p,E11.3)')' MAX err =',maxFerr                                              
        tt='     tr       UTot(i)      Td(i)      Ud(i)     fd(i)   '                               
        write(18,'(a58,a30)') tt , '  fs(i)     fbol(i)      fp(i) '                                
        DO iY = 1, nY                                                                               
         write(18,'(1p,8E11.3)') tr(iY), Utot(1,iY), Td(1,iY), Ud(iY),                              
     &                          fd(iY), fsbol(iY), fbol(iY), fp(iY)                                 
        END DO                                                                                      
      END IF                                                                                        
c      write(48,'(1p,5e12.4)') TAUslb(1,nY),Td(1,1),PsiGB,Ud(1),fd(1)                               
                                                                                                    
c     this is for running many models with single lambda case                                       
      SmC(5,model) = maxFerr                                                                        
      nL = nLst                                                                                     
                                                                                                    
      Tei = (FeGB/5.67D-08)**0.25D+00                                                                   
      Fi = FeGB                                                                                     
c -------------------------------------------------------------------------                         
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SLBIniT(nG)                                                                        
c =======================================================================                           
c This subroutine calculates the initial approximation for the temperature.                         
c It is based on the analogous subroutine InitTemp for spherical shell                              
c written by ZI, Jul'96.                                    [MN, Dec'97]                            
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER iL, iY, iG, nG, iW                                                                    
      DOUBLE PRECISION Sigext(npL), aux(npY), faux(npL), fstar(npY),                                
     &       Qfstar(npY),fstarQ(npY), QP(npY),QF(npY), TAU(npY), FovrF1,                            
     &       RHS(npY), IntQF, xP, Planck, resaux                                                    
c --------------------------------------------------------------------------                        
c     Lambda integral of fs=f_e*exp(-TAU) -> fstar                                                  
      CALL Bolom(fs,fstar)                                                                          
c     loop over grains                                                                              
      DO iG = 1, nG                                                                                 
        DO iY = 1, nY                                                                               
c         first approximation for temperature                                                       
          IF(iY.eq.1 .AND. typEntry(1).eq.1) THEN                                                   
c           in this case Tsub(1) is given in input                                                  
            Tei = Tsub(1) * 4.0D+00**0.25D+00                                                               
c           initialize the first element                                                            
            Td(iG,1) = Tsub(1)                                                                      
          END IF                                                                                    
c         if flux Fe1 is given in input in some form - at this point                                
c         Tei is initialized already in INPUT and carried in common/stellar/                        
          Td(iG,iY) = Tei /(4.0D+00**0.25D+00)                                                              
          RHS(iY) = 1.0D+00                                                                             
        END DO                                                                                      
                                                                                                    
c       generate the extinction cross-section Sigext                                                
        DO iL = 1, nL                                                                               
          Sigext(iL) = SigmaA(iG,iL)+SigmaS(iG,iL)                                                  
        END DO                                                                                      
c       Lambda integral of Sigext*fs -> Qfstar in IE97                                              
        DO iY = 1, nY                                                                               
c         generate auxiliary function for lambda integration:                                       
          DO iL = 1, nL                                                                             
            faux(iL) = Sigext(iL) *fs(iL,iY)/lambda (iL)                                            
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,faux,resaux)                                                 
          Qfstar(iY) = resaux                                                                       
        END DO                                                                                      
c      The slab geom. needs initial approximation for F/F1                                          
c      (The solution is not sensitive to this approximation, MN)                                    
        IF(TAUmax.LT.500.0D+00) THEN                                                                     
           FovrF1 = 1.0D+00                                                                             
         ELSE                                                                                       
           FovrF1 = 0.75D+00                                                                            
        END IF                                                                                      
c       Find the initial temperature profile by the expressions for slab,                           
c       analogous to eqs. B5 and B7 in IE97.                                                        
        DO iY = 1, nY                                                                               
c          generate auxiliary function for lambda integration:                                      
          DO iL = 1, nL                                                                             
            xP = 14400.0D+00 / Td(iG,iY) / lambda(iL)                                                   
            faux(iL) = Sigext(iL) * Planck(xP) / lambda (iL)                                        
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,faux,resaux)                                                 
c         Planck average of Sigext                                                                  
          QP(iY) = resaux                                                                           
c         calculate QF for slab (IV in the notes, the equivalent of eq.B5)                          
          QF(iY) = Qfstar(iY)/FovrF1+QP(iY)*(1.0D+00-fstar(iY)/FovrF1)                                  
c         Find the second term in III (in the notes)                                                
          DO iL = 1, nL                                                                             
            faux(iL)=fs(iL,iY)*(1.0D+00-SigmaA(iG,iL)/QP(iY))/lambda(iL)                                
          END DO                                                                                    
          CALL Simpson(npL,1,nL,lambda,faux,resaux)                                                 
          fstarQ(iY) = resaux                                                                       
        END DO                                                                                      
c       for each y calculate new alpha from III (the equivalent of eq.B7)                           
        DO iY = 1, nY                                                                               
          TAU(iY) = TAUslb(iLfid,iY)                                                                
        END DO                                                                                      
        DO iY = 1, nY                                                                               
          DO iW = iY, nY                                                                            
            aux(iW) = FovrF1*QF(iY)                                                                 
          END DO                                                                                    
          CALL Simpson(npY,iY,nY,TAU,aux,IntQF)                                                     
          RHS(iY) = 3.0D+00*IntQF - fstarQ(iY)                                                           
c         calculate temperature                                                                     
          Td(iG,iY) = Tei * (dabs(RHS(iY))/4.0D+00)**0.25D+00                                                
        END DO                                                                                      
c     end of loop over grains (iG)                                                                  
      END DO                                                                                        
                                                                                                    
c --------------------------------------------------------------------------                        
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c **********************************************************************                            
      SUBROUTINE SLBmat(TAUslb,mat0)                                                                
c ======================================================================                            
c This subroutine evaluates the radiative transfer matrix for slab geometry.                        
c TAUslb is the array of optical depths along the line of sight. [MN, Dec'97]                       
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iL, iY, i, j, k                                                                       
      DOUBLE PRECISION TAUslb(npL,npY), TAUr(npY), mat0(npL,npY,npY),                               
     &         L1(npY,npY),L2(npY,npY),L3(npY,npY),L4(npY,npY),                                     
     &         alpha(npY,npY), beta(npY,npY), gamma(npY,npY),                                       
     &         delta(npY,npY), SUM                                                                  
c -------------------------------------------------------------------------                         
      DO iL = 1, nL                                                                                 
       DO j = 1, nY                                                                                 
        DO k = 1, nY                                                                                
          mat0(iL,j,k) = 0.0D+00                                                                        
        END DO                                                                                      
       END DO                                                                                       
      END DO                                                                                        
c     -- evaluate matrix elements --                                                                
c     loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c      'Myspline' needs a 1D array                                                                  
        DO iY = 1, nY                                                                               
          TAUr(iY) = TAUslb(iL,iY)                                                                  
        END DO                                                                                      
c       Get the spline coefficients of the source function                                          
        CALL MYSPLINE(TAUr,nY,alpha,beta,gamma,delta)                                               
        CALL SLBAnalyt(TAUr,L1,L2,L3,L4,nY,npY)                                                     
c       Matrix element for U:                                                                       
        DO k = 1, nY                                                                                
          DO j = 1, nY                                                                              
            SUM = 0.0D+00                                                                                
            DO i = 1, nY                                                                            
             SUM = SUM + L1(i,k)*alpha(i,j)+L2(i,k)*beta(i,j)                                       
     &                 + L3(i,k)*gamma(i,j)+L4(i,k)*delta(i,j)                                      
            END DO                                                                                  
            mat0(iL,k,j) = SUM                                                                      
          END DO                                                                                    
        END DO                                                                                      
c     end of loop over wavelengths                                                                  
      END DO                                                                                        
c     save Y to Yok; needed for analysis in cases when requirement for                              
c     finer grids cannot be satisfied and previous solution is used for                             
c     output                                                                                        
      nYok = nY                                                                                     
      DO iY = 1, nY                                                                                 
        Yok(iY) = Y(iY)                                                                             
      END DO                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c ********************************************************************                              
                                                                                                    
                                                                                                    
c ********************************************************************                              
      SUBROUTINE SLBRadT(nG,error)                                                                  
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER Nmu, transmit                                                     
      DOUBLE PRECISION theta(npR),  muobs, tauT, Sfn                             
      COMMON/slbint/ theta,  muobs, tauT, Sfn, Nmu, transmit                    
      INTEGER iY, iL, nG, itnum, itlim, imu                                                         
      INTEGER error, Conv, iter, Fconv, Uconv, BolConv, m14                                         
      DOUBLE PRECISION mat0(npL,npY,npY), Em(npL,npY), fdsp(npL,npY),                               
     &    fdsm(npL,npY), fdep(npL,npY), fdem(npL,npY), fbolold(npY),                                
     &    Uold(npL,npY), dmaxU, dmaxF, olderr, oldmaxU, res, xP, Pi,                                
     &    IauxL(npL),IauxR(npL), IbolL(35), IbolR(35), Ibol(35),                                    
     &    Udbol(npY), Usbol(npY), QpTd1, QUtot1, qaux(npL), resaux,                                 
     &    PsiU, Tb, Qad, PSi0, qae,  Planck, IsbolL(35),IsbolR(35)                                  
c --------------------------------------------------------------------------                        
      Pi = 2.0D+00*ASIN(1.0D+00)                                                                            
      IF (iInn.eq.1) THEN                                                                           
        write(38,'(a8,i5)') '    nY= ',nY                                                           
        write(38,*) '    iter   maxFerr     dmaxU       dmaxF'                                      
      END IF                                                                                        
c     The slab Tau-profile at the fiducious lambda (needed in PrOut)                                
      DO iY = 1, nY                                                                                 
        tr(iY) = TAUslb(iLfid,iY)/TAUslb(iLfid,nY)                                                  
      END DO                                                                                        
c     generate stellar spectrum                                                                     
      CALL SLBStar(error)                                                                           
	IF(iVerb.eq.2) write(*,*)' Done with SLBStar '                                                     
c     generate albedo through the envelope                                                          
      CALL getOmega(nG)                                                                             
c     finish when file with the stellar spectrum is not available                                   
      IF (error.EQ.3) goto 999                                                                      
c     generate the first approximations for Td                                                      
      CALL SLBiniT(nG)                                                                              
      IF(iVerb.eq.2) write(*,*)' Done with SLBiniT'                                                 
                                                                                                    
c     find radiative transfer matrices                                                              
      IF (iX.GE.1) write(18,*)' Calculating weight matrices'                                        
      CALL SLBmat(TAUslb,mat0)                                                                      
      IF (iX.GE.1) THEN                                                                             
        write(18,*)' Weight matrices OK, calculating Tdust'                                         
      END IF                                                                                        
      itlim = 50000                                                                                 
      itnum = 4                                                                                     
      Conv = 0                                                                                      
      iter = 0                                                                                      
      oldmaxU = 0.0D+00                                                                                  
      olderr = 0.0D+00                                                                                   
      m14 = 0                                                                                       
c     === Iterations over dust temperature =========                                                
      DO WHILE (Conv.EQ.0.AND.iter.LE.itlim)                                                        
        iter = iter + 1                                                                             
c       find emission term                                                                          
        CALL Emission(0,0,nG,Td,abund,Us,Em)                                                        
c       solve for Utot                                                                              
        CALL Invert(nY,nL,mat0,Us,Em,omega,Utot,Uold,error)                                         
c       find new Td and alpha, and check convergence                                                
        CALL FindTemp(0,Utot,nG,Td)                                                                 
c       --------------------------------------                                                      
c       every itnum-th iteration check convergence:                                                 
c       first find 'old' flux (i.e. in the previous iteration)                                      
        IF (MOD(iter+1,itnum).EQ.0) THEN                                                            
c         Find the diffuse scattered flux(fl=1 for scatt. and fl=0 is for emissi                    
          CALL SLBdifF(1,omega,TAUslb,Utot,nL,nY,fds,fdsp,fdsm)                                     
c         Find the diffuse emitted flux                                                             
          CALL SLBdifF(0,omega,TAUslb,Em,nL,nY,fde,fdep,fdem)                                       
          CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                   
c         find bolometric flux                                                                      
          CALL Bolom(ftot,fbolold)                                                                  
        END IF                                                                                      
        IF (MOD(iter,itnum).EQ.0) THEN                                                              
c         Find the diffuse scattered flux                                                           
          CALL SLBdifF(1,omega,TAUslb,Utot,nL,nY,fds,fdsp,fdsm)                                     
c         Find the diffuse emitted flux                                                             
          CALL SLBdifF(0,omega,TAUslb,Em,nL,nY,fde,fdep,fdem)                                       
c         Add them to the stellar flux to find total flux                                           
          CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                   
c         find bolometric flux                                                                      
          CALL Bolom(ftot,fbol)                                                                     
c         check convergence of bolometric flux                                                      
          CALL Converg1(nY,accFbol,dynrange,fbolold,fbol,Fconv,dmaxF)                               
c         check convergence of energy density                                                       
          CALL Converg2(nY,nL,accConv,dynrange,Uold,Utot,Uconv,dmaxU)                               
c         FindErr calculates the err acc. to min/max values                                         
          CALL FindErr(fbol,maxFerr,nY)                                                             
c         flag m14 is to prevent unnecessary looping if convergence                                 
c         is extremely slow and err does not improve.                                               
          IF(iter.GE.1000.AND.                                                                      
     &           dabs(dmaxU-oldmaxU).LE.1.0d-5.AND.                                                 
     &             dabs(maxFerr-olderr).LE.1.0d-4) THEN                                             
            m14 = 1                                                                                 
            Conv = 1                                                                                
          END IF                                                                                    
          olderr = maxFerr                                                                          
          oldmaxU = dmaxU                                                                           
c ------  printout of errors and convergence with iter.(inner flag): ----                           
          IF(iInn.EQ.1) THEN                                                                        
            write(38,'(i7,1p,3e12.4)') iter, maxFerr, dmaxU, dmaxF                                  
          END IF                                                                                    
c ------------------------------------------------------------------------                          
          IF (maxFerr.LE.accuracy) THEN                                                             
            BolConv = 1                                                                             
          ELSE                                                                                      
            BolConv = 0                                                                             
          END IF                                                                                    
c         total criterion for convergence: Utot must converge, and ftot                             
c         must either converge or have the required accuracy                                        
          IF (Uconv*(Fconv+BolConv).GT.0) Conv = 1                                                  
        END IF                                                                                      
      END DO                                                                                        
c     === The End of Iterations over Td ===                                                         
      IF (iX.GE.1) THEN                                                                             
        IF (iter.le.itlim) THEN                                                                     
          write(18,*)' Convergence achieved, number of'                                             
          write(18,'(a34,i4)')                                                                      
     &      ' iterations over energy density: ',iter                                                
        ELSE                                                                                        
          write(18,'(a38,i5,a7)')                                                                   
     &    '  No convergence on energy density in',iter,' iter.'                                     
          iWARNING = iWARNING + 1                                                                   
        END IF                                                                                      
        write(18,'(a25,1p,E10.2)')                                                                  
     &    '  Max error in bol.flux:',maxFerr                                                        
      END IF                                                                                        
c     calculate the emission term for the converged Td                                              
        CALL Emission(0,0,nG,Td,abund,Us,Em)                                                        
c     calculate flux                                                                                
      CALL SLBdifF(1,omega,TAUslb,Utot,nL,nY,fds,fdsp,fdsm)                                         
      CALL SLBdifF(0,omega,TAUslb,Em,nL,nY,fde,fdep,fdem)                                           
      CALL Add(npY,nY,npL,nL,fs,fds,fde,ftot)                                                       
      CALL Add2(fdsp,fdep,fpbol,nY)                                                                 
      CALL Add2(fdsm,fdem,fmbol,nY)                                                                 
      CALL Bolom(ftot,fbol)                                                                         
      CALL Bolom(fs,fsbol)                                                                          
c     Find the err acc. to min/max values of fbol:                                                  
      CALL FindErr(fbol,maxFerr,nY)                                                                 
c     find average value of fbol and some misceleneous quantities                                   
      CALL SLBmisc(fbol,fmax,fmed,AveDev,RMS,nY)                                                    
c     calculate additional output quantities                                                        
      CALL Multiply(1,npY,nY,npL,nL,mat0,Utot,omega,0,Us,Uds)                                       
      CALL Multiply(0,npY,nY,npL,nL,mat0,Em,omega,0,Us,Ude)                                         
      CALL Add(npY,nY,npL,nL,Us,Uds,Ude,Uchck)                                                      
      CALL Bolom(Utot,Ubol)                                                                         
      CALL Bolom(Uchck,UbolChck)                                                                    
c     if emerging intensity is required (for left side ill.only):                                   
      IF (iVerb.EQ.2.AND.iC.GT.0) write(*,*)'Calculating Intensity'                                 
      IF(iC.GT.0.AND.ksi.eq.0.0D+00) THEN                                                                 
c       CALL SLBIntensity(TAUslb,fs,omega,Em,Utot,SLBIntL,SLBIntR,                                  
c     &                     mu1,nL,nY)                                                              
c      as is in ints2.06a.f:                                                                        
       CALL SLBIntensity(TAUslb,fs,omega,Em,Utot,SLBIntL,SLBIntR,                                   
     &                    IstR,mu1,nL,nY)                                                           
c -------- added May'01 -----------------                                                           
c      SLBInts are scaled so I_lam/Fe = mu1*i_lam/4/pi,                                             
c      where Fe = L/(4*pi*r^2)                                                                      
       DO imu = 1, Nmu                                                                              
         DO iL = 1, nL                                                                              
c          mu1/4/pi*Int gives I_lam/Fe                                                              
           SLBIntR(imu,iL) = SLBIntR(imu,iL)*mu1/4.0D+00/Pi                                              
           SLBIntL(imu,iL) = SLBIntL(imu,iL)*mu1/4.0D+00/Pi                                              
           IauxR(iL) = SLBIntR(imu,iL)/lambda(iL)                                                   
           IauxL(iL) = SLBIntL(imu,iL)/lambda(iL)                                                   
         END DO                                                                                     
c        bol. intensity from the right ...                                                          
         CALL SIMPSON(npL,1,nL,lambda,IauxR,res)                                                    
         IbolR(imu) = res                                                                           
c        ... and left side                                                                          
         CALL SIMPSON(npL,1,nL,lambda,IauxL,res)                                                    
         IbolL(imu) = res                                                                           
       END DO                                                                                       
                                                                                                    
c      get muobs*i(mu,lam):                                                                         
       DO imu = 1, Nmu                                                                              
         muobs = dcos(theta(imu))                                                                   
         IF(dabs(mu1-muobs).LT.1.0d-4) THEN                                                         
            IsbolR(imu) = muobs*fsbol(nY)                                                           
         ELSE                                                                                       
            IsbolR(imu) = 0.0D+00                                                                        
         END IF                                                                                     
        Ibol(imu) = IbolL(imu) + IbolR(imu)                                                         
        IsbolL(imu) = fsbol(1)                                                                      
       END DO                                                                                       
       IF(iX.GE.1.AND.iInn.EQ.1) THEN                                                               
        write(18,*) '----------------------------------------'                                      
        write(18,*)                                                                                 
     & ' theta_out    IdbolR     IdbolL     IsbolR      IsbolL'                                     
        DO imu = 1, Nmu                                                                             
         write(18,'(1p,5E11.3)') theta(imu), IbolR(imu),                                            
     &                           IbolL(imu), IsbolR(imu),IsbolL(imu)                                
        END DO                                                                                      
       END IF                                                                                       
       write(18,*) '------------------------------------'                                           
c     end if for intensity flag                                                                     
      END IF                                                                                        
c ****************** temporary, Apr'00 **************                                               
c     Additional output of T1,Psi for all models -                                                  
c     in one file for convenient plotting.                                                          
c     Find the Planck averaged absorption efficiencies                                              
       DO iL = 1, nL                                                                                
         xP = 14400.0D+00 / Td(1,1) / lambda(iL)                                                        
         qaux(iL) = SigmaA(1,iL) * Planck(xP) / lambda (iL)                                         
       END DO                                                                                       
       CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                    
       QpTd1 = resaux                                                                               
c     find  qae=Int qa*fe dlam                                                                      
       DO iL = 1, nL                                                                                
          qaux(iL) = SigmaA(1,iL) * fs(iL,1)/lambda(iL)                                             
       END DO                                                                                       
       CALL SIMPSON(npL,1,nL,lambda,qaux,resaux)                                                    
        qae = resaux                                                                                
       Psi0 = qae / QpTd1                                                                           
c ----------                                                                                        
      DO iL = 1, nL                                                                                 
        qaux(iL) = SigmaA(1,iL) * Utot(iL,1) / lambda (iL)                                          
      END DO                                                                                        
      CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                     
      QUtot1 = resaux                                                                               
      PsiU = mu1*QUtot1 / QpTd1                                                                     
      CALL Bolom(Us,Usbol)                                                                          
      DO iY = 1, nY                                                                                 
       Udbol(iY) = Ubol(iY) - Usbol(iY)                                                             
      END DO                                                                                        
      Tb = Tei*dsqrt(dsqrt(dabs(fmbol(1))))                                                         
c ----------                                                                                        
      DO iL = 1, nL                                                                                 
        qaux(iL) = SigmaA(1,iL) * (Uds(iL,1)+Ude(iL,1))/lambda(iL)                                  
      END DO                                                                                        
      CALL Simpson(npL,1,nL,lambda,qaux,resaux)                                                     
      Qad = resaux                                                                                  
                                                                                                    
c      write(48,'(1p,4e12.4)') TAUfid,Td(1,1),PsiU,Psi0                                             
                                                                                                    
c ************************************                                                              
c     screen output of maxFerr for convenience                                                      
      write(*,'(a11,1p,E11.3)')'  MAX err =',maxFerr                                                
c     fmed is printed in .out file as f1 = fmed = F/Fe1                                             
c ============ if the inner flag iInn=1:  =========                                                 
      IF(iX.GE.1 .AND. iInn.EQ.1) THEN                                                              
c       this printout is if iInn=1 for additional output                                            
c       print to message file                                                                       
        write(18,'(a11,1p,E11.3)')'   TAUfid =',TAUfid                                              
        IF(mu1.NE.-1.0D+00)  
     &         write(18,'(a11,1p,E11.3)')'      Psi =',PsiU                                                
        write(18,'(a11,1p,E11.3)')'     fmed =',fmed                                                
        write(18,'(a11,1p,E11.3)')'     fmax =',fmax                                                
        write(18,'(a11,1p,E11.3)')'  MAX err =',maxFerr                                             
        write(18,*)                                                                                 
     &'     tr      Ubol       Udbol      fdbol       fsbol     fbol'                               
        DO iY = 1, nY                                                                               
         write(18,'(1p,6E11.3)') tr(iY), Ubol(iY), Udbol(iY),                                       
     &               (fpbol(iY)-fmbol(iY)), fsbol(iY), fbol(iY)                                     
        END DO                                                                                      
      END IF                                                                                        
c ===================================================                                               
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SLBIntensity(TAUslb,fs,omega,Em,Utot,SLBIntL,SLBIntR,                              
     & IstR,mu1,nL,nY)                                                                              
c =======================================================================                           
      IMPLICIT none                                                                                 
       DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
       COMMON /constants/ Pi, sigma, Gconst, r_gd                               
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER Nmu, transmit                                                     
      DOUBLE PRECISION theta(npR),  muobs, tauT, Sfn                             
      COMMON/slbint/ theta,  muobs, tauT, Sfn, Nmu, transmit                    
      INTEGER nL, nY, iL, iY, imu                                                                   
      DOUBLE PRECISION Em(npL,npY), Utot(npL,npY), omega(npL,npY), mu1,                             
     &       TAUslb(npL,npY),SlbIntL(npR,npL),SlbIntR(npR,npL),                                       
     &       tau1(npY), IstR(npL), IdifL, IdifR, fs(npL,npY), res,                                  
     &       Sexp, Kron                                                                             
      EXTERNAL Sexp                                                                                 
c -----------------------------------------------------------------------                           
c     Loop over wavelengths                                                                         
      DO iL = 1, nL                                                                                 
c     Loop over angles (i.e. muobs), read in Input from 'slb_mugrid.dat'                            
        DO imu = 1, Nmu                                                                             
c         muobs and tauT are in 'slbintens.inc'                                                     
          muobs = dcos(theta(imu))                                                                  
          tauT = TAUslb(iL,nY)                                                                      
          IF(dabs(mu1-muobs).LT.1.0D-4) THEN                                                        
            Kron = 1.0D+00                                                                               
          ELSE                                                                                      
            Kron = 0.0D+00                                                                               
          END IF                                                                                    
c         Find the emerging intensity at ea.lambda for the required angles:                         
c         scaled stellar intensity (fs contains the exp term):                                      
c         this is for finding i_lam*muobs. Since the stellar term is:                               
c         IstR(iL)=muobs*(4.*Pi)/mu1 * fs(iL,nY)                                                    
c         this gives stellar int. in units I_lam/Ie=fs*muobs=fs*mu1 (stellar ray                    
c         is seen only when mu1=muobs), so instead of using Kron, directly multiply bu mu1                    
          IstR(iL) = mu1 * fs(iL,nY)                                                                
          IF(IstR(iL).LE.1.0d-20) IstR(iL) = 0.0D+00	                                                    
c         scaled diffuse intensity:                                                                 
          IdifR = 0.0D+00                                                                                
          IdifL = 0.0D+00                                                                                
          tau1(1) = 0.0D+00                                                                              
          DO iY = 2, nY                                                                             
            tau1(iY) = TAUslb(iL,iY)                                                                
c           Em() = 4*(T/Tei)^4 and sigma*Tei^4 = mu1*Ie                                             
            Sfn=(1.0D+00-omega(iL,iY))*Em(iL,iY)+
     &                           omega(iL,iY)*Utot(iL,iY)                            
c           transmit=1 for transmitted, transmit=0 for reflected intensity                          
            transmit = 1                                                                            
            CALL ROMBY(Sexp,tau1(iY-1),tau1(iY),res)                                                
            IdifR = IdifR + res                                                                     
            transmit = 0                                                                            
            CALL ROMBY(Sexp,tau1(iY-1),tau1(iY),res)                                                
            IdifL = IdifL + res                                                                     
          END DO                                                                                    
          IF(IdifR.LT.1.D-20) IdifR = 0.0D+00                                                            
          IF(IdifL.LT.1.D-20) IdifL = 0.0D+00                                                            
c          SLBIntR(imu,iL) = Kron*IstR(iL) + IdifR                                                  
          SLBIntR(imu,iL) = IdifR                                                                   
          SLBIntL(imu,iL) = IdifL                                                                   
c       enddo over angles                                                                           
        END DO                                                                                      
c     enddo over lambda                                                                             
      END DO                                                                                        
c -----------------------------------------------------------------                                 
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c **********************************************************************                            
      DOUBLE PRECISION FUNCTION Sexp(t)                                                             
c     This is the function under the tau-integral; it is called from Romby.                         
c     Here t = tau(iY); the flag 'transmit' is in 'slbintens.inc'.                                  
c ======================================================================                            
      IMPLICIT NONE
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)            
      DOUBLE PRECISION t, arg, efact                                                                
      INTEGER Nmu, transmit                                                     
      DOUBLE PRECISION theta(npR),  muobs, tauT, Sfn                             
      COMMON/slbint/ theta,  muobs, tauT, Sfn, Nmu, transmit                    
c -----------------------------------------------------------------                                 
        IF(transmit.eq.1) THEN                                                                      
c         for transmitted intensity                                                                 
          arg = (tauT-t) / muobs                                                                    
        ELSE                                                                                        
c         for reflected intensity                                                                   
          arg = t / muobs                                                                           
        END IF                                                                                      
c       limits (in case of exp over/under flow)                                                     
        IF(arg.GT.50.0D+00) THEN                                                                         
          efact = 0.0D+00                                                                                
        ELSE                                                                                        
          efact = dexp(-arg)                                                                        
        END IF                                                                                      
        IF(arg.LT.1.0D-6) efact = 1.0D+00                                                                 
c       and finally the function under the integral:                                                
        Sexp = Sfn * efact                                                                          
c -----------------------------------------------------------------                                 
      RETURN                                                                                        
      END                                                                                           
c***********************************************************************                            
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SLBsolve(model,nG,error)                                                           
c =======================================================================                           
c This subroutine solves the continuum radiative transfer problem in                                
c planar geometry.                                      [MN, Dec.'97]                               
c =======================================================================                           
      IMPLICIT none                                                                                 
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      INTEGER nY, nYprev, nP, nL, nPcav                                         
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                 
     &       bOut(npP+2)                                                        
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                 
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                 
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                     
      CHARACTER*235 nameETA                                                     
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                  
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),             
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                             
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                  
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,           
     &                  yEtaf                                                   
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                        
      INTEGER Ncav, Nins                                                        
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,              
     &                 dynrange, EtaRat, accFbol                                
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,             
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                   
      INTEGER iLfid, szds, top, Nfiles                                          
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),           
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                   
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                   
     &     a1, a2, aveV, aveA                                                   
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,              
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,            
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                  
      CHARACTER*100 zline(999)                                                  
      INTEGER iOUT, iVerb, iSPP, iA, iB, iC, iX, NlambdaOut,                    
     &         iInn, iPSF, iV, Nconv, Nvisi, iD, iPhys                                 
      DOUBLE PRECISION LambdaOut(20), ConvInt(20,1000), Visib(20,1000),         
     &       Offset(1000), qtheta1(1000), Te_min                                
      COMMON /output/ LambdaOut, ConvInt, Visib, Offset, qtheta1,               
     &      Te_min, iPSF, NlambdaOut, iOUT, iVerb, iSPP,                        
     &      iA, iB, iC, iX, iInn, iV, Nconv, Nvisi, iD, iPhys, zline                   
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,           
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),              
     &         IstR(npL), AveDev, RMS, maxFerr                                  
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,           
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                              
                                                                                
      INTEGER nYok, nPok                                                        
      DOUBLE PRECISION                                                          
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),             
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),           
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                 
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),          
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),         
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                 
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                       
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,             
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,             
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                      
      INTEGER iWARNING, iERROR, iCUMM                                           
      COMMON /status/ iWARNING, iERROR, iCUMM                                   
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right           
      CHARACTER nameStar(2)*235                                                 
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),          
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,          
     &         dilutn, UsR(npL,npY)                                             
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,           
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,           
     &       nBB, typEntry, Left, Right, nameStar                               
      INTEGER model, error, nG, iterFbol, FbolOK, grid                                              
	DOUBLE PRECISION devmax, oldFerr, mu, h, k                                                         
      LOGICAL oblique                                                                               
c --------------------------------------------------------------------------                        
c     counter for iterations over bolometric flux conservation                                      
      iterFbol = 0                                                                                  
      FbolOK = 0                                                                                    
      oldFerr = 100.0D+00                                                                                
c     make the grid for the smaller mu                                                              
      IF (dabs(mu1).LE.dabs(mu2)) THEN                                                              
        mu = dabs(mu1)                                                                              
      ELSE                                                                                          
        mu = dabs(mu2)                                                                              
      END IF                                                                                        
		                                                                                                  
      IF((mu.LE.0.1D+00).AND.(TAUmax.GE.20.0D+00)) THEN                                                      
         oblique = .true.                                                                           
         grid = 1                                                                                   
c      initial parameters for the oblique illumination grid                                         
       IF(npY.LT.50) THEN                                                                           
        iWARNING = iWARNING + 1                                                                     
        error = 4                                                                                   
        RETURN                                                                                      
       ELSE                                                                                         
        nY = 50                                                                                     
       END IF                                                                                       
        h = 0.5D+00                                                                                     
        k = 5.0D+00                                                                                     
        CALL SLBtrace(TAUmax,TAUTot,TAUslb,Y,mu,h,k,nL,nY)                                          
      ELSE                                                                                          
         oblique = .false.                                                                          
         grid = 0                                                                                   
c       generate the increment for the initial TAU-grid (grid=0)                                    
        CALL SLBY(TAUmax,Y,nY)                                                                      
      END IF                                                                                        
c ------------- Loop over bol.flux conservation -------------                                       
      DO WHILE (FbolOK.EQ.0)                                                                        
       iterFbol = iterFbol + 1                                                                      
        IF((iterFbol.GE.3).AND.(oblique).AND.(iX.GE.1)) THEN                                        
          write(18,*)'  Can not improve the oblique'                                                
          write(18,*)'  illumination grid anymore  '                                                
          iWARNING = iWARNING + 1                                                                   
          FbolOK = 2                                                                                
          RETURN                                                                                    
        END IF                                                                                      
        IF (iX.GE.1) THEN                                                                           
          write(18,*)'  ',iterFbol,' iteration over Fbol'                                           
        END IF                                                                                      
        IF (iVerb.EQ.2) write(*,'(a14,i3,a20)')                                                     
     &     ' In SLBsolve: ',iterFbol,' iteration over Fbol'                                         
c       if the illumination angle is too large choose the proper grid                               
        IF(grid.NE.1) THEN                                                                          
          CALL SLBtau(TAUTot,TAUslb,Y,nL,nY)                                                        
        END IF                                                                                      
        IF (iX.GE.1) THEN                                                                           
          write(18,'(a28,i3,a12)') '  Calculation for slab with ',                                  
     &                          nY,' grid points'                                                   
        END IF                                                                                      
        IF (nY.GT.npY) THEN                                                                         
         IF (iVerb.EQ.2) write(*,*)' npY needs to be increased!'                                    
         IF (iX.GE.1) THEN                                                                          
          write(18,*) ' ********** MESSAGE from SOLVE *********'                                    
          write(18,*) ' npY has to be increased in file userpar.inc'                                
          write(18,*) ' ***************************************'                                    
          iWARNING = iWARNING + 1                                                                   
          RETURN                                                                                    
         END IF                                                                                     
        END IF                                                                                      
c       solve the radiative transfer problem                                                        
        CALL SLBRadT(nG,error)                                                                      
         IF (iVerb.EQ.2) write(*,*)'Done with SLBRadT'                                              
c       for tests of single lambda case uncomment below                                             
c       and comment CALL Spectral in MAIN:                                                          
c        CALL SLBgray(model,nG,error)                                                               
        IF(maxFerr.LE.accuracy) THEN                                                                
          FbolOK = 1                                                                                
        ELSE                                                                                        
         IF(oblique) THEN                                                                           
           IF(iterFbol.EQ.2) THEN                                                                   
c            next try with 104pt grid:                                                              
             h = h/1.5D+00                                                                              
             k = k*1.5D+00                                                                              
             nY = 104                                                                               
             CALL SLBtrace(TAUmax,TAUTot,TAUslb,Y,mu,h,k,nL,nY)                                     
           END IF                                                                                   
           IF(iterFbol.EQ.3) THEN                                                                   
c            last attempt with 160pt grid:                                                          
             h = 0.25D+00                                                                               
             k = 7.5D+00                                                                                
             nY = 160                                                                               
             CALL SLBtrace(TAUmax,TAUTot,TAUslb,Y,mu,h,k,nL,nY)                                     
           END IF                                                                                   
         ELSE                                                                                       
           CALL SLBacc(fbol,accuracy,devmax,FbolOK,error)                                           
           IF(iterFbol.GT.1.AND.maxFerr.GT.oldFerr) THEN                                            
            IF(iX.GE.1) THEN                                                                        
             write(18,*)' ================ WARNING ================= '                              
             write(18,*)' Error is increasing in spite of grid'                                     
             write(18,*)' improvement. Stopping iterations over Fbol.'                              
            END IF                                                                                  
            error = 0                                                                               
            FbolOK = 2                                                                              
            iWARNING = iWARNING + 1                                                                 
           END IF                                                                                   
           oldFerr = maxFerr                                                                        
         END IF                                                                                     
c         if the grid size limit is reached error=2                                                 
          IF (error.EQ.2.AND.iterFbol.EQ.1) THEN                                                    
c          if this is the first calculation end this model                                          
           IF(iX.GE.1) THEN                                                                         
            write(18,*)' =========== IMPORTANT WARNING =========== '                                
            write(18,*)' The limit for grid size is already reached'                                
            write(18,*)' and flux conservation can not be improved'                                 
            write(18,'(a,1p,e10.2)')'  Max deviation of Fbol ',maxFerr                              
            write(18,*)' Treat all results with caution!'                                           
           END IF                                                                                   
           error = 0                                                                                
           FbolOK = 2                                                                               
           iWARNING = iWARNING + 1                                                                  
          END IF                                                                                    
c         if this is a higher iteration use previous solution                                       
          IF (error.EQ.2) THEN                                                                      
            IF (iX.GE.1.AND.iterFbol.GT.1) THEN                                                     
              write(18,*)' ======= IMPORTANT WARNING ======== '                                     
              write(18,*)' In trying to conserve Fbol reached'                                      
              write(18,*)' the limit for grid sizes.  '                                             
              write(18,'(a,1p,e10.2)')'  Max deviation of Fbol:',maxFerr                            
              write(18,*)' Treat all results with caution!'                                         
            END IF                                                                                  
            error = 0                                                                               
            FbolOK = 2                                                                              
            iWARNING = iWARNING + 1                                                                 
          END IF                                                                                    
c         if Fbol not conserved try again with a finer grid                                         
          IF (FbolOK.EQ.0 .AND. iX.GE.1) THEN                                                       
            write(18,*)'  ******** MESSAGE from SOLVE ********'                                     
            write(18,'(a,1p,e10.2)')                                                                
     &                '  Max deviation of Fbol:', maxFerr                                           
            write(18,*)'  Trying again with finer grids'                                            
          END IF                                                                                    
c        if could not conserve Fbol in 5 trials give it up                                          
         IF (FbolOK.EQ.0 .AND. iterFbol.GT.5) THEN                                                  
          IF (iX.GE.1) THEN                                                                         
          write(18,*)' **********  WARNING from SOLVE  **********'                                  
          write(18,*)' Could not obtain required accuracy '                                         
          write(18,'(a4,i4,a8)')' in ',iterFbol,' trials.'                                          
          write(18,'(a23,1p,e10.2)')' Max deviation of Fbol:',maxFerr                               
          write(18,*)' !!!!  Treat all results with caution  !!!!'                                  
          write(18,*)' ******************************************'                                  
          END IF                                                                                    
          iWARNING = iWARNING + 1                                                                   
          FbolOK = 2                                                                                
         END IF                                                                                     
        END IF                                                                                      
c     end of loop over flux conservation                                                            
      END DO                                                                                        
c -----------------------------------------------------------------------                           
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           

c ***********************************************************************                           
      SUBROUTINE SLBStar(error)                                                                     
c =======================================================================                           
c This subroutine generates the stellar moments in case of slab geometry.                           
c is=1 is for the left src, is=2 is the right src          [MN, Feb.'99]                            
c =======================================================================                           
      IMPLICIT none   
      DOUBLE PRECISION Pi, sigma, Gconst, r_gd                                 
      COMMON /constants/ Pi, sigma, Gconst, r_gd                                                                                                             
      INTEGER npY, npP, npX, npL, npG, npR                                                               
      INCLUDE 'userpar.inc'                                                                         
      PARAMETER (npG=1)                                                                             
      INTEGER nY, nYprev, nP, nL, nPcav                                                             
      DOUBLE PRECISION Y(npY), Yprev(npY), P(npP), lambda(npL),                                     
     &       bOut(npP+2)                                                                            
      COMMON /grids1/ nY, nYprev, nP, nPcav, nL                                                     
      COMMON /grids2/ Y, Yprev, P, lambda, bOut                                                     
      INTEGER denstyp, Ntr, iterETA, nYEtaf                                                         
      CHARACTER*235 nameETA                                                                         
      LOGICAL POWD, EXPD, RDW, RDWA, FILD, SLB                                                      
      DOUBLE PRECISION pow, Yout, ETAcoef(npY,4), ptr(10), Ytr(10),                                 
     &       ETAdiscr(npY), yEtaf(1000), Etaf(1000)                                                 
      COMMON /density1/ denstyp, Ntr, iterETA, nYEtaf, nameETA                                      
      COMMON /density2/ pow, Yout, ETAcoef, Ytr, ptr, ETAdiscr, Etaf,                               
     &                  yEtaf                                                                       
      COMMON /density3/ POWD, EXPD, RDW, RDWA, FILD, SLB                                            
      INTEGER iLfid, szds, top, Nfiles                                                              
      DOUBLE PRECISION TAUtot(npL), SigmaA(npG,npL), SigmaS(npG,npL),                               
     &     omega(npL,npY), Tsub(npG), abund(npG,npY), TAUmax,                                       
     &     xC(10), xCuser(10), SigExfid, TAUfid, lamfid, qsd,                                       
     &     a1, a2, aveV, aveA                                                                       
      COMMON /optprop/ TAUtot, SigmaA, SigmaS, omega, Tsub, abund,                                  
     &            TAUmax, xC, xCuser, SigExfid, TAUfid, lamfid, qsd,                                
     &            a1, a2, aveV, aveA, iLfid, szds, top, Nfiles                                      
      INTEGER Ncav, Nins                                                                            
      DOUBLE PRECISION accRomb, accuracy, accConv, delTAUsc, facc,                                  
     &                 dynrange, EtaRat, accFbol
      COMMON /numerics/ accRomb, accuracy, accConv, delTAUsc, facc,                                 
     &                  dynrange, EtaRat, accFbol, Ncav, Nins                                 
      INTEGER nYok, nPok                                                                            
      DOUBLE PRECISION                                                                              
     &       Ude(npL,npY), Uds(npL,npY), Us(npL,npY), fde(npL,npY),                                 
     &       fds(npL,npY), fs(npL,npY), Utot(npL,npY), ftot(npL,npY),                               
     &       Td(npG,npY), Ubol(npY), fbol(npY), Uchck(npL,npY),                                     
     &       UbolChck(npY), Spectrum(npL), SpecChar(30,99), tauF(npY),                              
     &       Intens(npL,npP+2), IntOut(20,npP+2), SmC(30,99), Yok(npY),                             
     &       Pok(npP), tauOut(npL), tauZout(npP+2), Fi, tr(npY),                                    
     &       rg(npG,npY), fsL(npL,npY), fsR(npL,npY), Eps(npY),                                     
     &       fsRp(npL,npY), fsRm(npL,npY), Fout, Fdiff                                              
      COMMON /solution/ Ude, Uds, Us, fde, fds, fs, Utot, ftot, Td,                                 
     &       Ubol, fbol, Uchck, UbolChck, Spectrum, SpecChar, tauF,                                 
     &       Intens, IntOut, SmC, Yok, Pok, tauOut, tauZout, Fi,                                    
     &       tr, rg, fsL, fsR, Eps, fsRp, fsRm, Fout, Fdiff, nYok, nPok                             
      INTEGER startyp(2), Nlamtr(2), nBB(2), typEntry(2), Left, Right                               
      CHARACTER nameStar(2)*235                                                                     
      DOUBLE PRECISION Tstar(2), lamtr(2,101), klam(2,100), Tbb(2,10),                              
     &         rellum(2,10), mu1, ksi, mu2, xSiO, r1rs, Tei, Teo, chi,                              
     &         dilutn, UsR(npL,npY)                                                                 
      COMMON /source/ Tstar, lamtr, klam, Tbb, rellum, mu1, ksi, mu2,                               
     &       xSiO, r1rs, Tei, Teo, chi, dilutn, UsR, startyp, Nlamtr,                               
     &       nBB, typEntry, Left, Right, nameStar                                                   
      DOUBLE PRECISION TAUslb(npL,npY), fsbol(npY), fpbol(npY), fmax,                               
     &         fmbol(npY), fmed, SLBIntR(npR,npL), SLBIntL(npR,npL),                                  
     &         IstR(npL), AveDev, RMS, maxFerr                                                      
      COMMON /slab/ TAUslb, fsbol, fpbol, fmax, fmbol, fmed, SLBIntR,                               
     &         SLBIntL, IstR, AveDev, RMS, maxFerr                                                  
                                                                                                    
      INTEGER iY, iL, is, error                                 
      DOUBLE PRECISION  ShpL(npL), ShpR(npL), UsL(npL,npY), Faux(npL),
     &        arg, dyn2, Eint2, Eint3, x, res                                                     
c -----------------------------------------------------------------------                           
      dyn2 = 1.0D-20                                                                                                                                                                                  
c     left-side source is always present
      CALL GetSPShape(ShpL,1)                                                                    
      IF(Right.GT.0) THEN                                                                           
         CALL GetSPShape(ShpR,2)                                                                    
      ELSE                                                                                          
        DO iL = 1, nL                                                                               
          ShpR(iL) = 0.0D+00                                                                             
        END DO                                                                                      
      END IF                                                                                        

      DO iY = 1, nY                                                                                
c       loop over wavelengths                                                                       
        DO iL = 1, nL                                                                               
c       find stellar part of flux and en.density                                                        
c       for the source on the left                                                        
c          for diffuse illumination (from a half-plane)                                             
           IF(mu1.eq.-1.0) THEN                                                              
             fsL(iL,iY) = ShpL(iL)*Eint3(TAUslb(iL,iY))                                                
             UsL(iL,iY) = ShpL(iL)*Eint2(TAUslb(iL,iY))                                          
           ELSE                                                                                     
c            for directional illumination                                                           
             x = TAUslb(iL,iY) / mu1                                                                
             IF(x.GE.50.0D+00) THEN                                                                      
               fsL(iL,iY) = 0.0D+00                                                                      
               UsL(iL,iY) = 0.0D+00                                                                      
             ELSE                                                                                   
               fsL(iL,iY) = ShpL(iL)*dexp(-x)                                                           
               UsL(iL,iY) = fsL(iL,iY)/mu1                                                                 
             END IF                                                                                 
           END IF                                                                                   
c          for the second source on the right
           IF(Right.GT.0) THEN                                                                           
             IF(mu2.eq.-1.0D+00) THEN                                                              
c               if diffuse illumination from the right                                                  
                arg = TAUslb(iL,nY)-TAUslb(iL,iY)                                                       
                fsR(iL,iY) = ShpR(iL)*Eint3(arg)                                                           
                UsR(iL,iY) = ShpR(iL)*Eint2(arg)                                              
             ELSE                                                                                     
c               for directional illumination from the right                                             
                x = (TAUslb(iL,nY)-TAUslb(iL,iY)) / mu2                                                
                IF(x.GE.50.0D+00) THEN                                                                      
                   fsR(iL,iY) = 0.0D+00                                                                      
                   UsR(iL,iY) = 0.0D+00                                                                      
                ELSE                                                                                   
                   fsR(iL,iY) = ShpR(iL)*dexp(-x)                                                           
                   UsR(iL,iY) = fsR(iL,iY)/mu2                                                                 
                END IF                                                                                 
             END IF                                                                                   
c           end if for source on the right  
            END IF                                                                                     
        END DO                                                                                      
      END DO                                                                                       
                                                                                                    
      DO iY = 1, nY                                                                                 
c       loop over wavelengths                                                                       
        DO iL = 1, nL                                                                               
          fs(iL,iY) = fsL(iL,iY) - ksi * fsR(iL,iY)                                                 
          Us(iL,iY) = UsL(iL,iY) + ksi * UsR(iL,iY)                                                          
c         here only Us needs limit from below; fs can be negative though!                           
          IF (Us(iL,iY).LT.dyn2) Us(iL,iY) = 0.0D+00                                                    
        END DO                                                                                      
      END DO                                                                                        
                                                                                                    
c     normalize stellar quantities with the stellar bolometric flux                                 
      CALL Bolom(fsL,fsbol)                           
	                                              
c     fsbol(1) is always non-zero for slab                                                          
      DO iY = 1, nY                                                                                 
        DO iL = 1, nL                                                                               
           Us(iL,iY) = Us(iL,iY) / fsbol(1)                                                         
           fs(iL,iY) = fs(iL,iY) / fsbol(1)                                                         
           fsL(iL,iY) = fsL(iL,iY) / fsbol(1)                                                       
           fsR(iL,iY) = fsR(iL,iY) / fsbol(1)                                                       
        END DO                                                                                      
      END DO                                                                                        
cc!   Scale of slab emission in case of diffuse illumination
      IF(mu1.eq.-1.0D+00) THEN                                                              
        DO iL = 1, nL
c         division by lambda b/c all spectra are in lambda*f_lambda units
          Faux(iL) = ShpL(iL)*Eint3(TAUslb(iL,nY)) / lambda(iL)
        END DO
        CALL Simpson(npL,1,nL,lambda,Faux,res)                                                     
        Fdiff = sigma*(Tei**4.0D+00)*(1.0D+00-2.0D+00*res)
        write(18,'(a22)')  'Slab diffuse emission:'                                         
        write(18,'(a15,1p,e10.3)')'Fdiff[W/m2]   =',Fdiff                                          
        write(18,'(a15,1p,e10.3)')'Fext,in[W/m2] =',sigma*(Tei**4.0D+00)                                          
      END IF 
c ^^^^^^^^^^^
      error = 0                                                                                     
      goto 999                                                                                      
998   write(12,*)' *** FATAL ERROR IN DUSTY! *************************'                             
      write(12,*)' File with the spectral shape of external radiation:'                             
      write(12,'(a2,a256)')'  ',nameStar(is)                                                        
      write(12,*)' is missing or not properly formatted?!'                                          
      write(12,*)' ***************************************************'                             
      error = 3                                                                                     
c -----------------------------------------------------------------------                           
999   RETURN                                                                                        
      END                                                                                           
c ***********************************************************************   

                                                                                                    
                                                                                                    
c **********************************************************************                            
      SUBROUTINE SLBTau(TauTot,TAUslb,delT,nL,nY)                                                   
c ======================================================================                            
c It generates TAUslb(npL,npY) grid with given spacing delT, calculated                             
c in sub SLBy. In the current version it is exp near the slab boundaries                            
c and equidistant in the middle.                             [MN,Sep'98]                            
c ======================================================================                            
      IMPLICIT none                                                                                 
      INTEGER nL, nY, iY, iL                                                                        
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      DOUBLE PRECISION TAUslb(npL,npY),TauTot(npL),TAU(npY),delT(npY)                               
c ----------------------------------------------------------------------                            
       TAU(1) = 0.0D+00                                                                                  
       DO iY = 2, nY                                                                                
         TAU(iY) = TAU(iY-1) + delT(iY)                                                             
       END DO                                                                                       
      DO iL = 1, nL                                                                                 
        DO iY = 1, nY                                                                               
          TAUslb(iL,iY) = TauTot(iL)*TAU(iY)/TAU(nY)                                                
        END DO                                                                                      
      END DO                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SLBtrace(TAUmax,TAUTot,TAUslb,Y,mu,h,k,nL,nY)                                      
c ======================================================================                            
c     This subroutine generates the TAU-grid for slab in the case of                                
c     grazing angle of incidence.                            [MN,Jan'99]                            
c ======================================================================                            
      IMPLICIT NONE                                                                                 
      INTEGER nL, nY, iY, iL, Nthick, Nskin, iadj                                                   
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      DOUBLE PRECISION TAUslb(npL,npY), TAUTot(npL), TAU(npY), Y(npY),                              
     &              fsort(npY), TAUmax, mu, h, k, step                                              
c ----------------------------------------------------------------------                            
c     Number of pts. in the skin layer with depth=min{mu1,mu2}:                                     
      Nskin = k/h                                                                                   
c     Counter for the end of the layer adjacent to the skin layer                                   
      iadj = 2*Nskin                                                                                
c     Number of pts. in the opt.thick inner part:                                                   
      Nthick = nY - 4*Nskin                                                                         
      iY = 1                                                                                        
      TAU(1) = 0.0D+00                                                                                  
      TAU(nY) = 1.0D+00                                                                                 
c     resolve the surface boundary layer, where tau = 0 .. k*mu                                     
      DO WHILE(iY.LT.nY/2)                                                                          
      iY = iY + 1                                                                                   
        IF((TAU(iY).LE.k*mu).AND.(iY.LE.Nskin)) THEN                                                
          TAU(iY) = TAU(1) + (iY-1)*h*mu/TAUmax                                                     
          TAU(nY-iY+1) = TAU(nY) - TAU(iY)                                                          
        ELSE                                                                                        
c         resolve the adjacent layer                                                                
          IF(iY.LE.iadj) THEN                                                                       
            TAU(iY) = TAU(iY-1) + h/TAUmax                                                          
            TAU(nY-iY+1) = TAU(nY) - TAU(iY)                                                        
          ELSE                                                                                      
c           for the opt.thick inner part:                                                           
            step = (TAU(nY-iadj+1)-TAU(iadj)) / (Nthick+1)                                          
            TAU(iY) = TAU(iY-1) + step                                                              
            TAU(nY-iY+1) = TAU(nY) - TAU(iY)                                                        
          END IF                                                                                    
        END IF                                                                                      
      END DO                                                                                        
c     sorting (to avoid overlapping or mismatched pieces)                                           
      DO iY = 1, nY                                                                                 
        fsort(iY) = TAU(iY)                                                                         
      END DO                                                                                        
      CALL sort(fsort,nY)                                                                           
      DO iY = 1, nY                                                                                 
        TAU(iY) = fsort(iY)                                                                         
        Y(iY) = TAU(iY)                                                                             
      END DO                                                                                        
      DO iL = 1, nL                                                                                 
        DO iY = 1, nY                                                                               
          TAUslb(iL,iY) = TAUTot(iL)*TAU(iY)                                                        
        END DO                                                                                      
      END DO                                                                                        
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c ***********************************************************************                           
                                                                                                    
c ***********************************************************************                           
      SUBROUTINE SLBy(TAUmax,dTAU,nY)                                                               
c =======================================================================                           
c     This subroutine generates the increment for the initial TAU-grid.                             
c     It is equidistant in TAU in the middle and equidistant in log(TAU)                            
c     near the two faces. It has 15 pts for small (tauV.LE.1) and 30pts                             
c     for large total opt.depth (tauV.LE.1000). In some cases of tauV.GE.500.                       
c     80pts grid is better to start with. If this is the case, uncomment                            
c     the part below with 80pt initial grid. Make sure you have selected proper                     
c     nY in the line for slab calculation in 'userpar.inc'.         [MN,Sep'98]                     
c =======================================================================                           
      IMPLICIT NONE                                                                                 
      INTEGER nY, iY                                                                                
      INTEGER npY, npP, npX, npL, npG, npR                                          
      INCLUDE 'userpar.inc'                                                     
      PARAMETER (npG=1)                                                         
      DOUBLE PRECISION dTAU(npY), TAUmax                                                            
c ----------------------------------------------------------------------                            
      IF(TAUmax.LT.0.1D+00) THEN                                                                        
         nY = 6                                                                                     
         DO iY = 1, nY                                                                              
           IF(iY.LE.3) THEN                                                                         
             dTAU(iY) = 0.5D+00*(dexp(0.5D+00*iY)-dexp(0.5D+00))                                                  
           ELSE IF(iY.GT.3.and.iY.LE.5) THEN                                                        
             dTAU(iY) = dTAU(iY-1)                                                                  
           ELSE                                                                                     
             dTAU(iY) = dTAU(2+nY-iY)                                                               
           END IF                                                                                   
         END DO                                                                                     
      ELSE IF(TAUmax.GE.0.1D+00.AND.TAUmax.LE.10.0D+00) THEN                                                 
         nY = 15                                                                                    
         DO iY = 1, nY                                                                              
           IF(iY.LE.5) THEN                                                                         
             dTAU(iY) = 0.5D+00*(dexp(0.5D+00*iY)-dexp(0.5D+00))                                                  
           ELSE IF(iY.GT.5.and.iY.LE.12) THEN                                                       
             dTAU(iY) = dTAU(iY-1)                                                                  
           ELSE                                                                                     
             dTAU(iY) = dTAU(2+nY-iY)                                                               
           END IF                                                                                   
         END DO                                                                                     
      ELSE IF(TAUmax.GT.10D+00) THEN                                                                    
        nY = 30                                                                                     
        DO iY = 1, nY                                                                               
           IF(iY.LE.10) THEN                                                                        
             dTAU(iY) = 0.5D+00*(dexp(0.5D+00*iY)-dexp(0.5D+00))                                                  
            ELSE IF(iY.GT.10.and.iY.LE.22) THEN                                                     
             dTAU(iY) = dTAU(iY-1)                                                                  
            ELSE                                                                                    
             dTAU(iY) = dTAU(2+nY-iY)                                                               
           END IF                                                                                   
        END DO                                                                                      
      END IF                                                                                        
c     IF(TAUmax.GE.500) THEN                                                                        
c        nY = 80                                                                                    
c        DO iY = 1, nY                                                                              
c          IF(iY.LE.11) THEN                                                                        
c             dTAU(iY) = 0.5*(exp(0.5*iY)-exp(0.5))                                                 
c          ELSE IF(iY.GT.11.and.iY.LE.71) THEN                                                      
c             dTAU(iY) = dTAU(iY-1)                                                                 
c          ELSE                                                                                     
c             dTAU(iY) = dTAU(2+nY-iY)                                                              
c          END IF                                                                                   
c        END DO                                                                                     
c      END IF                                                                                       
c ----------------------------------------------------------------------                            
      RETURN                                                                                        
      END                                                                                           
c *********************************************************************                             
                                                                                                    
c      INCLUDE 'disksubs.for'                                                                       
                                                                                                    
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                           
c                             THE END                                                               
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
